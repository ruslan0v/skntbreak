
--- C:\Users\boobi\source\workmain\src\Skntbreak.Api\Controllers\AdminController.cs ---
using System;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Skntbreak.Application.Services;
using Skntbreak.Core.Dto.Admin;
using Skntbreak.Core.Dto.BreakPoolDay;
using Skntbreak.Core.Dto.Schedules;
using Skntbreak.Core.Enums;
using Skntbreak.Core.Interfaces;

namespace Skntbreak.Api.Controllers
{
    [Route("api/[controller]")]
    [ApiController]
    [Authorize(Policy = "AdminOnly")]
    public class AdminController : ControllerBase
    {
        private readonly IAdminService _adminService;

        public AdminController(IAdminService adminService)
        {
            _adminService = adminService;
        }

        // ==================== СТАТИСТИКА ====================

        [HttpGet("stats")]
        public async Task<IActionResult> GetDashboardStats()
        {
            try
            {
                var stats = await _adminService.GetDashboardStats();
                return Ok(stats);
            }
            catch (Exception ex)
            {
                return BadRequest(new { error = ex.Message });
            }
        }

        [HttpGet("shifts/today")]
        public async Task<IActionResult> GetTodayShifts()
        {
            try
            {
                var shifts = await _adminService.GetTodayShifts();
                return Ok(shifts);
            }
            catch (Exception ex)
            {
                return BadRequest(new { error = ex.Message });
            }
        }

        // ==================== ПОЛЬЗОВАТЕЛИ ====================

        [HttpGet("users")]
        public async Task<IActionResult> GetAllUsers()
        {
            try
            {
                var users = await _adminService.GetAllUsers();
                return Ok(users);
            }
            catch (Exception ex)
            {
                return BadRequest(new { error = ex.Message });
            }
        }

        [HttpGet("users/{id}")]
        public async Task<IActionResult> GetUser(int id)
        {
            try
            {
                var user = await _adminService.GetUserById(id);
                return Ok(user);
            }
            catch (Exception ex)
            {
                return NotFound(new { error = ex.Message });
            }
        }

        [HttpPost("users")]
        public async Task<IActionResult> CreateUser([FromBody] CreateUserAdminDto request)
        {
            try
            {
                var user = await _adminService.CreateUser(request);
                return Ok(user);
            }
            catch (Exception ex)
            {
                return BadRequest(new { error = ex.Message });
            }
        }

        [HttpPut("users/{id}")]
        public async Task<IActionResult> UpdateUser(int id, [FromBody] UpdateUserAdminDto request)
        {
            try
            {
                var user = await _adminService.UpdateUser(id, request);
                return Ok(user);
            }
            catch (Exception ex)
            {
                return BadRequest(new { error = ex.Message });
            }
        }

        [HttpDelete("users/{id}")]
        public async Task<IActionResult> DeleteUser(int id)
        {
            try
            {
                await _adminService.DeleteUser(id);
                return Ok(new { message = "Пользователь удалён" });
            }
            catch (Exception ex)
            {
                return BadRequest(new { error = ex.Message });
            }
        }

        // ==================== РАСПИСАНИЯ ====================

        [HttpGet("schedules")]
        public async Task<IActionResult> GetAllSchedules()
        {
            try
            {
                var schedules = await _adminService.GetAllSchedules();
                return Ok(schedules);
            }
            catch (Exception ex)
            {
                return BadRequest(new { error = ex.Message });
            }
        }

        [HttpGet("schedules/{id}")]
        public async Task<IActionResult> GetSchedule(int id)
        {
            try
            {
                var schedule = await _adminService.GetScheduleById(id);
                return Ok(schedule);
            }
            catch (Exception ex)
            {
                return NotFound(new { error = ex.Message });
            }
        }

        [HttpPost("schedules")]
        public async Task<IActionResult> CreateSchedule([FromBody] CreateScheduleDto request)
        {
            try
            {
                var schedule = await _adminService.CreateSchedule(request);
                return Ok(schedule);
            }
            catch (Exception ex)
            {
                return BadRequest(new { error = ex.Message });
            }
        }

        [HttpPut("schedules/{id}")]
        public async Task<IActionResult> UpdateSchedule(int id, [FromBody] UpdateScheduleDto request)
        {
            try
            {
                var schedule = await _adminService.UpdateSchedule(id, request);
                return Ok(schedule);
            }
            catch (Exception ex)
            {
                return BadRequest(new { error = ex.Message });
            }
        }

        [HttpDelete("schedules/{id}")]
        public async Task<IActionResult> DeleteSchedule(int id)
        {
            try
            {
                await _adminService.DeleteSchedule(id);
                return Ok(new { message = "Расписание удалено" });
            }
            catch (Exception ex)
            {
                return BadRequest(new { error = ex.Message });
            }
        }

        // ==================== ПУЛЫ ПЕРЕРЫВОВ ====================

        [HttpGet("break-pools")]
        public async Task<IActionResult> GetAllBreakPools()
        {
            try
            {
                var pools = await _adminService.GetAllBreakPools();
                return Ok(pools);
            }
            catch (Exception ex)
            {
                return BadRequest(new { error = ex.Message });
            }
        }

        [HttpGet("break-pools/{date}/{shift}")]
        public async Task<IActionResult> GetBreakPool(string date, int shift)
        {
            try
            {
                var workDate = DateOnly.Parse(date);
                var shiftType = (ShiftType)shift;
                var pool = await _adminService.GetBreakPoolByDateAndShift(workDate, shiftType);
                return Ok(pool);
            }
            catch (Exception ex)
            {
                return NotFound(new { error = ex.Message });
            }
        }

        [HttpPost("break-pools")]
        public async Task<IActionResult> CreateOrUpdateBreakPool([FromBody] CreateBreakPoolDayDto request)
        {
            try
            {
                var pool = await _adminService.CreateOrUpdateBreakPool(request);
                return Ok(pool);
            }
            catch (Exception ex)
            {
                return BadRequest(new { error = ex.Message });
            }
        }

        [HttpPost("shifts/{userShiftId}/end")]
        public async Task<IActionResult> EndUserShift(int userShiftId)
        {
            try
            {
                var userShift = await _adminService.EndUserShiftAsync(userShiftId);
                return Ok(new { message = "Смена завершена", endedAt = userShift.EndedAt });
            }
            catch (Exception ex)
            {
                return BadRequest(new { error = ex.Message });
            }
        }
    }
}



--- C:\Users\boobi\source\workmain\src\Skntbreak.Api\Controllers\BreakQueueController.cs ---
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Skntbreak.Core.Dto.Queue;
using Skntbreak.Core.Interfaces;

namespace Skntbreak.Api.Controllers
{
    [Route("api/[controller]")]
    [ApiController]
    [Authorize]
    public class BreakQueueController : ControllerBase
    {
        private readonly IBreakQueueService _queueService;

        public BreakQueueController(IBreakQueueService queueService)
        {
            _queueService = queueService;
        }

        [HttpPost("enqueue")]
        public async Task<IActionResult> Enqueue([FromBody] EnqueueRequestDto request)
        {
            try
            {
                var userId = GetCurrentUserId();
                var result = await _queueService.EnqueueAsync(userId, request.DurationMinutes);
                return Ok(result);
            }
            catch (InvalidOperationException ex)
            {
                return BadRequest(new { error = ex.Message });
            }
        }

        [HttpGet("state")]
        public async Task<IActionResult> GetState()
        {
            try
            {
                var userId = GetCurrentUserId();
                var state = await _queueService.GetQueueStateAsync(userId);
                return Ok(state);
            }
            catch (Exception ex)
            {
                return BadRequest(new { error = ex.Message });
            }
        }

        [HttpPost("confirm/{queueEntryId}")]
        public async Task<IActionResult> Confirm(int queueEntryId)
        {
            try
            {
                var userId = GetCurrentUserId();
                var result = await _queueService.ConfirmBreakAsync(userId, queueEntryId);
                return Ok(result);
            }
            catch (InvalidOperationException ex)
            {
                return BadRequest(new { error = ex.Message });
            }
            catch (UnauthorizedAccessException ex)
            {
                return Forbid(ex.Message);
            }
        }

        [HttpPost("postpone/{queueEntryId}")]
        public async Task<IActionResult> Postpone(int queueEntryId)
        {
            try
            {
                var userId = GetCurrentUserId();
                var result = await _queueService.PostponeAsync(userId, queueEntryId);
                return Ok(result);
            }
            catch (InvalidOperationException ex)
            {
                return BadRequest(new { error = ex.Message });
            }
        }

        [HttpPost("skip-round")]
        public async Task<IActionResult> SkipRound()
        {
            try
            {
                var userId = GetCurrentUserId();
                await _queueService.SkipBreakRoundAsync(userId);
                return Ok(new { message = "Перерыв пропущен" });
            }
            catch (InvalidOperationException ex)
            {
                return BadRequest(new { error = ex.Message });
            }
        }

        [HttpPost("priority/{targetUserId}")]
        [Authorize(Policy = "TeamLeadOrAdmin")]
        public async Task<IActionResult> PriorityBreak(
            int targetUserId,
            [FromBody] EnqueueRequestDto? request = null)
        {
            try
            {
                var requestingUserId = GetCurrentUserId();
                var result = await _queueService.EnqueuePriorityAsync(
                    targetUserId, requestingUserId, request?.DurationMinutes);
                return Ok(result);
            }
            catch (Exception ex)
            {
                return BadRequest(new { error = ex.Message });
            }
        }

        private int GetCurrentUserId()
        {
            var userIdClaim = User.FindFirst("userId")?.Value;
            if (string.IsNullOrEmpty(userIdClaim) || !int.TryParse(userIdClaim, out var userId))
                throw new UnauthorizedAccessException("Пользователь не авторизован");
            return userId;
        }
    }
}

--- C:\Users\boobi\source\workmain\src\Skntbreak.Api\Controllers\BreaksController.cs ---
using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Skntbreak.Core.Dto.Break;
using Skntbreak.Core.Interfaces;

namespace Skntbreak.Api.Controllers
{
    [Route("api/[controller]")]
    [ApiController]
    [Authorize]
    public class BreaksController : ControllerBase
    {
        private readonly IBreakService _breakService;

        public BreaksController(IBreakService breakService)
        {
            _breakService = breakService;
        }

        // Взять перерыв
        [HttpPost("start")]
        public async Task<IActionResult> StartBreak([FromBody] StartBreakDto request)
        {
            var userId = GetCurrentUserId();
            try
            {
                var activeBreak = await _breakService.StartBreakAsync(request, userId);
                return Ok(activeBreak);
            }
            catch (Exception ex)
            {
                return BadRequest(new { error = ex.Message });
            }
        }

        // Завершить свой активный перерыв
        [HttpPost("end/{breakId}")]
        public async Task<IActionResult> EndBreak(int breakId)
        {
            try
            {
                var userId = GetCurrentUserId();
                var endedBreak = await _breakService.EndBreakAsync(breakId, userId);
                return Ok(endedBreak);
            }
            catch (Exception ex)
            {
                return BadRequest(new { error = ex.Message });
            }
        }

        // Пропустить перерыв
        [HttpPost("skip")]
        public async Task<IActionResult> SkipBreak([FromBody] SkipBreakDto request)
        {
            var userId = GetCurrentUserId();
            try
            {
                var skippedBreak = await _breakService.SkipBreakAsync(request, userId);
                return Ok(skippedBreak);
            }
            catch (Exception ex)
            {
                return BadRequest(new { error = ex.Message });
            }
        }

        // НОВОЕ: Получить свой активный перерыв
        [HttpGet("my-active")]
        public async Task<IActionResult> GetMyActiveBreak()
        {
            try
            {
                var userId = GetCurrentUserId();
                var activeBreak = await _breakService.GetUserActiveBreakAsync(userId);

                if (activeBreak == null)
                    return Ok(new { hasActiveBreak = false });

                return Ok(new { hasActiveBreak = true, breakData = activeBreak });
            }
            catch (Exception ex)
            {
                return BadRequest(new { error = ex.Message });
            }
        }

        // НОВОЕ: Получить все активные перерывы в моей смене
        [HttpGet("active-in-shift")]
        public async Task<IActionResult> GetActiveBreaksInMyShift([FromQuery] string date)
        {
            try
            {
                var userId = GetCurrentUserId();
                var workDate = DateOnly.Parse(date);

                var allActiveBreaks = await _breakService.GetActiveBreaksByDateAsync(workDate, userId);
                return Ok(allActiveBreaks);
            }
            catch (Exception ex)
            {
                return BadRequest(new { error = ex.Message });
            }
        }

        // НОВОЕ: История перерывов пользователя
        [HttpGet("my-history")]
        public async Task<IActionResult> GetMyBreakHistory([FromQuery] string date)
        {
            try
            {
                var userId = GetCurrentUserId();
                var workDate = DateOnly.Parse(date);
                var history = await _breakService.GetUserBreakHistoryAsync(userId, workDate);
                return Ok(history);
            }
            catch (Exception ex)
            {
                return BadRequest(new { error = ex.Message });
            }
        }

        private int GetCurrentUserId()
        {
            var userIdClaim = User.FindFirst("userId")?.Value;
            if (string.IsNullOrEmpty(userIdClaim) || !int.TryParse(userIdClaim, out var userId))
                throw new UnauthorizedAccessException("Пользователь не авторизован");
            return userId;
        }

        [HttpGet("pool-info")]
        public async Task<IActionResult> GetBreakPoolInfo([FromQuery] string date)
        {
            try
            {
                var userId = GetCurrentUserId();
                var workDate = DateOnly.Parse(date);

                var poolInfo = await _breakService.GetBreakPoolInfoAsync(workDate, userId);
                return Ok(poolInfo);
            }
            catch (Exception ex)
            {
                return BadRequest(new { error = ex.Message });
            }
        }
    }
}


--- C:\Users\boobi\source\workmain\src\Skntbreak.Api\Controllers\DashboardController.cs ---
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;

namespace Skntbreak.Api.Controllers
{
    [Route("api/[controller]")]
    [Authorize]
    [ApiController]
    public class DashboardController : ControllerBase
    {

    }
}


--- C:\Users\boobi\source\workmain\src\Skntbreak.Api\Controllers\PoolsController.cs ---
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using Skntbreak.Core.Entities;
using Skntbreak.Core.Enums;
using Skntbreak.Core.Interfaces;

namespace Skntbreak.Api.Controllers
{
    [Route("api/[controller]")]
    [Authorize(Policy = "TeamLeadOrAdmin")]
    [ApiController]
    public class PoolsController : ControllerBase
    {
        private readonly IBreakPoolDayRepository _poolRepository;
        
        public PoolsController(IBreakPoolDayRepository poolRepository)
        {
            _poolRepository = poolRepository;
        }

        [HttpPost("seed")]
        public async Task<IActionResult> Seed([FromQuery] DateOnly? date = null, [FromQuery] int breaks = 2)
        {
            var d = date ?? DateOnly.FromDateTime(DateTime.UtcNow.Date);

            async Task EnsureAsync(ShiftType shift, int total)
            {
                var exist = await _poolRepository.GetByDateAndShiftAsync(d, shift);
                if (exist == null)
                    await _poolRepository.AddAsync(new BreakPoolDay { Group = shift, WorkDate = d, TotalBreaks = total, AvailableBreaks = total });
            }

            await EnsureAsync(ShiftType.Day, breaks);
            await EnsureAsync(ShiftType.Evening, breaks);

            return Ok(new { date = d, breaks });
        }
    }
}


--- C:\Users\boobi\source\workmain\src\Skntbreak.Api\Controllers\ScheduleController.cs ---
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Skntbreak.Core.Dto.Schedules;
using Skntbreak.Core.Entities;
using Skntbreak.Core.Interfaces;

namespace Skntbreak.Api.Controllers.Admin
{
    [Route("api/[controller]")]
    [ApiController]
    public class ScheduleController : ControllerBase
    {
        private readonly IScheduleService _scheduleService;

        public ScheduleController(IScheduleService scheduleService)
        {
            _scheduleService = scheduleService;
        }

        // Доступно ВСЕМ авторизованным пользователям
        [Authorize]
        [HttpGet("getall")]
        public async Task<ActionResult<IEnumerable<Schedule>>> GetAllSchedules()
        {
            try
            {
                var result = await _scheduleService.GetAllSchedules();
                return Ok(result);
            }
            catch (Exception ex)
            {
                return BadRequest(new { error = ex.Message });
            }
        }

        // Доступно ВСЕМ авторизованным пользователям
        [Authorize]
        [HttpGet("{id}")]
        public async Task<ActionResult<Schedule>> GetSchedule([FromRoute] int id)
        {
            try
            {
                var result = await _scheduleService.GetScheduleById(id);
                if (result == null)
                {
                    return NotFound(new { error = $"Расписание с ID {id} не найдено" });
                }
                return Ok(result);
            }
            catch (Exception ex)
            {
                return BadRequest(new { error = ex.Message });
            }
        }

        // Только TeamLead и Admin
        [Authorize(Policy = "TeamLeadOrAdmin")]
        [HttpPost("create")]
        public async Task<ActionResult<Schedule>> CreateSchedule([FromBody] CreateScheduleDto createScheduleDto)
        {
            try
            {
                var result = await _scheduleService.CreateSchedule(createScheduleDto);
                if (result == null)
                {
                    return BadRequest(new { error = "Не удалось создать расписание" });
                }
                return Ok(result);
            }
            catch (Exception ex)
            {
                return BadRequest(new { error = ex.Message });
            }
        }

        // Только TeamLead и Admin
        [Authorize(Policy = "TeamLeadOrAdmin")]
        [HttpPut("update/{id}")]  // Исправлено: убран пробел
        public async Task<ActionResult<Schedule>> UpdateSchedule(int id, [FromBody] UpdateScheduleDto updateScheduleDto)
        {
            try
            {
                var result = await _scheduleService.UpdateSchedule(id, updateScheduleDto);
                if (result == null)
                {
                    return NotFound(new { error = $"Расписание с ID {id} не найдено" });
                }
                return Ok(result);
            }
            catch (Exception ex)
            {
                return BadRequest(new { error = ex.Message });
            }
        }

        // Только TeamLead и Admin
        [Authorize(Policy = "TeamLeadOrAdmin")]
        [HttpDelete("{id}")]  // Исправлено: POST → DELETE
        public async Task<ActionResult> DeleteSchedule([FromRoute] int id)
        {
            try
            {
                var result = await _scheduleService.DeleteSchedule(id);
                if (result == null)
                {
                    return NotFound(new { error = $"Расписание с ID {id} не найдено" });
                }
                return Ok(new { message = "Расписание удалено" });
            }
            catch (Exception ex)
            {
                return BadRequest(new { error = ex.Message });
            }
        }
    }
}


--- C:\Users\boobi\source\workmain\src\Skntbreak.Api\Controllers\UsersController.cs ---
using System;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using Skntbreak.Application.Interfaces;
using Skntbreak.Application.Services;
using Skntbreak.Core.Dto.Users;
using Skntbreak.Core.Enums;
using Skntbreak.Core.Interfaces;
using SkntBreak.Infrastructure.Data.Repositories;

namespace Skntbreak.Api.Controllers
{
    [Route("api/[controller]")]
    [ApiController]
    public class UsersController : ControllerBase
    {
        private readonly IUserService _userService;

        public UsersController(IUserService userService)
        {
            _userService = userService;
        }

        [HttpPost("register")]
        [Authorize(Policy = "AdminOnly")]
        public async Task<IActionResult> Register(RegisterUserRequest request)
        {
            try
            {
                await _userService.Register(request.UserName, request.Login, request.Password);
                return Ok(new { message = "Пользователь успешно зарегистрирован" });
            }
            catch (Exception ex)
            {
                return BadRequest(new { error = ex.Message });
            }
        }

        [HttpPost("login")]
        public async Task<IActionResult> Login(LoginUserRequest request)
        {
            var token = await _userService.Login(request.Login, request.Password);

            Response.Cookies.Append("cookies", token);

            return Ok(new { token });
        }

        [HttpGet("profile")]
        [Authorize]
        public async Task<IActionResult> GetProfile()
        {
            try
            {
                var userId = GetCurrentUserId();
                var profile = await _userService.GetProfile(userId);
                return Ok(profile);
            }
            catch (Exception ex)
            {
                return BadRequest(new { error = ex.Message });
            }
        }

        [HttpPut("profile")]
        [Authorize]
        public async Task<IActionResult> UpdateProfile([FromBody] UpdateProfileDto request)
        {
            try
            {
                var userId = GetCurrentUserId();
                await _userService.UpdateProfile(userId, request);
                return Ok(new { message = "Профиль обновлён" });
            }
            catch (Exception ex)
            {
                return BadRequest(new { error = ex.Message });
            }
        }

        private int GetCurrentUserId()
        {
            var userIdClaim = User.FindFirst("userId")?.Value;
            if (string.IsNullOrEmpty(userIdClaim) || !int.TryParse(userIdClaim, out var userId))
            {
                throw new UnauthorizedAccessException("Необходима авторизация");
            }
            return userId;
        }
    }
 }


--- C:\Users\boobi\source\workmain\src\Skntbreak.Api\Controllers\UserShiftsController.cs ---
using System;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Skntbreak.Core.Dto.UserShift;
using Skntbreak.Core.Enums;
using Skntbreak.Core.Interfaces;

namespace Skntbreak.Api.Controllers
{
    [Route("api/[controller]")]
    [ApiController]
    [Authorize]
    public class UserShiftsController : ControllerBase
    {
        private readonly IUserShiftService _shiftService;

        public UserShiftsController(IUserShiftService shiftService)
        {
            _shiftService = shiftService;
        }

        [HttpPost("start")]
        public async Task<IActionResult> StartShift([FromBody] StartShiftRequest request)
        {
            try
            {
                var userId = GetCurrentUserId();

                var userShift = await _shiftService.StartShiftAsync(
                    userId,
                    request.ScheduleId
                );

                // Р’РѕР·РІСЂР°С‰Р°РµРј DTO РІРјРµСЃС‚Рѕ entity
                var result = new
                {
                    userShift.Id,
                    userShift.UserId,
                    userShift.ScheduleId,
                    userShift.WorkDate,
                    userShift.Group,
                    userShift.StartedAt,
                    Schedule = userShift.Schedule == null ? null : new
                    {
                        userShift.Schedule.Id,
                        userShift.Schedule.Name,
                        userShift.Schedule.StartTime,
                        userShift.Schedule.EndTime,
                        userShift.Schedule.ShiftType
                    },
                    Breaks = userShift.Breaks?.Select(b => new
                    {
                        b.Id,
                        b.Status,
                        b.DurationMinutes,
                        b.BreakNumber,
                        b.StartTime,
                        b.EndTime
                    }).ToList()
                };

                return Ok(result);
            }
            catch (UnauthorizedAccessException ex)
            {
                Console.WriteLine($"[StartShift] UnauthorizedAccessException: {ex.Message}");
                return Unauthorized(new { error = ex.Message });
            }
            catch (ArgumentException ex)
            {
                Console.WriteLine($"[StartShift] ArgumentException: {ex.Message}");
                return BadRequest(new { error = ex.Message });
            }
            catch (InvalidOperationException ex)
            {
                Console.WriteLine($"[StartShift] InvalidOperationException: {ex.Message}");
                return Conflict(new { error = ex.Message });
            }
            catch (Exception ex)
            {
                Console.WriteLine($"[StartShift] Exception: {ex.Message}");
                return StatusCode(500, new { error = ex.Message });
            }
        }



        [HttpGet("my/{workDate}")]
        public async Task<IActionResult> GetMyShift(DateOnly workDate)
        {
            try
            {
                var userId = GetCurrentUserId();
                var userShift = await _shiftService.GetUserShiftAsync(userId, workDate);

                if (userShift == null)
                    return NotFound(new { error = "РЎРјРµРЅР° РЅРµ РЅР°Р№РґРµРЅР°" });

                // РџСЂРµРѕР±СЂР°Р·СѓРµРј РІ DTO
                var result = new
                {
                    userShift.Id,
                    userShift.UserId,
                    userShift.ScheduleId,
                    userShift.WorkDate,
                    userShift.Group,
                    Schedule = userShift.Schedule == null ? null : new
                    {
                        userShift.Schedule.Id,
                        userShift.Schedule.Name,
                        userShift.Schedule.StartTime,
                        userShift.Schedule.EndTime
                    },
                    Breaks = userShift.Breaks?.Select(b => new
                    {
                        b.Id,
                        b.Status,
                        b.DurationMinutes,
                        b.BreakNumber,
                        b.StartTime,
                        b.EndTime
                    }).ToList()
                };

                return Ok(result);
            }
            catch (Exception ex)
            {
                Console.WriteLine($"[GetMyShift] Error: {ex.Message}");
                return StatusCode(500, new { error = ex.Message });
            }
        }

        [HttpGet("my")]
        public async Task<IActionResult> GetMyShifts()
        {
            try
            {
                var userId = GetCurrentUserId();
                var userShifts = await _shiftService.GetUserShiftsAsync(userId);

                // РџСЂРµРѕР±СЂР°Р·СѓРµРј РІ DTO
                var result = userShifts.Select(us => new
                {
                    us.Id,
                    us.UserId,
                    us.ScheduleId,
                    us.WorkDate,
                    us.Group,
                    Schedule = us.Schedule == null ? null : new
                    {
                        us.Schedule.Id,
                        us.Schedule.Name,
                        us.Schedule.StartTime,
                        us.Schedule.EndTime
                    },
                    Breaks = us.Breaks?.Select(b => new
                    {
                        b.Id,
                        b.Status,
                        b.DurationMinutes,
                        b.BreakNumber,
                        b.StartTime,
                        b.EndTime
                    }).ToList()
                });

                return Ok(result);
            }
            catch (Exception ex)
            {
                Console.WriteLine($"[GetMyShifts] Error: {ex.Message}");
                return StatusCode(500, new { error = ex.Message });
            }
        }



        [HttpDelete("{userShiftId}")]
        public async Task<IActionResult> DeleteShift(int userShiftId)
        {
            try
            {
                var userId = GetCurrentUserId();
                await _shiftService.DeleteUserShiftAsync(userShiftId, userId);
                return Ok(new { message = "РЎРјРµРЅР° СѓРґР°Р»РµРЅР°" });
            }
            catch (ArgumentException ex)
            {
                return NotFound(new { error = ex.Message });
            }
            catch (UnauthorizedAccessException ex)
            {
                return Forbid(ex.Message);
            }
            catch (Exception ex)
            {
                return BadRequest(new { error = ex.Message });
            }
        }

        [HttpGet("by-date-group/{workDate}/{group}")]
        public async Task<IActionResult> GetShiftsByDateAndGroup(DateOnly workDate, ShiftType group)
        {
            try
            {
                var shifts = await _shiftService.GetShiftsByDateAndGroupAsync(workDate, group);
                return Ok(shifts);
            }
            catch (Exception ex)
            {
                return BadRequest(new { error = ex.Message });
            }
        }

        [HttpGet("colleagues")]
        public async Task<IActionResult> GetColleagues([FromQuery] int scheduleId, [FromQuery] DateOnly workDate)
        {
            try
            {
                var userId = GetCurrentUserId();
                var colleagues = await _shiftService.GetColleaguesAsync(scheduleId, workDate, userId);

                return Ok(colleagues);
            }
            catch (Exception ex)
            {
                Console.WriteLine($"[GetColleagues] Error: {ex.Message}");
                return StatusCode(500, new { error = ex.Message });
            }
        }

        [HttpPost("end")]
        public async Task<IActionResult> EndShift()
        {
            try
            {
                var userId = GetCurrentUserId();
                var userShift = await _shiftService.EndShiftAsync(userId);

                return Ok(new
                {
                    message = "РЎРјРµРЅР° Р·Р°РІРµСЂС€РµРЅР°",
                    endedAt = userShift.EndedAt,
                    duration = userShift.EndedAt.Value - userShift.StartedAt
                });
            }
            catch (InvalidOperationException ex)
            {
                return BadRequest(new { error = ex.Message });
            }
        }

        [HttpGet("available")]  // в†ђ Р”Рћ [HttpGet("my/{workDate}")]
        public async Task<IActionResult> GetAvailableSchedules()
        {
            try
            {
                var schedules = await _shiftService.GetAvailableSchedulesAsync();
                var result = schedules.Select(s => new
                {
                    id = s.Id,
                    name = s.Name,
                    startTime = s.StartTime.ToString(@"hh\:mm"),
                    endTime = s.EndTime.ToString(@"hh\:mm"),
                    shiftType = s.ShiftType
                });
                return Ok(result);
            }
            catch (Exception ex)
            {
                return BadRequest(new { error = ex.Message });
            }
        }

        private int GetCurrentUserId()
        {
            Console.WriteLine($"[GetCurrentUserId] Checking claims...");
            Console.WriteLine($"[GetCurrentUserId] User.Identity.IsAuthenticated: {User.Identity?.IsAuthenticated}");

            var userIdClaim = User.FindFirst("userId")?.Value;

            Console.WriteLine($"[GetCurrentUserId] userId claim: {userIdClaim}");

            if (string.IsNullOrEmpty(userIdClaim) || !int.TryParse(userIdClaim, out var userId))
            {
                Console.WriteLine($"[GetCurrentUserId] вќЊ Failed to parse userId");
                throw new UnauthorizedAccessException("РџРѕР»СЊР·РѕРІР°С‚РµР»СЊ РЅРµ Р°РІС‚РѕСЂРёР·РѕРІР°РЅ");
            }

            Console.WriteLine($"[GetCurrentUserId] вњ… UserId parsed: {userId}");
            return userId;
        }
    }
}


--- C:\Users\boobi\source\workmain\src\Skntbreak.Api\Hubs\BreakQueueHub.cs ---
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.SignalR;
using Skntbreak.Core.Interfaces;
using Skntbreak.Core.Dto.Queue;


namespace Skntbreak.Api.Hubs
{
    [Authorize]
    public class BreakQueueHub : Hub<IBreakQueueClient>
    {
        private readonly IUserShiftRepository _userShiftRepo;

        public BreakQueueHub(IUserShiftRepository userShiftRepo)
        {
            _userShiftRepo = userShiftRepo;
        }

        public override async Task OnConnectedAsync()
        {
            var userIdStr = Context.User?.FindFirst("userId")?.Value;
            if (int.TryParse(userIdStr, out var userId))
            {
                // Автоматически подписываем на группу текущей смены
                var activeShift = await _userShiftRepo.GetActiveShiftAsync(userId);
                if (activeShift != null)
                {
                    string groupKey = $"{activeShift.WorkDate:yyyy-MM-dd}_{(int)activeShift.Group}";
                    await Groups.AddToGroupAsync(Context.ConnectionId, groupKey);
                }
            }

            await base.OnConnectedAsync();
        }

        public override async Task OnDisconnectedAsync(Exception? exception)
        {
            // Группы автоматически очищаются при дисконнекте
            await base.OnDisconnectedAsync(exception);
        }

        // Клиент может вручную подписаться на конкретную группу
        public async Task JoinShiftGroup(string workDate, int group)
        {
            string groupKey = $"{workDate}_{group}";
            await Groups.AddToGroupAsync(Context.ConnectionId, groupKey);
        }

        public async Task LeaveShiftGroup(string workDate, int group)
        {
            string groupKey = $"{workDate}_{group}";
            await Groups.RemoveFromGroupAsync(Context.ConnectionId, groupKey);
        }
    }
}

--- C:\Users\boobi\source\workmain\src\Skntbreak.Api\Hubs\BreakQueueNotifier.cs ---
// Skntbreak.Api/Services/BreakQueueNotifier.cs
using Microsoft.AspNetCore.SignalR;
using Skntbreak.Api.Hubs;
using Skntbreak.Core.Dto.Queue;
using Skntbreak.Core.Interfaces;

namespace Skntbreak.Api.Services
{
    public class BreakQueueNotifier : IBreakQueueNotifier
    {
        private readonly IHubContext<BreakQueueHub, IBreakQueueClient> _hub;

        public BreakQueueNotifier(IHubContext<BreakQueueHub, IBreakQueueClient> hub)
        {
            _hub = hub;
        }

        public async Task NotifyYourTurnAsync(int userId, int queueEntryId, int durationMinutes, int timeoutSeconds)
        {
            await _hub.Clients.User(userId.ToString())
                .YourTurn(queueEntryId, durationMinutes, timeoutSeconds);
        }

        public async Task NotifyExpiredAsync(int userId, int queueEntryId, int newPosition)
        {
            await _hub.Clients.User(userId.ToString())
                .NotificationExpired(queueEntryId, newPosition);
        }

        public async Task BroadcastQueueUpdateAsync(
            DateOnly workDate, int group, List<QueueEntryDto> queue, int availableSlots, int currentRound)
        {
            string groupKey = $"{workDate:yyyy-MM-dd}_{group}";
            await _hub.Clients.Group(groupKey)
                .QueueUpdated(queue, availableSlots, currentRound);
        }

        public async Task BroadcastBreakEndedAsync(
            DateOnly workDate, int group, int userId, string userName, int breakRound)
        {
            string groupKey = $"{workDate:yyyy-MM-dd}_{group}";
            await _hub.Clients.Group(groupKey)
                .BreakEnded(userId, userName, breakRound);
        }
    }
}


--- C:\Users\boobi\source\workmain\src\Skntbreak.Api\Program.cs ---
using System.Text;
using Microsoft.AspNetCore.Authentication.JwtBearer;
using Microsoft.AspNetCore.CookiePolicy;
using Microsoft.EntityFrameworkCore;
using Microsoft.IdentityModel.Tokens;
using Microsoft.OpenApi.Models;
using Skntbreak.Api.Hubs;
using Skntbreak.Api.Services;
using Skntbreak.Application.Interfaces;
using Skntbreak.Application.Services;
using Skntbreak.Core.Interfaces;
using Skntbreak.Infrastructure.Data.Repositories;
using Skntbreak.Infrastructure.Helpers;
using SkntBreak.Infrastructure.Data;
using SkntBreak.Infrastructure.Data.Repositories;

var builder = WebApplication.CreateBuilder(args);
var configuration = builder.Configuration;

builder.Services.Configure<JwtOptions>(configuration.GetSection(nameof(JwtOptions)));

builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
   .AddJwtBearer(options =>
   {
       options.TokenValidationParameters = new TokenValidationParameters
       {
           ValidateIssuer = false,
           ValidateAudience = false,
           ValidateLifetime = true,
           ValidateIssuerSigningKey = true,
           IssuerSigningKey = new SymmetricSecurityKey(
    Encoding.UTF8.GetBytes(
        configuration.GetSection(nameof(JwtOptions))[nameof(JwtOptions.SecretKey)]!
    ))
       };

       options.Events = new JwtBearerEvents
       {
           OnMessageReceived = context =>
           {
               var accessToken = context.Request.Query["access_token"];
               var path = context.HttpContext.Request.Path;

               // Р”Р»СЏ WebSockets Рё SignalR РёР·РІР»РµРєР°РµРј С‚РѕРєРµРЅ РёР· query string
               if (!string.IsNullOrEmpty(accessToken) && path.StartsWithSegments("/breakQueueHub"))
               {
                   context.Token = accessToken;
               }
               // РРЅР°С‡Рµ СЃРЅР°С‡Р°Р»Р° РїС‹С‚Р°РµРјСЃСЏ РїСЂРѕС‡РёС‚Р°С‚СЊ С‚РѕРєРµРЅ РёР· cookie
               else if (context.Request.Cookies.TryGetValue("cookies", out var tokenFromCookie))
               {
                   // Р•СЃР»Рё РІ Р·Р°РіРѕР»РѕРІРєРµ Authorization РЅРµС‚ С‚РѕРєРµРЅР°, РёСЃРїРѕР»СЊР·СѓРµРј С‚РѕРєРµРЅ РёР· cookie
                   if (string.IsNullOrEmpty(context.Request.Headers["Authorization"]))
                   {
                       context.Token = tokenFromCookie;
                   }
               }
               return Task.CompletedTask;
           }
       };
   });

builder.Services.AddAuthorization(options =>
{
    options.AddPolicy("AdminOnly", policy => policy.RequireRole("Admin"));
    options.AddPolicy("TeamLeadOrAdmin", policy => policy.RequireRole("TeamLead", "Admin"));
    options.AddPolicy("RequireAuth", policy => policy.RequireAuthenticatedUser());
});

builder.Services.AddControllers();
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen(setup =>
{
    var jwtSecurityScheme = new OpenApiSecurityScheme
    {
        BearerFormat = "JWT",
        Name = "JWT Authentication",
        In = ParameterLocation.Header,
        Type = SecuritySchemeType.Http,
        Scheme = JwtBearerDefaults.AuthenticationScheme,
        Description = "Put **_ONLY_** your JWT Bearer token on textbox below!",
        Reference = new OpenApiReference
        {
            Id = JwtBearerDefaults.AuthenticationScheme,
            Type = ReferenceType.SecurityScheme
        }
    };

    setup.AddSecurityDefinition(jwtSecurityScheme.Reference.Id, jwtSecurityScheme);

    setup.AddSecurityRequirement(new OpenApiSecurityRequirement
    {
        { jwtSecurityScheme, Array.Empty<string>() }
    });
});

builder.Services.AddSignalR();

builder.Services.AddDbContext<SkntbreakDbContext>(
    options =>
    {
        options.UseNpgsql(configuration.GetConnectionString(nameof(SkntbreakDbContext)));
    });

builder.Services.AddCors(options =>
{
    options.AddPolicy("AllowFrontend", policy =>
    {
        policy.WithOrigins("http://localhost:5173", "https://localhost:7059")
             .AllowAnyMethod()
             .AllowAnyHeader()
             .AllowCredentials();
    });
});

builder.Services.AddControllers()
    .AddJsonOptions(options =>
    {
        options.JsonSerializerOptions.Converters.Add(
            new System.Text.Json.Serialization.JsonStringEnumConverter()
        );
    });


builder.Services.AddScoped<IUserRepository, UserRepository>();
builder.Services.AddScoped<IBreakRepository, BreakRepository>();
builder.Services.AddScoped<IScheduleRepository, ScheduleRepository>();
builder.Services.AddScoped<IBreakChatRepository, BreakChatRepository>();
builder.Services.AddScoped<IBreakPoolDayRepository, BreakPoolDayRepository>();
builder.Services.AddScoped<IUserShiftRepository, UserShiftRepository>();
builder.Services.AddScoped<IScheduleService, ScheduleService>();
builder.Services.AddScoped<IBreakService, BreakService>();
builder.Services.AddScoped<IUserShiftService, UserShiftService>();
builder.Services.AddScoped<IJwtProvider, JwtProvider>();
builder.Services.AddScoped<IPasswordHasher, PasswordHasher>();
builder.Services.AddScoped<IUserService, UserService>();
builder.Services.AddScoped<IAdminService, AdminService>();
builder.Services.AddScoped<IBreakQueueRepository, BreakQueueRepository>();
builder.Services.AddScoped<IBreakQueueService, BreakQueueService>();
builder.Services.AddHostedService<QueueNotificationWatcher>();
builder.Services.AddScoped<IBreakQueueNotifier, BreakQueueNotifier>();
builder.Services.AddScoped<IShiftBreakTemplateRepository, ShiftBreakTemplateRepository>();
builder.Services.AddHostedService<BreakAutoCloserService>();

var app = builder.Build();

if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}

app.UseCors("AllowFrontend");

app.UseHttpsRedirection();
app.UseCookiePolicy(new CookiePolicyOptions
{
    MinimumSameSitePolicy = SameSiteMode.None,
    HttpOnly = HttpOnlyPolicy.Always,
    Secure = CookieSecurePolicy.SameAsRequest
});

app.UseAuthentication();
app.UseAuthorization();

app.MapHub<BreakQueueHub>("/breakQueueHub");
app.MapControllers();

app.Run();

--- C:\Users\boobi\source\workmain\src\Skntbreak.Application\Services\AdminService.cs ---
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Skntbreak.Application.Interfaces;
using Skntbreak.Core.Dto.Admin;
using Skntbreak.Core.Dto.BreakPoolDay;
using Skntbreak.Core.Dto.Schedules;
using Skntbreak.Core.Dto.Users;
using Skntbreak.Core.Entities;
using Skntbreak.Core.Enums;
using Skntbreak.Core.Interfaces;
using SkntBreak.Infrastructure.Data.Repositories;

namespace Skntbreak.Application.Services
{
    public class AdminService : IAdminService
    {
        private readonly IUserRepository _userRepository;
        private readonly IUserShiftRepository _userShiftRepository;
        private readonly IBreakRepository _breakRepository;
        private readonly IScheduleRepository _scheduleRepository;
        private readonly IBreakPoolDayRepository _breakPoolDayRepository;
        private readonly IPasswordHasher _passwordHasher;
        private readonly IBreakService _breakService;

        public AdminService(
            IUserRepository userRepository,
            IUserShiftRepository userShiftRepository,
            IBreakRepository breakRepository,
            IScheduleRepository scheduleRepository,
            IBreakPoolDayRepository breakPoolDayRepository,
            IPasswordHasher passwordHasher,
            IBreakService breakService)
        {
            _userRepository = userRepository;
            _userShiftRepository = userShiftRepository;
            _breakRepository = breakRepository;
            _scheduleRepository = scheduleRepository;
            _breakPoolDayRepository = breakPoolDayRepository;
            _passwordHasher = passwordHasher;
            _breakService = breakService;
        }

        // ==================== ПОЛЬЗОВАТЕЛИ ====================

        public async Task<List<AdminUserDto>> GetAllUsers()
        {
            var users = await _userRepository.GetAllWithShiftsAndBreaksAsync();
            var userDtos = users.Select(user =>
            {
                var allBreaks = user.UserShifts.SelectMany(s => s.Breaks).ToList();

                return new AdminUserDto
                {
                    Id = user.Id,
                    UserName = user.UserName,
                    Login = user.Login,
                    Role = user.Role.ToString(),
                    TotalShifts = user.UserShifts.Count(),
                    TotalBreaks = allBreaks.Count,
                    CompletedBreaks = allBreaks.Count(b => b.Status == BreakStatus.Finished),
                    SkippedBreaks = allBreaks.Count(b => b.Status == BreakStatus.Skipped)
                };
            }).ToList();

            return userDtos;
        }

        public async Task<AdminUserDto> GetUserById(int userId)
        {
            var user = await _userRepository.GetByIdWithShiftsAndBreaksAsync(userId);
            if (user == null)
                throw new Exception($"Пользователь с ID {userId} не найден");

            var allBreaks = user.UserShifts.SelectMany(s => s.Breaks).ToList();

            return new AdminUserDto
            {
                Id = user.Id,
                UserName = user.UserName,
                Login = user.Login,
                Role = user.Role.ToString(),
                TotalShifts = user.UserShifts.Count(),
                TotalBreaks = allBreaks.Count,
                CompletedBreaks = allBreaks.Count(b => b.Status == BreakStatus.Finished),
                SkippedBreaks = allBreaks.Count(b => b.Status == BreakStatus.Skipped)
            };
        }

        public async Task<UserShift> EndUserShiftAsync(int userShiftId)
        {
            var userShift = await _userShiftRepository.GetByIdAsync(userShiftId);
            if (userShift == null) throw new Exception($"Смена с ID {userShiftId} не найдена");
            if (userShift.EndedAt != null) throw new Exception("Смена уже завершена");

            var activeBreak = userShift.Breaks.FirstOrDefault(b => b.Status == BreakStatus.Taken);
            if (activeBreak != null)
            {
                // ИНКАПСУЛИРОВАННЫЙ ВЫЗОВ: Гарантирует освобождение слотов и уведомление очереди
                await _breakService.EndBreakAsync(activeBreak.Id, userShift.UserId);
            }

            userShift.EndedAt = DateTime.UtcNow;
            await _userShiftRepository.UpdateAsync(userShift);
            return userShift;
        }

        public async Task<AdminUserDto> CreateUser(CreateUserAdminDto request)
        {
            var existingUser = await _userRepository.GetByLoginAsync(request.Login);
            if (existingUser != null)
                throw new Exception($"Пользователь с логином {request.Login} уже существует");

            if (!Enum.TryParse<RoleType>(request.Role, true, out var role))
            {
                // Показываем доступные роли
                var validRoles = string.Join(", ", Enum.GetNames(typeof(RoleType)));
                throw new Exception($"Неверная роль '{request.Role}'. Доступные роли: {validRoles}");
            }

            var hashedPassword = _passwordHasher.Generate(request.Password);

            var user = new User
            {
                UserName = request.UserName,
                Login = request.Login,
                PasswordHash = hashedPassword,
                Role = role
            };

            await _userRepository.AddAsync(user);

            return new AdminUserDto
            {
                Id = user.Id,
                UserName = user.UserName,
                Login = user.Login,
                Role = user.Role.ToString(),
                TotalShifts = 0,
                TotalBreaks = 0,
                CompletedBreaks = 0,
                SkippedBreaks = 0
            };
        }

        public async Task<AdminUserDto> UpdateUser(int userId, UpdateUserAdminDto request)
        {
            var user = await _userRepository.GetByIdAsync(userId);
            if (user == null)
                throw new Exception($"Пользователь с ID {userId} не найден");

            if (!string.IsNullOrWhiteSpace(request.UserName))
                user.UserName = request.UserName;

            if (!string.IsNullOrWhiteSpace(request.Login))
            {
                var existingUser = await _userRepository.GetByLoginAsync(request.Login);
                if (existingUser != null && existingUser.Id != userId)
                    throw new Exception($"Логин {request.Login} уже занят");
                user.Login = request.Login;
            }

            if (!string.IsNullOrWhiteSpace(request.Role))
            {
                if (!Enum.TryParse<RoleType>(request.Role, true, out var role))
                {
                    var validRoles = string.Join(", ", Enum.GetNames(typeof(RoleType)));
                    throw new Exception($"Неверная роль '{request.Role}'. Доступные роли: {validRoles}");
                }
                user.Role = role;
            }

            if (!string.IsNullOrWhiteSpace(request.Password))
                user.PasswordHash = _passwordHasher.Generate(request.Password);

            await _userRepository.UpdateAsync(user);

            var shifts = await _userShiftRepository.GetByUserAsync(user.Id);
            var allBreaks = shifts.SelectMany(s => s.Breaks).ToList();

            return new AdminUserDto
            {
                Id = user.Id,
                UserName = user.UserName,
                Login = user.Login,
                Role = user.Role.ToString(),
                TotalShifts = shifts.Count(),
                TotalBreaks = allBreaks.Count,
                CompletedBreaks = allBreaks.Count(b => b.Status == BreakStatus.Finished),
                SkippedBreaks = allBreaks.Count(b => b.Status == BreakStatus.Skipped)
            };
        }

        public async Task DeleteUser(int userId)
        {
            var user = await _userRepository.GetByIdAsync(userId);
            if (user == null)
                throw new Exception($"Пользователь с ID {userId} не найден");

            await _userRepository.DeleteAsync(userId);
        }

        // ==================== СТАТИСТИКА ====================

        public async Task<DashboardStatsDto> GetDashboardStats()
        {
            var users = await _userRepository.GetAllAsync();
            var allShifts = await _userShiftRepository.GetAllAsync();
            var today = DateOnly.FromDateTime(DateTime.UtcNow);
            var todayShifts = allShifts.Where(s => s.WorkDate == today).ToList();
            var allBreaks = todayShifts.SelectMany(s => s.Breaks).ToList();
            var activeBreaks = allBreaks.Where(b => b.Status == BreakStatus.Taken).ToList();

            return new DashboardStatsDto
            {
                TotalUsers = users.Count(),
                TotalShiftsToday = todayShifts.Count,
                ActiveBreaks = activeBreaks.Count,
                CompletedBreaksToday = allBreaks.Count(b => b.Status == BreakStatus.Finished),
                SkippedBreaksToday = allBreaks.Count(b => b.Status == BreakStatus.Skipped),
                TotalBreaksToday = allBreaks.Count
            };
        }

        public async Task<List<UserShiftDetailDto>> GetTodayShifts()
        {
            var today = DateOnly.FromDateTime(DateTime.UtcNow);
            var shifts = await _userShiftRepository.GetByDateAsync(today);

            return shifts.Select(s => new UserShiftDetailDto
            {
                Id = s.Id,
                UserId = s.UserId,
                UserName = s.User.UserName,
                ScheduleName = s.Schedule.Name,
                WorkDate = s.WorkDate,
                Group = s.Group.ToString(),
                TotalBreaks = s.Breaks.Count,
                ActiveBreaks = s.Breaks.Count(b => b.Status == BreakStatus.Taken),
                CompletedBreaks = s.Breaks.Count(b => b.Status == BreakStatus.Finished),
                SkippedBreaks = s.Breaks.Count(b => b.Status == BreakStatus.Skipped)
            }).ToList();
        }

        // ==================== РАСПИСАНИЯ ====================

        public async Task<List<Schedule>> GetAllSchedules()
        {
            var schedules = await _scheduleRepository.GetAllAsync();
            return schedules.ToList();
        }

        public async Task<Schedule> GetScheduleById(int id)
        {
            var schedule = await _scheduleRepository.GetByIdAsync(id);
            if (schedule == null)
                throw new Exception($"Расписание с ID {id} не найдено");
            return schedule;
        }

        public async Task<Schedule> CreateSchedule(CreateScheduleDto request)
        {
            var schedule = new Schedule
            {
                Name = request.Name,
                StartTime = request.StartTime,
                EndTime = request.EndTime
            };

            return await _scheduleRepository.AddAsync(schedule);
        }

        public async Task<Schedule> UpdateSchedule(int id, UpdateScheduleDto request)
        {
            var schedule = await _scheduleRepository.GetByIdAsync(id);
            if (schedule == null)
                throw new Exception($"Расписание с ID {id} не найдено");

            if (!string.IsNullOrWhiteSpace(request.Name))
                schedule.Name = request.Name;

            if (request.StartTime != null)
                schedule.StartTime = request.StartTime;

            if (request.EndTime != null)
                schedule.EndTime = request.EndTime;

            await _scheduleRepository.UpdateAsync(schedule);
            return schedule;
        }

        public async Task DeleteSchedule(int id)
        {
            var schedule = await _scheduleRepository.GetByIdAsync(id);
            if (schedule == null)
                throw new Exception($"Расписание с ID {id} не найдено");

            await _scheduleRepository.DeleteAsync(id);
        }

        // ==================== ПУЛЫ ПЕРЕРЫВОВ ====================

        public async Task<List<BreakPoolDayDto>> GetAllBreakPools()
        {
            var pools = await _breakPoolDayRepository.GetAllAsync();

            return pools.Select(p => new BreakPoolDayDto
            {
                Id = p.Id,
                Group = p.Group,
                WorkDate = p.WorkDate,
                MaxCurrentBreaks = p.TotalBreaks,
                CurrentBreaksCount = p.TotalBreaks - p.AvailableBreaks,
                AvailableBreaksCount = p.AvailableBreaks
            }).ToList();
        }

        public async Task<BreakPoolDayDto> GetBreakPoolByDateAndShift(DateOnly date, ShiftType shift)
        {
            var pool = await _breakPoolDayRepository.GetByDateAndShiftAsync(date, shift);

            if (pool == null)
                throw new Exception($"Пул перерывов не найден для даты {date} и смены {shift}");

            return new BreakPoolDayDto
            {
                Id = pool.Id,
                Group = pool.Group,
                WorkDate = pool.WorkDate,
                MaxCurrentBreaks = pool.TotalBreaks,
                CurrentBreaksCount = pool.TotalBreaks - pool.AvailableBreaks,
                AvailableBreaksCount = pool.AvailableBreaks
            };
        }

        public async Task<BreakPoolDayDto> CreateOrUpdateBreakPool(CreateBreakPoolDayDto request)
        {
            var existingPool = await _breakPoolDayRepository.GetByDateAndShiftAsync(
                request.WorkDate,
                request.Group);

            if (existingPool != null)
            {
                // Обновляем существующий
                existingPool.TotalBreaks = request.MaxCurrentBreaks;
                existingPool.AvailableBreaks = request.MaxCurrentBreaks;

                var updated = await _breakPoolDayRepository.UpdateAsync(existingPool);

                return new BreakPoolDayDto
                {
                    Id = updated.Id,
                    Group = updated.Group,
                    WorkDate = updated.WorkDate,
                    MaxCurrentBreaks = updated.TotalBreaks,
                    CurrentBreaksCount = updated.TotalBreaks - updated.AvailableBreaks,
                    AvailableBreaksCount = updated.AvailableBreaks
                };
            }
            else
            {
                // Создаем новый
                var newPool = new BreakPoolDay
                {
                    Group = request.Group,
                    WorkDate = request.WorkDate,
                    TotalBreaks = request.MaxCurrentBreaks,
                    AvailableBreaks = request.MaxCurrentBreaks
                };

                var created = await _breakPoolDayRepository.AddAsync(newPool);

                return new BreakPoolDayDto
                {
                    Id = created.Id,
                    Group = created.Group,
                    WorkDate = created.WorkDate,
                    MaxCurrentBreaks = created.TotalBreaks,
                    CurrentBreaksCount = 0,
                    AvailableBreaksCount = created.AvailableBreaks
                };
            }
        }
    }
}


--- C:\Users\boobi\source\workmain\src\Skntbreak.Application\Services\BreakAutoCloserService.cs ---
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using Skntbreak.Core.Enums;
using Skntbreak.Core.Interfaces;

namespace Skntbreak.Api.Services
{
    public class BreakAutoCloserService : BackgroundService
    {
        private readonly IServiceProvider _services;
        private readonly ILogger<BreakAutoCloserService> _logger;

        public BreakAutoCloserService(IServiceProvider services, ILogger<BreakAutoCloserService> logger)
        {
            _services = services;
            _logger = logger;
        }

        protected override async Task ExecuteAsync(CancellationToken stoppingToken)
        {
            _logger.LogInformation("Сервис автозавершения перерывов (BreakAutoCloserService) запущен.");
            while (!stoppingToken.IsCancellationRequested)
            {
                try
                {
                    using var scope = _services.CreateScope();
                    var breakRepo = scope.ServiceProvider.GetRequiredService<IBreakRepository>();
                    var breakService = scope.ServiceProvider.GetRequiredService<IBreakService>();

                    var activeBreaks = (await breakRepo.GetAllAsync())
                       .Where(b => b.Status == BreakStatus.Taken).ToList();

                    foreach (var b in activeBreaks)
                    {
                        var elapsed = DateTime.UtcNow - b.StartTime;
                        if (elapsed.TotalMinutes >= b.DurationMinutes)
                        {
                            _logger.LogInformation($"Автоматическое завершение перерыва {b.Id} для пользователя {b.UserShift.UserId}. Время вышло.");
                            // Использование инкапсулированного сервиса гарантирует возврат слотов в пул и пуш очереди
                            await breakService.EndBreakAsync(b.Id, b.UserShift.UserId);
                        }
                    }
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "Критическая ошибка в BreakAutoCloserService.");
                }

                await Task.Delay(TimeSpan.FromSeconds(15), stoppingToken);
            }
        }
    }
}

--- C:\Users\boobi\source\workmain\src\Skntbreak.Application\Services\BreakPoolDaySeeder.cs ---
using System;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Skntbreak.Core.Entities;
using Skntbreak.Core.Enums;
using Skntbreak.Core.Interfaces;

namespace Skntbreak.Api.Services
{
    public class BreakPoolDaySeeder : BackgroundService
    {
        private readonly IServiceProvider _services;
        private readonly TimeSpan _runAt = new TimeSpan(5, 0, 0);

        public BreakPoolDaySeeder(IServiceProvider services)
        {
            _services = services;
        }

        protected override async Task ExecuteAsync(CancellationToken stoppingToken)
        {
            while (!stoppingToken.IsCancellationRequested)
            {
                var now = DateTime.UtcNow;
                var todayRun = now.Date.Add(_runAt);
                var nextRun = now <= todayRun ? todayRun : todayRun.AddDays(1);

                var delay = nextRun - now;
                if (delay > TimeSpan.Zero)
                {
                    try { await Task.Delay(delay, stoppingToken); }
                    catch (TaskCanceledException) { break; }
                }

                try
                {
                    using var scope = _services.CreateScope();
                    var poolRepo = scope.ServiceProvider.GetRequiredService<IBreakPoolDayRepository>();

                    var date = DateOnly.FromDateTime(nextRun.Date);

                    var day = await poolRepo.GetByDateAndShiftAsync(date, ShiftType.Day);
                    if (day == null)
                    {
                        await poolRepo.AddAsync(new BreakPoolDay
                        {
                            Group = ShiftType.Day,
                            WorkDate = date,
                            TotalBreaks = 5,
                            AvailableBreaks = 5
                        });
                    }

                    var evening = await poolRepo.GetByDateAndShiftAsync(date, ShiftType.Evening);
                    if (evening == null)
                    {
                        await poolRepo.AddAsync(new BreakPoolDay
                        {
                            Group = ShiftType.Evening,
                            WorkDate = date,
                            TotalBreaks = 3,
                            AvailableBreaks = 3
                        });
                    }
                }
                catch
                {
                }
            }
        }
    }
}




--- C:\Users\boobi\source\workmain\src\Skntbreak.Application\Services\BreakQueueService.cs ---
using Microsoft.EntityFrameworkCore;
using Skntbreak.Application.Interfaces;
using Skntbreak.Core.Dto.Break;
using Skntbreak.Core.Dto.Queue;
using Skntbreak.Core.Entities;
using Skntbreak.Core.Enums;
using Skntbreak.Core.Interfaces;

namespace Skntbreak.Application.Services
{
    public class BreakQueueService : IBreakQueueService
    {
        private readonly IBreakQueueRepository _queueRepo;
        private readonly IBreakRepository _breakRepo;
        private readonly IUserShiftRepository _userShiftRepo;
        private readonly IBreakPoolDayRepository _poolRepo;
        private readonly IShiftBreakTemplateRepository _templateRepo;
        private readonly IUserRepository _userRepo;
        private readonly IBreakQueueNotifier _notifier;

        private static readonly TimeSpan NotificationTimeout = TimeSpan.FromSeconds(90);
        private static readonly TimeSpan BreakInterval = TimeSpan.Zero;

        public BreakQueueService(IBreakQueueRepository queueRepo, IBreakRepository breakRepo, IUserShiftRepository userShiftRepo, IBreakPoolDayRepository poolRepo, IShiftBreakTemplateRepository templateRepo, IUserRepository userRepo, IBreakQueueNotifier notifier)
        {
            _queueRepo = queueRepo; _breakRepo = breakRepo; _userShiftRepo = userShiftRepo;
            _poolRepo = poolRepo; _templateRepo = templateRepo; _userRepo = userRepo; _notifier = notifier;
        }

        public async Task<QueuePositionDto> EnqueueAsync(int userId, int? durationMinutes = null)
        {
            var userShift = await _userShiftRepo.GetActiveShiftAsync(userId) ?? throw new InvalidOperationException("Нет активной смены");
            int currentRound = await DetermineCurrentRoundAsync(userShift);
            var existing = await _queueRepo.GetUserEntryAsync(userShift.Id, currentRound);
            if (existing != null && (existing.Status == QueueStatus.Waiting || existing.Status == QueueStatus.Notified)) throw new InvalidOperationException("Вы уже в очереди");

            var lastBreak = await _breakRepo.GetLastFinishedBreakByUserAsync(userId);
            if (lastBreak?.EndTime != null)
            {
                var elapsed = DateTime.UtcNow - lastBreak.EndTime.Value;
                if (elapsed < BreakInterval) throw new InvalidOperationException($"Подождите ещё {(int)(BreakInterval - elapsed).TotalMinutes} мин");
            }

            int duration = await ResolveDurationAsync(userShift, durationMinutes);
            await ValidateDurationQuotaAsync(userShift.WorkDate, userShift.Group, duration);

            int maxPos = await _queueRepo.GetMaxPositionAsync(userShift.WorkDate, userShift.Group, currentRound);
            var entry = new BreakQueue { WorkDate = userShift.WorkDate, Group = userShift.Group, BreakRound = currentRound, Position = maxPos + 1, UserShiftId = userShift.Id, DurationMinutes = duration, Status = QueueStatus.Waiting, EnqueuedAt = DateTime.UtcNow, IsPriority = false };
            await _queueRepo.AddAsync(entry);
            await TryNotifyNextAsync(userShift.WorkDate, userShift.Group, currentRound);
            await BroadcastQueueUpdateAsync(userShift.WorkDate, userShift.Group, currentRound);

            return new QueuePositionDto { QueueEntryId = entry.Id, Position = entry.Position, BreakRound = currentRound, DurationMinutes = duration, Status = entry.Status, PeopleAhead = entry.Position - 1, Message = entry.Position - 1 > 0 ? $"Перед вами {entry.Position - 1} чел." : null };
        }

        public async Task<QueueStateDto> GetQueueStateAsync(int userId)
        {
            var userShift = await _userShiftRepo.GetActiveShiftAsync(userId);
            if (userShift == null) return new QueueStateDto { CurrentRound = 0, Queue = new(), AvailableSlots = 0, ActiveBreaks = 0 };

            int currentRound;
            try { currentRound = await DetermineCurrentRoundAsync(userShift); }
            catch
            {
                currentRound = (userShift.Breaks?.Count(b => b.Status == BreakStatus.Finished || b.Status == BreakStatus.Skipped) ?? 0) + 1; if (currentRound > 1) currentRound--;
            }

            var pool = await _poolRepo.GetByDateAndShiftAsync(userShift.WorkDate, userShift.Group) ?? await _poolRepo.AddAsync(new BreakPoolDay { Group = userShift.Group, WorkDate = userShift.WorkDate, TotalBreaks = 5, AvailableBreaks = 5 });
            var queue = await _queueRepo.GetQueueAsync(userShift.WorkDate, userShift.Group, currentRound);
            var shiftsInGroup = await _userShiftRepo.GetByDateAndGroupAsync(userShift.WorkDate, userShift.Group);
            bool roundComplete = await _queueRepo.IsRoundCompleteAsync(userShift.WorkDate, userShift.Group, currentRound, shiftsInGroup.Count());
            var myEntry = queue.FirstOrDefault(q => q.UserShiftId == userShift.Id);

            return new QueueStateDto { CurrentRound = currentRound, IsRoundComplete = roundComplete, AvailableSlots = pool.AvailableBreaks, ActiveBreaks = pool.TotalBreaks - pool.AvailableBreaks, AllowDurationChoice = userShift.Schedule.AllowDurationChoice, Remaining10Min = pool.Remaining10MinBreaks, Remaining20Min = pool.Remaining20MinBreaks, Queue = queue.Select(q => new QueueEntryDto { Id = q.Id, UserId = q.UserShift.UserId, UserName = q.UserShift.User.UserName, Position = q.Position, DurationMinutes = q.DurationMinutes, Status = q.Status, IsPriority = q.IsPriority, EnqueuedAt = q.EnqueuedAt, NotifiedAt = q.NotifiedAt }).ToList(), MyEntry = myEntry == null ? null : new QueueEntryDto { Id = myEntry.Id, UserId = myEntry.UserShift.UserId, UserName = myEntry.UserShift.User.UserName, Position = myEntry.Position, DurationMinutes = myEntry.DurationMinutes, Status = myEntry.Status, IsPriority = myEntry.IsPriority, EnqueuedAt = myEntry.EnqueuedAt, NotifiedAt = myEntry.NotifiedAt } };
        }

        public async Task<ActiveBreakDto> ConfirmBreakAsync(int userId, int queueEntryId)
        {
            var entry = await _queueRepo.GetByIdAsync(queueEntryId) ?? throw new ArgumentException("Запись не найдена");
            if (entry.UserShift.UserId != userId) throw new UnauthorizedAccessException("Это не ваша запись");
            if (entry.Status != QueueStatus.Notified) throw new InvalidOperationException("Уведомление не активно");

            var userShift = entry.UserShift;

            // Concurrency Retry Loop для слотов пула
            bool saved = false;
            int retries = 3;
            while (!saved && retries > 0)
            {
                try
                {
                    var pool = await _poolRepo.GetByDateAndShiftAsync(entry.WorkDate, entry.Group);
                    if (pool == null || pool.AvailableBreaks <= 0) throw new InvalidOperationException("Нет свободных слотов");

                    pool.AvailableBreaks -= 1;
                    if (entry.DurationMinutes == 10 && pool.Remaining10MinBreaks.HasValue) { if (pool.Remaining10MinBreaks.Value <= 0) throw new InvalidOperationException("10-мин закончились"); pool.Remaining10MinBreaks -= 1; }
                    else if (entry.DurationMinutes == 20 && pool.Remaining20MinBreaks.HasValue) { if (pool.Remaining20MinBreaks.Value <= 0) throw new InvalidOperationException("20-мин закончились"); pool.Remaining20MinBreaks -= 1; }

                    await _poolRepo.UpdateAsync(pool);
                    saved = true;
                }
                catch (DbUpdateConcurrencyException)
                {
                    retries--;
                    if (retries == 0) throw new InvalidOperationException("Высокая нагрузка, не удалось зарезервировать слот.");
                }
            }

            var newBreak = new Break { UserShiftId = userShift.Id, DurationMinutes = entry.DurationMinutes, BreakNumber = entry.BreakRound, Status = BreakStatus.Taken, StartTime = DateTime.UtcNow, WorkDate = entry.WorkDate };
            var createdBreak = await _breakRepo.AddAsync(newBreak);

            entry.Status = QueueStatus.Confirmed;
            await _queueRepo.UpdateAsync(entry);
            await TryNotifyNextAsync(entry.WorkDate, entry.Group, entry.BreakRound);
            await BroadcastQueueUpdateAsync(entry.WorkDate, entry.Group, entry.BreakRound);

            return new ActiveBreakDto { Id = createdBreak.Id, UserId = userId, UserShiftId = createdBreak.UserShiftId, Status = createdBreak.Status, DurationMinutes = createdBreak.DurationMinutes, BreakNumber = createdBreak.BreakNumber, StartTime = createdBreak.StartTime, WorkDate = createdBreak.WorkDate, UserName = userShift.User?.UserName ?? "Unknown" };
        }

        public async Task<QueuePositionDto> PostponeAsync(int userId, int queueEntryId)
        {
            var entry = await _queueRepo.GetByIdAsync(queueEntryId) ?? throw new ArgumentException("Запись не найдена");
            if (entry.UserShift.UserId != userId) throw new UnauthorizedAccessException("Это не ваша запись");
            if (entry.Status != QueueStatus.Notified) throw new InvalidOperationException("Уведомление не активно");

            var queue = await _queueRepo.GetQueueAsync(entry.WorkDate, entry.Group, entry.BreakRound);
            var waitingAfter = queue.Where(q => q.Status == QueueStatus.Waiting && q.Position > entry.Position).OrderBy(q => q.Position).ToList();

            if (waitingAfter.Count > 0)
            {
                int skipCount = Math.Min(2, waitingAfter.Count);
                var toShift = waitingAfter.Take(skipCount).ToList();
                foreach (var q in toShift) q.Position -= 1;
                await _queueRepo.UpdateRangeAsync(toShift);
                entry.Position = toShift.Last().Position + 1;
            }

            entry.Status = QueueStatus.Waiting;
            entry.NotifiedAt = null;
            await _queueRepo.UpdateAsync(entry);

            await TryNotifyNextAsync(entry.WorkDate, entry.Group, entry.BreakRound);
            await BroadcastQueueUpdateAsync(entry.WorkDate, entry.Group, entry.BreakRound);

            return new QueuePositionDto
            {
                QueueEntryId = entry.Id,
                Position = entry.Position,
                BreakRound = entry.BreakRound,
                DurationMinutes = entry.DurationMinutes,
                Status = entry.Status,
                PeopleAhead = queue.Count(q => q.Position < entry.Position && q.Id != entry.Id && (q.Status == QueueStatus.Waiting || q.Status == QueueStatus.Notified)),
                Message = "Отложено"
            };
        }

        public async Task ExpireNotificationAsync(int queueEntryId)
        {
            var entry = await _queueRepo.GetByIdAsync(queueEntryId);
            if (entry == null || entry.Status != QueueStatus.Notified) return;
            if (entry.NotifiedAt.HasValue && DateTime.UtcNow - entry.NotifiedAt.Value < NotificationTimeout) return;
            int maxPos = await _queueRepo.GetMaxPositionAsync(entry.WorkDate, entry.Group, entry.BreakRound);
            entry.Position = maxPos + 1; entry.Status = QueueStatus.Waiting; entry.NotifiedAt = null;
            await _queueRepo.UpdateAsync(entry);
            await TryNotifyNextAsync(entry.WorkDate, entry.Group, entry.BreakRound);
            await BroadcastQueueUpdateAsync(entry.WorkDate, entry.Group, entry.BreakRound);
            await _notifier.NotifyExpiredAsync(entry.UserShift.UserId, entry.Id, entry.Position);
        }

        public async Task<QueuePositionDto> EnqueuePriorityAsync(int targetUserId, int requestingUserId, int? durationMinutes = null)
        {
            var requester = await _userRepo.GetByIdAsync(requestingUserId) ?? throw new ArgumentException("Запросивший не найден");
            if (requester.Role != RoleType.TeamLead && requester.Role != RoleType.Admin) throw new UnauthorizedAccessException("Недостаточно прав");
            var userShift = await _userShiftRepo.GetActiveShiftAsync(targetUserId) ?? throw new InvalidOperationException("Нет активной смены");

            int currentRound;
            try { currentRound = await DetermineCurrentRoundAsync(userShift); } catch { currentRound = 1; }
            int duration = await ResolveDurationAsync(userShift, durationMinutes);

            var queue = await _queueRepo.GetQueueAsync(userShift.WorkDate, userShift.Group, currentRound);
            var toShift = queue.Where(q => q.Status == QueueStatus.Waiting || q.Status == QueueStatus.Notified).ToList();
            foreach (var q in toShift) q.Position += 1;
            await _queueRepo.UpdateRangeAsync(toShift);

            var entry = new BreakQueue { WorkDate = userShift.WorkDate, Group = userShift.Group, BreakRound = currentRound, Position = 1, UserShiftId = userShift.Id, DurationMinutes = duration, Status = QueueStatus.Waiting, EnqueuedAt = DateTime.UtcNow, IsPriority = true };
            await _queueRepo.AddAsync(entry);
            await TryNotifyNextAsync(userShift.WorkDate, userShift.Group, currentRound);
            await BroadcastQueueUpdateAsync(userShift.WorkDate, userShift.Group, currentRound);

            return new QueuePositionDto { QueueEntryId = entry.Id, Position = 1, BreakRound = currentRound, DurationMinutes = duration, Status = entry.Status, PeopleAhead = 0, Message = "Приоритетная постановка" };
        }

        public async Task SkipBreakRoundAsync(int userId)
        {
            var userShift = await _userShiftRepo.GetActiveShiftAsync(userId) ?? throw new InvalidOperationException("Нет активной смены");
            int currentRound = await DetermineCurrentRoundAsync(userShift);
            var existing = await _queueRepo.GetUserEntryAsync(userShift.Id, currentRound);
            if (existing != null && (existing.Status == QueueStatus.Waiting || existing.Status == QueueStatus.Notified))
            {
                existing.Status = QueueStatus.Cancelled;
                await _queueRepo.UpdateAsync(existing);
            }
            var skipBreak = new Break { UserShiftId = userShift.Id, DurationMinutes = 0, BreakNumber = currentRound, Status = BreakStatus.Skipped, StartTime = DateTime.UtcNow, EndTime = DateTime.UtcNow, WorkDate = userShift.WorkDate };
            await _breakRepo.AddAsync(skipBreak);
            await TryNotifyNextAsync(userShift.WorkDate, userShift.Group, currentRound);
            await BroadcastQueueUpdateAsync(userShift.WorkDate, userShift.Group, currentRound);
        }

        public async Task ProcessNextInQueueAsync(DateOnly workDate, ShiftType group, int breakRound)
        {
            await TryNotifyNextAsync(workDate, group, breakRound);
            await BroadcastQueueUpdateAsync(workDate, group, breakRound);
        }

        private async Task<int> DetermineCurrentRoundAsync(UserShift userShift)
        {
            var userBreakRounds = userShift.Breaks?.Where(b => b.Status == BreakStatus.Finished || b.Status == BreakStatus.Skipped).Select(b => b.BreakNumber).Distinct().Count() ?? 0;
            int nextRound = userBreakRounds + 1;
            if (nextRound > 1)
            {
                var shiftsInGroup = await _userShiftRepo.GetByDateAndGroupAsync(userShift.WorkDate, userShift.Group);
                bool prevComplete = await _queueRepo.IsRoundCompleteAsync(userShift.WorkDate, userShift.Group, nextRound - 1, shiftsInGroup.Count());
                if (!prevComplete) throw new InvalidOperationException($"Раунд {nextRound - 1} ещё не завершён");
            }
            return nextRound;
        }

        // ИСПРАВЛЕНО: Вычисляем длительность на основе фактически завершенных перерывов (игнорируя Skipped)
        private async Task<int> ResolveDurationAsync(UserShift userShift, int? requested)
        {
            if (userShift.Schedule.AllowDurationChoice)
            {
                if (requested == null || (requested != 10 && requested != 20)) throw new InvalidOperationException("Выберите 10 или 20 минут");
                return requested.Value;
            }
            int actualFinishedBreaks = userShift.Breaks?.Count(b => b.Status == BreakStatus.Finished) ?? 0;
            var templates = await _templateRepo.GetByScheduleAsync(userShift.ScheduleId);
            var template = templates.FirstOrDefault(t => t.Order == actualFinishedBreaks + 1);
            return template?.DurationMinutes ?? 20;
        }

        private async Task ValidateDurationQuotaAsync(DateOnly workDate, ShiftType group, int duration)
        {
            var pool = await _poolRepo.GetByDateAndShiftAsync(workDate, group);
            if (pool == null) return;
            if (duration == 10 && pool.Remaining10MinBreaks.HasValue && pool.Remaining10MinBreaks.Value <= 0) throw new InvalidOperationException("10-минутные перерывы закончились");
            if (duration == 20 && pool.Remaining20MinBreaks.HasValue && pool.Remaining20MinBreaks.Value <= 0) throw new InvalidOperationException("20-минутные перерывы закончились");
        }

        // ИСПРАВЛЕНО: Использование оптимизированного метода GetNextEligibleWaitingAsync без проблемы N+1
        private async Task TryNotifyNextAsync(DateOnly workDate, ShiftType group, int breakRound)
        {
            bool hasNotified = await _queueRepo.HasNotifiedEntryAsync(workDate, group, breakRound);
            if (hasNotified) return;

            var pool = await _poolRepo.GetByDateAndShiftAsync(workDate, group);
            if (pool == null || pool.AvailableBreaks <= 0) return;

            var next = await _queueRepo.GetNextEligibleWaitingAsync(workDate, group, breakRound, BreakInterval);
            if (next == null) return;

            next.Status = QueueStatus.Notified;
            next.NotifiedAt = DateTime.UtcNow;
            await _queueRepo.UpdateAsync(next);
            await _notifier.NotifyYourTurnAsync(next.UserShift.UserId, next.Id, next.DurationMinutes, 90);
        }

        private async Task BroadcastQueueUpdateAsync(DateOnly workDate, ShiftType group, int breakRound)
        {
            var queue = await _queueRepo.GetQueueAsync(workDate, group, breakRound);
            var pool = await _poolRepo.GetByDateAndShiftAsync(workDate, group);
            var queueDto = queue.Select(q => new QueueEntryDto { Id = q.Id, UserId = q.UserShift.UserId, UserName = q.UserShift.User.UserName, Position = q.Position, DurationMinutes = q.DurationMinutes, Status = q.Status, IsPriority = q.IsPriority, EnqueuedAt = q.EnqueuedAt, NotifiedAt = q.NotifiedAt }).ToList();
            await _notifier.BroadcastQueueUpdateAsync(workDate, (int)group, queueDto, pool?.AvailableBreaks ?? 0, breakRound);
        }
    }
}

--- C:\Users\boobi\source\workmain\src\Skntbreak.Application\Services\BreakService.cs ---
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.EntityFrameworkCore;
using Skntbreak.Application.Interfaces;
using Skntbreak.Core.Dto.Break;
using Skntbreak.Core.Entities;
using Skntbreak.Core.Enums;
using Skntbreak.Core.Interfaces;

namespace Skntbreak.Application.Services
{
    public class BreakService : IBreakService
    {
        private readonly IBreakRepository _breakRepository;
        private readonly IUserRepository _userRepository;
        private readonly IUserShiftRepository _userShiftRepository;
        private readonly IBreakPoolDayRepository _poolDayRepository;
        private readonly IBreakQueueService _queueService;

        public BreakService(IBreakRepository breakRepository, IUserRepository userRepository, IUserShiftRepository userShiftRepository, IBreakPoolDayRepository poolDayRepository, IBreakQueueService queueService)
        {
            _breakRepository = breakRepository;
            _userRepository = userRepository;
            _userShiftRepository = userShiftRepository;
            _poolDayRepository = poolDayRepository;
            _queueService = queueService;
        }

        public async Task<ActiveBreakDto> StartBreakAsync(StartBreakDto request, int userId)
        {
            // Жестко запрещаем прямой старт перерывов в обход очереди. ConfirmBreakAsync является легитимным методом.
            throw new InvalidOperationException("Прямой старт перерыва отключен архитектурно. Используйте систему подтверждения в очереди.");
        }

        public async Task<BreakDetailsDto> EndBreakAsync(int breakId, int userId)
        {
            var endedBreak = await _breakRepository.GetByIdAsync(breakId) ?? throw new ArgumentException($"Перерыв с Id {breakId} не найден");
            var userShift = await _userShiftRepository.GetByIdAsync(endedBreak.UserShiftId);

            if (userShift == null || userShift.UserId != userId) throw new UnauthorizedAccessException("Это не ваш перерыв");
            if (endedBreak.Status != BreakStatus.Taken) throw new InvalidOperationException($"Перерыв не активен (статус: {endedBreak.Status})");

            // Optimistic Concurrency Control Retry Loop
            bool saved = false;
            int retries = 3;
            while (!saved && retries > 0)
            {
                try
                {
                    var pool = await _poolDayRepository.GetByDateAndShiftAsync(endedBreak.WorkDate, userShift.Group);
                    if (pool != null)
                    {
                        pool.AvailableBreaks += 1;
                        if (endedBreak.DurationMinutes == 10 && pool.Remaining10MinBreaks.HasValue) pool.Remaining10MinBreaks += 1;
                        else if (endedBreak.DurationMinutes == 20 && pool.Remaining20MinBreaks.HasValue) pool.Remaining20MinBreaks += 1;
                        await _poolDayRepository.UpdateAsync(pool);
                    }
                    saved = true;
                }
                catch (DbUpdateConcurrencyException)
                {
                    retries--;
                    if (retries == 0) throw new InvalidOperationException("Не удалось обновить квоты из-за высокой нагрузки. Попробуйте еще раз.");
                }
            }

            endedBreak.Status = BreakStatus.Finished;
            endedBreak.EndTime = DateTime.UtcNow;
            await _breakRepository.UpdateAsync(endedBreak);

            await _queueService.ProcessNextInQueueAsync(endedBreak.WorkDate, userShift.Group, endedBreak.BreakNumber);

            return new BreakDetailsDto
            {
                Id = endedBreak.Id,
                UserId = userId,
                UserShiftId = endedBreak.UserShiftId,
                Status = endedBreak.Status,
                DurationMinutes = endedBreak.DurationMinutes,
                BreakNumber = endedBreak.BreakNumber,
                StartTime = endedBreak.StartTime,
                EndTime = endedBreak.EndTime,
                WorkDate = endedBreak.WorkDate
            };
        }

        public async Task<BreakDetailsDto> SkipBreakAsync(SkipBreakDto request, int userId)
        {
            var userShift = await _userShiftRepository.GetActiveShiftAsync(userId) ?? throw new InvalidOperationException("Пользователь не начал смену");

            var newBreak = new Break
            {
                UserShiftId = userShift.Id,
                DurationMinutes = request.DurationMinutes,
                BreakNumber = request.BreakNumber,
                Status = BreakStatus.Skipped,
                StartTime = DateTime.UtcNow,
                EndTime = DateTime.UtcNow,
                WorkDate = userShift.WorkDate
            };
            var skippedBreak = await _breakRepository.AddAsync(newBreak);
            return new BreakDetailsDto { /* mapping */ Id = skippedBreak.Id, UserId = userId, UserShiftId = skippedBreak.UserShiftId, Status = skippedBreak.Status, DurationMinutes = skippedBreak.DurationMinutes, BreakNumber = skippedBreak.BreakNumber, StartTime = skippedBreak.StartTime, EndTime = skippedBreak.EndTime, WorkDate = skippedBreak.WorkDate };
        }

        public async Task<BreakDetailsDto> SkipBreakAsync(int breakId, int userId)
        {
            var breakEntity = await _breakRepository.GetByIdAsync(breakId);
            if (breakEntity == null) throw new ArgumentException($"Перерыв с Id {breakId} не найден");
            breakEntity.Status = BreakStatus.Skipped;
            breakEntity.EndTime = DateTime.UtcNow;
            await _breakRepository.UpdateAsync(breakEntity);
            return new BreakDetailsDto { /* mapping */ Id = breakEntity.Id, UserId = userId, UserShiftId = breakEntity.UserShiftId, Status = breakEntity.Status, DurationMinutes = breakEntity.DurationMinutes, BreakNumber = breakEntity.BreakNumber, StartTime = breakEntity.StartTime, EndTime = breakEntity.EndTime, WorkDate = breakEntity.WorkDate };
        }

        public async Task<List<ActiveBreakDto>> GetActiveBreaksAsync()
        {
            var breaks = await _breakRepository.GetAllAsync();
            return breaks.Where(b => b.Status == BreakStatus.Taken).Select(b => new ActiveBreakDto { /* mapping */ Id = b.Id, UserId = b.UserShift.UserId, UserShiftId = b.UserShiftId, Status = b.Status, DurationMinutes = b.DurationMinutes, BreakNumber = b.BreakNumber, StartTime = b.StartTime, WorkDate = b.WorkDate, UserName = b.UserShift?.User?.UserName ?? "Unknown" }).ToList();
        }

        public async Task<List<ActiveBreakDto>> GetActiveBreaksByScheduleAsync(int scheduleId)
        {
            var breaks = await _breakRepository.GetActiveBreaksByScheduleAsync(scheduleId);
            return breaks.Select(b => new ActiveBreakDto { /* mapping */ Id = b.Id, UserId = b.UserShift.UserId, UserShiftId = b.UserShiftId, Status = b.Status, DurationMinutes = b.DurationMinutes, BreakNumber = b.BreakNumber, StartTime = b.StartTime, WorkDate = b.WorkDate, UserName = b.UserShift?.User?.UserName ?? "Unknown" }).ToList();
        }

        public async Task<ActiveBreakDto?> GetUserActiveBreakAsync(int userId)
        {
            var breakEntity = await _breakRepository.GetActiveBreakByUserAsync(userId);
            if (breakEntity == null) return null;
            return new ActiveBreakDto { /* mapping */ Id = breakEntity.Id, UserId = userId, UserShiftId = breakEntity.UserShiftId, Status = breakEntity.Status, DurationMinutes = breakEntity.DurationMinutes, BreakNumber = breakEntity.BreakNumber, StartTime = breakEntity.StartTime, WorkDate = breakEntity.WorkDate, UserName = breakEntity.UserShift?.User?.UserName ?? "Unknown" };
        }

        public async Task<List<BreakDetailsDto>> GetUserBreakHistoryAsync(int userId, DateOnly date)
        {
            var userShift = await _userShiftRepository.GetByUserAndDateAsync(userId, date);
            if (userShift == null) return new List<BreakDetailsDto>();
            var breaks = await _breakRepository.GetAllAsync();
            return breaks.Where(b => b.UserShiftId == userShift.Id).OrderBy(b => b.StartTime).Select(b => new BreakDetailsDto { /* mapping */ Id = b.Id, UserId = userId, UserShiftId = b.UserShiftId, Status = b.Status, DurationMinutes = b.DurationMinutes, BreakNumber = b.BreakNumber, StartTime = b.StartTime, EndTime = b.EndTime, WorkDate = b.WorkDate }).ToList();
        }

        public async Task<BreakStatisticsDto> GetBreakStatisticsAsync(int userId, DateOnly date)
        {
            var breaks = await GetUserBreakHistoryAsync(userId, date);
            var user = await _userRepository.GetByIdAsync(userId);
            return new BreakStatisticsDto { UserId = userId, UserName = user?.UserName ?? "Unknown", WorkDate = date, TotalBreaks = breaks.Count, CompletedBreaks = breaks.Count(b => b.Status == BreakStatus.Finished), ActiveBreaks = breaks.Count(b => b.Status == BreakStatus.Taken), OverdueBreaks = breaks.Count(b => b.EndTime.HasValue && b.EndTime.Value > b.StartTime.AddMinutes(b.DurationMinutes)), TotalBreakTime = TimeSpan.FromMinutes(breaks.Where(b => b.Status == BreakStatus.Finished && b.EndTime.HasValue).Sum(b => (b.EndTime!.Value - b.StartTime).TotalMinutes)), AverageBreakTime = breaks.Any(b => b.Status == BreakStatus.Finished && b.EndTime.HasValue) ? TimeSpan.FromMinutes(breaks.Where(b => b.Status == BreakStatus.Finished && b.EndTime.HasValue).Average(b => (b.EndTime!.Value - b.StartTime).TotalMinutes)) : TimeSpan.Zero, BreaksByStatus = breaks.GroupBy(b => b.Status).ToDictionary(g => g.Key, g => g.Count()) };
        }

        public async Task<BreakStatisticsDto> GetScheduleStatisticsAsync(int scheduleId, DateOnly date)
        {
            var breaks = await _breakRepository.GetAllAsync();
            var scheduleBreaks = breaks.Where(b => b.UserShift.ScheduleId == scheduleId && b.WorkDate == date).ToList();
            return new BreakStatisticsDto { WorkDate = date, TotalBreaks = scheduleBreaks.Count, CompletedBreaks = scheduleBreaks.Count(b => b.Status == BreakStatus.Finished), ActiveBreaks = scheduleBreaks.Count(b => b.Status == BreakStatus.Taken), OverdueBreaks = scheduleBreaks.Count(b => b.EndTime.HasValue && b.EndTime.Value > b.StartTime.AddMinutes(b.DurationMinutes)), BreaksByStatus = scheduleBreaks.GroupBy(b => b.Status).ToDictionary(g => g.Key, g => g.Count()) };
        }

        public async Task InitializeUserShiftBreaksAsync(int userShiftId) { await Task.CompletedTask; }

        public async Task<List<BreakDetailsDto>> GetAvailableBreaksAsync(int userId, DateOnly date)
        {
            var userShift = await _userShiftRepository.GetByUserAndDateAsync(userId, date);
            if (userShift == null) return new List<BreakDetailsDto>();
            var breaks = await _breakRepository.GetAllAsync();
            return breaks.Where(b => b.UserShiftId == userShift.Id && b.Status == BreakStatus.Available).Select(b => new BreakDetailsDto { Id = b.Id, UserId = userId, UserShiftId = b.UserShiftId, Status = b.Status, DurationMinutes = b.DurationMinutes, BreakNumber = b.BreakNumber, StartTime = b.StartTime, EndTime = b.EndTime, WorkDate = b.WorkDate }).ToList();
        }

        public async Task<List<ActiveBreakDto>> GetActiveBreaksByDateAsync(DateOnly workDate, int currentUserId)
        {
            var userShift = await _userShiftRepository.GetByUserAndDateAsync(currentUserId, workDate);
            if (userShift == null) return new List<ActiveBreakDto>();
            var activeBreaks = await _breakRepository.GetBreaksByDateAndGroupAsync(workDate, userShift.Group);
            return activeBreaks.Where(b => b.Status == BreakStatus.Taken).Select(b => new ActiveBreakDto { Id = b.Id, UserId = b.UserShift.UserId, UserShiftId = b.UserShiftId, Status = b.Status, DurationMinutes = b.DurationMinutes, BreakNumber = b.BreakNumber, StartTime = b.StartTime, WorkDate = b.WorkDate, UserName = b.UserShift?.User?.UserName ?? "Unknown" }).OrderBy(b => b.StartTime).ToList();
        }

        public async Task<BreakPoolInfoDto> GetBreakPoolInfoAsync(DateOnly workDate, int userId)
        {
            var userShift = await _userShiftRepository.GetByUserAndDateAsync(userId, workDate);
            if (userShift == null) return new BreakPoolInfoDto { TotalBreaks = 0, AvailableBreaks = 0, ActiveBreaks = 0, CanTakeBreak = false, Message = "У вас нет активной смены на эту дату" };
            var pool = await _poolDayRepository.GetByDateAndShiftAsync(workDate, userShift.Group);
            if (pool == null) return new BreakPoolInfoDto { TotalBreaks = 0, AvailableBreaks = 0, ActiveBreaks = 0, CanTakeBreak = false, Message = "Пул перерывов не настроен" };

            var hasActiveBreak = await _breakRepository.GetActiveBreakByUserAsync(userId) != null;
            var intervalPassed = await IsIntervalPassed(userId);

            var canTake = pool.AvailableBreaks > 0 && !hasActiveBreak && intervalPassed;
            string? message = null;
            if (hasActiveBreak) message = "У вас уже есть активный перерыв";
            else if (!intervalPassed) message = "Необходимо подождать 60 минут после последнего перерыва";
            else if (pool.AvailableBreaks <= 0) message = "Все перерывы заняты";

            return new BreakPoolInfoDto { TotalBreaks = pool.TotalBreaks, AvailableBreaks = pool.AvailableBreaks, ActiveBreaks = pool.TotalBreaks - pool.AvailableBreaks, CanTakeBreak = canTake, Message = message };
        }

        private async Task<int> GetNextBreakNumberAsync(int usershiftId)
        {
            var lastBreak = await _breakRepository.GetLastBreakByUserShiftAsync(usershiftId);
            return lastBreak?.BreakNumber + 1 ?? 1;
        }

        public async Task<bool> IsIntervalPassed(int userId)
        {
            var lastFinishedBreak = await _breakRepository.GetLastFinishedBreakByUserAsync(userId);
            if (lastFinishedBreak == null) return true;
            return (DateTime.UtcNow - lastFinishedBreak.EndTime.Value).TotalMinutes >= 60;
        }
    }
}

--- C:\Users\boobi\source\workmain\src\Skntbreak.Application\Services\DashboardService.cs ---
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Skntbreak.Application.Services
{
    internal class DashboardService
    {
    }
}


--- C:\Users\boobi\source\workmain\src\Skntbreak.Application\Services\QueueNotificationWatcher.cs ---
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using Skntbreak.Core.Interfaces;

namespace Skntbreak.Api.Services
{
    public class QueueNotificationWatcher : BackgroundService
    {
        private readonly IServiceProvider _services;
        private readonly ILogger<QueueNotificationWatcher> _logger;
        private static readonly TimeSpan CheckInterval = TimeSpan.FromSeconds(15);
        private static readonly TimeSpan Timeout = TimeSpan.FromSeconds(90);

        public QueueNotificationWatcher(
            IServiceProvider services,
            ILogger<QueueNotificationWatcher> logger)
        {
            _services = services;
            _logger = logger;
        }

        protected override async Task ExecuteAsync(CancellationToken stoppingToken)
        {
            _logger.LogInformation("QueueNotificationWatcher запущен");

            while (!stoppingToken.IsCancellationRequested)
            {
                try
                {
                    await Task.Delay(CheckInterval, stoppingToken);
                }
                catch (TaskCanceledException)
                {
                    break;
                }

                try
                {
                    using var scope = _services.CreateScope();
                    var queueRepo = scope.ServiceProvider
                        .GetRequiredService<IBreakQueueRepository>();
                    var queueService = scope.ServiceProvider
                        .GetRequiredService<IBreakQueueService>();

                    var expired = await queueRepo.GetExpiredNotificationsAsync(Timeout);

                    foreach (var entry in expired)
                    {
                        _logger.LogInformation(
                            "Тайм-аут уведомления для QueueEntry {Id}, User {UserId}",
                            entry.Id, entry.UserShift?.UserId);

                        await queueService.ExpireNotificationAsync(entry.Id);
                    }
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "Ошибка в QueueNotificationWatcher");
                }
            }
        }
    }
}

--- C:\Users\boobi\source\workmain\src\Skntbreak.Application\Services\ScheduleService.cs ---
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Skntbreak.Application.Interfaces;
using Skntbreak.Core.Dto.Schedules;
using Skntbreak.Core.Entities;
using Skntbreak.Core.Interfaces;

namespace Skntbreak.Application.Services
{
    public class ScheduleService : IScheduleService
    {
        private readonly IScheduleRepository _scheduleRepository;
        
        public ScheduleService(IScheduleRepository scheduleRepository)
        {
            _scheduleRepository = scheduleRepository;
        }

        public async Task<Schedule> CreateSchedule(CreateScheduleDto createScheduleDto)
        {
            Schedule schedule = new Schedule
            {
                Name = createScheduleDto.Name,
                StartTime = createScheduleDto.StartTime,
                EndTime = createScheduleDto.EndTime,
                ShiftType = createScheduleDto.ShiftType
            };

            var createdSchedule = await _scheduleRepository.AddAsync(schedule);
            return createdSchedule;
        }

        public async Task<List<Schedule>> GetAllSchedules()
        {
            var schedules = await _scheduleRepository.GetAllAsync();
            return schedules.ToList();
        }

        public async Task<Schedule> GetScheduleById(int id)
        {
            var schedule = await _scheduleRepository.GetByIdAsync(id);
            return schedule;
        }

        public async Task<Schedule> DeleteSchedule(int id)
        {
           var schedule = await _scheduleRepository.GetByIdAsync(id);  
           await _scheduleRepository.DeleteAsync(id);
           return schedule;   
        }
        public async Task<Schedule> UpdateSchedule(int id, UpdateScheduleDto updateScheduleDto)
        {
            var scheduleEntity = await _scheduleRepository.GetByIdAsync(id);

            if (!string.IsNullOrWhiteSpace(updateScheduleDto.Name))
                scheduleEntity.Name = updateScheduleDto.Name;

            if (updateScheduleDto.StartTime != null)
                scheduleEntity.StartTime = updateScheduleDto.StartTime;

            if (updateScheduleDto.EndTime != null)
                scheduleEntity.EndTime = updateScheduleDto.EndTime;

            if (updateScheduleDto.ShiftType != null)
                scheduleEntity.ShiftType = updateScheduleDto.ShiftType;

            await _scheduleRepository.UpdateAsync(scheduleEntity);
            return scheduleEntity;
        }
    }
}


--- C:\Users\boobi\source\workmain\src\Skntbreak.Application\Services\UserService.cs ---
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Skntbreak.Application.Interfaces;
using Skntbreak.Core.Dto.Users;
using Skntbreak.Core.Entities;
using Skntbreak.Core.Interfaces;
using SkntBreak.Infrastructure.Data.Repositories;

namespace Skntbreak.Application.Services
{
    public class UserService : IUserService
    {
        private readonly IPasswordHasher _passwordHasher;
        private readonly IUserRepository _userRepository;
        private readonly IJwtProvider _jwtProvider;
        private readonly IUserShiftRepository _userShiftRepository;

        public UserService(
            IPasswordHasher passwordHasher,
            IUserRepository userRepository,
            IJwtProvider jwtProvider,
            IUserShiftRepository userShiftRepository)
        {
            _passwordHasher = passwordHasher;
            _userRepository = userRepository;
            _jwtProvider = jwtProvider;
            _userShiftRepository = userShiftRepository;
        }

        public async Task Register(string userName, string login, string password)
        {
            var hashedPassword = _passwordHasher.Generate(password);

            var user = new User
            {
                UserName = userName,
                Login = login,
                PasswordHash = hashedPassword
            };

            await _userRepository.AddAsync(user);
        }

        public async Task<string> Login(string login, string password)
        {
            var user = await _userRepository.GetByLoginAsync(login);

            if (user is null)
            {
                throw new Exception("Пользователь с таким логином не найден");
            }

            var result = _passwordHasher.Verify(password, user.PasswordHash);

            if (result == false)
            {
                throw new Exception("Неверный пароль");
            }

            var token = _jwtProvider.GenerateToken(user);

            return token;
        }

        public async Task<UserProfileDto> GetProfile(int userId)
        {
            var user = await _userRepository.GetByIdAsync(userId);

            if (user == null)
                throw new Exception("Пользователь не найден");

            // Получаем статистику
            var shifts = await _userShiftRepository.GetByUserAsync(userId);
            var allBreaks = shifts.SelectMany(s => s.Breaks).ToList();

            return new UserProfileDto
            {
                Id = user.Id,
                UserName = user.UserName,
                Login = user.Login,
                Role = user.Role.ToString(),
                TotalShifts = shifts.Count(),
                TotalBreaks = allBreaks.Count,
                CompletedBreaks = allBreaks.Count(b => b.Status == Core.Enums.BreakStatus.Finished),
                SkippedBreaks = allBreaks.Count(b => b.Status == Core.Enums.BreakStatus.Skipped)
            };
        }

        public async Task UpdateProfile(int userId, UpdateProfileDto request)
        {
            var user = await _userRepository.GetByIdAsync(userId);

            if (user == null)
                throw new Exception("Пользователь не найден");

            if (!string.IsNullOrWhiteSpace(request.UserName))
                user.UserName = request.UserName;

            await _userRepository.UpdateAsync(user);
        }
    }
}


--- C:\Users\boobi\source\workmain\src\Skntbreak.Application\Services\UserShiftService.cs ---
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Skntbreak.Application.Interfaces;
using Skntbreak.Core.Dto.UserShift;
using Skntbreak.Core.Entities;
using Skntbreak.Core.Enums;
using Skntbreak.Core.Interfaces;
using SkntBreak.Infrastructure.Data.Repositories;

namespace Skntbreak.Application.Services
{
    public class UserShiftService : IUserShiftService
    {
        private readonly IUserShiftRepository _userShiftRepository;
        private readonly IUserRepository _userRepository;
        private readonly IScheduleRepository _scheduleRepository;

        public UserShiftService(IUserShiftRepository userShiftRepository, IUserRepository userRepository, IScheduleRepository scheduleRepository)
        {
            _userShiftRepository = userShiftRepository;
            _userRepository = userRepository;
            _scheduleRepository = scheduleRepository;
        }

        public async Task<UserShift> StartShiftAsync(int userId, int scheduleId)
        {
            var user = await _userRepository.GetByIdAsync(userId);
            if (user == null) throw new ArgumentException($"РџРѕР»СЊР·РѕРІР°С‚РµР»СЊ СЃ ID {userId} РЅРµ РЅР°Р№РґРµРЅ");

            var activeShift = await _userShiftRepository.GetActiveShiftAsync(userId);
            if (activeShift != null)
                throw new InvalidOperationException($"РЈ РІР°СЃ СѓР¶Рµ РµСЃС‚СЊ Р°РєС‚РёРІРЅР°СЏ СЃРјРµРЅР° РѕС‚ {activeShift.WorkDate:dd.MM.yyyy}. Р—Р°РІРµСЂС€РёС‚Рµ РµС‘ РїРµСЂРµРґ РЅР°С‡Р°Р»РѕРј РЅРѕРІРѕР№.");

            var today = DateOnly.FromDateTime(DateTime.UtcNow); // РЈР±СЂР°РЅРѕ AddHours(3)

            var schedule = await _scheduleRepository.GetByIdAsync(scheduleId);
            if (schedule == null) throw new ArgumentException($"Р Р°СЃРїРёСЃР°РЅРёРµ СЃ ID {scheduleId} РЅРµ РЅР°Р№РґРµРЅРѕ");

            var userShift = new UserShift
            {
                UserId = userId,
                ScheduleId = scheduleId,
                WorkDate = today,
                Group = schedule.ShiftType,
                StartedAt = DateTime.UtcNow
            };
            return await _userShiftRepository.AddAsync(userShift);
        }

        public async Task<List<ColleagueDto>> GetColleaguesAsync(int scheduleId, DateOnly workDate, int currentUserId)
        {
            var shifts = await _userShiftRepository.GetByScheduleAndDateAsync(scheduleId, workDate);
            return shifts
               .Select(s => new ColleagueDto
               {
                   UserId = s.UserId,
                   UserName = s.User?.UserName ?? "Unknown",
                   Group = s.Group.ToString(),
                   IsCurrentUser = s.UserId == currentUserId,
                   ActiveBreaksCount = s.Breaks?.Count(b => b.Status == BreakStatus.Taken) ?? 0,
                   CompletedBreaksCount = s.Breaks?.Count(b => b.Status == BreakStatus.Finished) ?? 0
               })
               .OrderBy(c => c.IsCurrentUser ? 0 : 1)
               .ThenBy(c => c.UserName)
               .ToList();
        }

        public async Task<UserShift?> GetUserShiftAsync(int userId, DateOnly workDate)
        {
            return await _userShiftRepository.GetByUserAndDateAsync(userId, workDate);
        }

        public async Task<List<UserShift>> GetUserShiftsAsync(int userId)
        {
            var shifts = await _userShiftRepository.GetByUserAsync(userId);
            return shifts.ToList();
        }

        public async Task DeleteUserShiftAsync(int userShiftId, int requestingUserId)
        {
            var userShift = await _userShiftRepository.GetByIdAsync(userShiftId);
            if (userShift == null) throw new ArgumentException($"РЎРјРµРЅР° СЃ ID {userShiftId} РЅРµ РЅР°Р№РґРµРЅР°");
            if (userShift.UserId != requestingUserId) throw new UnauthorizedAccessException("Р’С‹ РЅРµ РјРѕР¶РµС‚Рµ СѓРґР°Р»РёС‚СЊ С‡СѓР¶СѓСЋ СЃРјРµРЅСѓ");
            await _userShiftRepository.DeleteAsync(userShiftId);
        }

        public async Task<List<UserShift>> GetShiftsByDateAndGroupAsync(DateOnly workDate, ShiftType group)
        {
            var shifts = await _userShiftRepository.GetByDateAndGroupAsync(workDate, group);
            return shifts.ToList();
        }

        public async Task<UserShift> EndShiftAsync(int userId)
        {
            var userShift = await _userShiftRepository.GetActiveShiftAsync(userId); // РџРѕРёСЃРє Р°РєС‚РёРІРЅРѕР№, Р° РЅРµ РїРѕ РІС‹С‡РёСЃР»РµРЅРЅРѕР№ РґР°С‚Рµ
            if (userShift == null) throw new InvalidOperationException("РќРµС‚ Р°РєС‚РёРІРЅРѕР№ СЃРјРµРЅС‹");

            var activeBreak = userShift.Breaks.FirstOrDefault(b => b.Status == BreakStatus.Taken);
            if (activeBreak != null) throw new InvalidOperationException("Р—Р°РІРµСЂС€РёС‚Рµ С‚РµРєСѓС‰РёР№ РїРµСЂРµСЂС‹РІ РїРµСЂРµРґ РѕРєРѕРЅС‡Р°РЅРёРµРј СЃРјРµРЅС‹");

            userShift.EndedAt = DateTime.UtcNow;
            await _userShiftRepository.UpdateAsync(userShift);
            return userShift;
        }

        public async Task<List<Schedule>> GetAvailableSchedulesAsync()
        {
            var nowMsk = DateTime.UtcNow.AddHours(3).TimeOfDay;
            var allSchedules = await _scheduleRepository.GetAllAsync();

            return allSchedules
                .Where(s =>
                {
                    if (s.EndTime > s.StartTime)
                        return nowMsk >= s.StartTime && nowMsk <= s.EndTime;
                    else
                        // РЅРѕС‡РЅР°СЏ СЃРјРµРЅР°, РЅР°РїСЂРёРјРµСЂ 22:00вЂ“06:00
                        return nowMsk >= s.StartTime || nowMsk <= s.EndTime;
                })
                .ToList();
        }

    }
}

--- C:\Users\boobi\source\workmain\src\Skntbreak.Core\Dto\Admin\AdminUserDto.cs ---
namespace Skntbreak.Core.Dto.Admin
{
    public class AdminUserDto
    {
        public int Id { get; set; }
        public string UserName { get; set; }
        public string Login { get; set; }
        public string Role { get; set; }
        public int TotalShifts { get; set; }
        public int TotalBreaks { get; set; }
        public int CompletedBreaks { get; set; }
        public int SkippedBreaks { get; set; }
    }
}


--- C:\Users\boobi\source\workmain\src\Skntbreak.Core\Dto\Admin\CreateUserDto.cs ---
namespace Skntbreak.Core.Dto.Admin
{
    public class CreateUserAdminDto
    {
        public string UserName { get; set; }
        public string Login { get; set; }
        public string Password { get; set; }
        public string Role { get; set; } // "SL1", "SL2", "Chatter", "TeamLead", "Admin"
    }
}


--- C:\Users\boobi\source\workmain\src\Skntbreak.Core\Dto\Admin\DashboardStatsDto.cs ---
namespace Skntbreak.Core.Dto.Admin
{
    public class DashboardStatsDto
    {
        public int TotalUsers { get; set; }
        public int TotalShiftsToday { get; set; }
        public int ActiveBreaks { get; set; }
        public int CompletedBreaksToday { get; set; }
        public int SkippedBreaksToday { get; set; }
        public int TotalBreaksToday { get; set; }
    }
}


--- C:\Users\boobi\source\workmain\src\Skntbreak.Core\Dto\Admin\UpdateUserDto.cs ---
namespace Skntbreak.Core.Dto.Admin
{
    public class UpdateUserAdminDto
    {
        public string? UserName { get; set; }
        public string? Login { get; set; }
        public string? Password { get; set; }
        public string? Role { get; set; }
    }
}


--- C:\Users\boobi\source\workmain\src\Skntbreak.Core\Dto\Admin\UserShiftDetailDto.cs ---
using System;

namespace Skntbreak.Core.Dto.Admin
{
    public class UserShiftDetailDto
    {
        public int Id { get; set; }
        public int UserId { get; set; }
        public string UserName { get; set; }
        public string ScheduleName { get; set; }
        public DateOnly WorkDate { get; set; }
        public string Group { get; set; }
        public int TotalBreaks { get; set; }
        public int ActiveBreaks { get; set; }
        public int CompletedBreaks { get; set; }
        public int SkippedBreaks { get; set; }
    }
}


--- C:\Users\boobi\source\workmain\src\Skntbreak.Core\Dto\Break\ActiveBreakDto.cs ---
using Skntbreak.Core.Enums;

namespace Skntbreak.Core.Dto.Break
{
    public class ActiveBreakDto
    {
        public int Id { get; set; }
        public int UserId { get; set; }
        public int UserShiftId { get; set; }
        public BreakStatus Status { get; set; }
        public int DurationMinutes { get; set; }
        public int BreakNumber { get; set; }
        public DateTime StartTime { get; set; }
        public DateOnly WorkDate { get; set; }
        public string UserName { get; set; } = string.Empty; // ДОБАВЛЕНО

        // Вычисляемые свойства
        public DateTime ExpectedEndTime => StartTime.AddMinutes(DurationMinutes);
        public TimeSpan ElapsedTime => DateTime.UtcNow - StartTime;
        public TimeSpan RemainingTime
        {
            get
            {
                var remaining = ExpectedEndTime - DateTime.UtcNow;
                return remaining.TotalSeconds > 0 ? remaining : TimeSpan.Zero;
            }
        }
        public bool IsOverdue => DateTime.UtcNow > ExpectedEndTime;
    }
}


--- C:\Users\boobi\source\workmain\src\Skntbreak.Core\Dto\Break\BreakDetailsDto.cs ---
using Skntbreak.Core.Enums;

namespace Skntbreak.Core.Dto.Break
{
    public class BreakDetailsDto
    {
        public int Id { get; set; }
        public int UserId { get; set; }
        public int UserShiftId { get; set; }
        public BreakStatus Status { get; set; }
        public int DurationMinutes { get; set; }
        public DateTime StartTime { get; set; }
        public DateTime? EndTime { get; set; }
        public DateOnly WorkDate { get; set; }
        public int BreakNumber { get; set; }
    }
}


--- C:\Users\boobi\source\workmain\src\Skntbreak.Core\Dto\Break\BreakHistoryDto.cs ---
using Skntbreak.Core.Enums;

namespace Skntbreak.Core.Dto.Break
{
    public class BreakHistoryDto
    {
        public int Id { get; set; }
        public BreakStatus Status { get; set; }
        public int DurationMinutes { get; set; }
        public DateTime StartTime { get; set; }
        public DateTime? EndTime { get; set; }
        public DateOnly WorkDate { get; set; }
        public TimeSpan? ActualDuration => EndTime.HasValue ? EndTime.Value - StartTime : null;
        public bool IsCompleted => Status == BreakStatus.Finished;
        public bool IsOverdue => EndTime.HasValue && EndTime.Value > StartTime.AddMinutes(DurationMinutes);
    }
}


--- C:\Users\boobi\source\workmain\src\Skntbreak.Core\Dto\Break\BreakPoolInfoDto.cs ---
namespace Skntbreak.Core.Dto.Break
{
    public class BreakPoolInfoDto
    {
        public int TotalBreaks { get; set; }
        public int AvailableBreaks { get; set; }
        public int ActiveBreaks { get; set; }
        public bool CanTakeBreak { get; set; }
        public string? Message { get; set; }
    }
}


--- C:\Users\boobi\source\workmain\src\Skntbreak.Core\Dto\Break\BreakStatisticsDto.cs ---
using Skntbreak.Core.Enums;

namespace Skntbreak.Core.Dto.Break
{
    public class BreakStatisticsDto
    {
        public int TotalBreaks { get; set; }
        public int CompletedBreaks { get; set; }
        public int ActiveBreaks { get; set; }
        public int OverdueBreaks { get; set; }
        public TimeSpan TotalBreakTime { get; set; }
        public TimeSpan AverageBreakTime { get; set; }
        public Dictionary<BreakStatus, int> BreaksByStatus { get; set; } = new();
        public DateOnly WorkDate { get; set; }
        public int UserId { get; set; }
        public string UserName { get; set; }
    }
}


--- C:\Users\boobi\source\workmain\src\Skntbreak.Core\Dto\Break\EndBreakDto.cs ---
namespace Skntbreak.Core.Dto.Break
{
    public class EndBreakDto
    {
        public int BreakId { get; set; }
        public int UserId { get; set; }
        public DateTime EndTime { get; set; }
    }
}


--- C:\Users\boobi\source\workmain\src\Skntbreak.Core\Dto\Break\NonActiveBreakDto.cs ---
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Skntbreak.Core.Enums;

namespace Skntbreak.Core.Dto.Break
{
    public class NonActiveBreakDto
    {
        public int Id { get; set; }
        public int UserId { get; set; }
        public int UserShiftId { get; set; }
        public BreakStatus Status { get; set; }
        public int DurationMinutes { get; set; }
        public int BreakNumber { get; set; }
        public DateTime EndTime { get; set; }
        public DateOnly WorkDate { get; set; }
    }
}

--- C:\Users\boobi\source\workmain\src\Skntbreak.Core\Dto\Break\SkipBreakDto.cs ---
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Skntbreak.Core.Dto.Break
{
    public class SkipBreakDto
    {
        public DateTime RequestTime { get; set; } = DateTime.UtcNow;
        public int BreakNumber { get; set; }
        public int DurationMinutes { get; set; } = 20;
    }
}


--- C:\Users\boobi\source\workmain\src\Skntbreak.Core\Dto\Break\StartBreakDto.cs ---
using Skntbreak.Core.Enums;

namespace Skntbreak.Core.Dto.Break
{
    public class StartBreakDto
    {
        public DateTime RequestTime { get; set; } = DateTime.UtcNow;
        public int BreakNumber { get; set; }
        public int DurationMinutes { get; set; } = 20;
    }
}


--- C:\Users\boobi\source\workmain\src\Skntbreak.Core\Dto\BreakChat\BreakChatDto.cs ---
using Skntbreak.Core.Enums;

namespace Skntbreak.Core.Dto.BreakChat
{
    public class BreakChatDto
    {
        public int Id { get; set; }
        public int UserId { get; set; }
        public DateTime StartTime { get; set; }
        public DateTime EndTime { get; set; }
        public bool IsReserved { get; set; }
        public TimeSpan Duration => EndTime - StartTime;
    }
}


--- C:\Users\boobi\source\workmain\src\Skntbreak.Core\Dto\BreakChat\CreateBreakChatDto.cs ---
using Skntbreak.Core.Enums;

namespace Skntbreak.Core.Dto.BreakChat
{
    public class CreateBreakChatDto
    {
        public int UserId { get; set; }
        public DateTime StartTime { get; set; }
        public DateTime EndTime { get; set; }
        public bool IsReserved { get; set; }
    }
}


--- C:\Users\boobi\source\workmain\src\Skntbreak.Core\Dto\BreakChat\UpdateBreakChatDto.cs ---
using Skntbreak.Core.Enums;

namespace Skntbreak.Core.Dto.BreakChat
{
    public class UpdateBreakChatDto
    {
        public DateTime? StartTime { get; set; }
        public DateTime? EndTime { get; set; }
        public bool? IsReserved { get; set; }
    }
}


--- C:\Users\boobi\source\workmain\src\Skntbreak.Core\Dto\BreakPoolDay\BreakPoolDayDto.cs ---
using Skntbreak.Core.Enums;

namespace Skntbreak.Core.Dto.BreakPoolDay
{
    public class BreakPoolDayDto
    {
        public int Id { get; set; }
        public ShiftType Group { get; set; }
        public DateOnly WorkDate { get; set; }
        public int MaxCurrentBreaks { get; set; }
        public int CurrentBreaksCount { get; set; }
        public int AvailableBreaksCount { get; set; }
    }
}


--- C:\Users\boobi\source\workmain\src\Skntbreak.Core\Dto\BreakPoolDay\CreateBreakPoolDayDto.cs ---
using Skntbreak.Core.Enums;

namespace Skntbreak.Core.Dto.BreakPoolDay
{
    public class CreateBreakPoolDayDto
    {
        public ShiftType Group { get; set; }
        public DateOnly WorkDate { get; set; }
        public int MaxCurrentBreaks { get; set; }
    }
}


--- C:\Users\boobi\source\workmain\src\Skntbreak.Core\Dto\BreakPoolDay\UpdateBreakPoolDayDto.cs ---
using Skntbreak.Core.Enums;

namespace Skntbreak.Core.Dto.BreakPoolDay
{
    public class UpdateBreakPoolDayDto
    {
        public int? MaxCurrentBreaks { get; set; }
    }
}


--- C:\Users\boobi\source\workmain\src\Skntbreak.Core\Dto\Queue\EnqueueRequestDto.cs ---
namespace Skntbreak.Core.Dto.Queue
{
    public class EnqueueRequestDto
    {
        public int? DurationMinutes { get; set; } // null = из шаблона
    }
}


--- C:\Users\boobi\source\workmain\src\Skntbreak.Core\Dto\Queue\QueueEntryDto.cs ---
using Skntbreak.Core.Enums;
namespace Skntbreak.Core.Dto.Queue 
{
    public class QueueEntryDto
    {
        public int Id { get; set; }
        public int UserId { get; set; }
        public string UserName { get; set; } = string.Empty;
        public int Position { get; set; }
        public int DurationMinutes { get; set; }
        public QueueStatus Status { get; set; }
        public bool IsPriority { get; set; }
        public DateTime EnqueuedAt { get; set; }
        public DateTime? NotifiedAt { get; set; }
    }
}


--- C:\Users\boobi\source\workmain\src\Skntbreak.Core\Dto\Queue\QueuePositionDto.cs ---
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Skntbreak.Core.Enums;
namespace Skntbreak.Core.Dto.Queue
{
    public class QueuePositionDto
    {
        public int QueueEntryId { get; set; }
        public int Position { get; set; }
        public int BreakRound { get; set; }
        public int DurationMinutes { get; set; }
        public QueueStatus Status { get; set; }
        public int PeopleAhead { get; set; }
        public string? Message { get; set; }
    }
}



--- C:\Users\boobi\source\workmain\src\Skntbreak.Core\Dto\Queue\QueueStateDto.cs ---
namespace Skntbreak.Core.Dto.Queue
{
    public class QueueStateDto
    {
        public int CurrentRound { get; set; }
        public bool IsRoundComplete { get; set; }
        public List<QueueEntryDto> Queue { get; set; } = new();
        public int AvailableSlots { get; set; }
        public int ActiveBreaks { get; set; }

        // Для 18-02
        public bool AllowDurationChoice { get; set; }
        public int? Remaining10Min { get; set; }
        public int? Remaining20Min { get; set; }
        public QueueEntryDto? MyEntry { get; set; }
    }
}


--- C:\Users\boobi\source\workmain\src\Skntbreak.Core\Dto\Schedules\CreateScheduleDto.cs ---
using Skntbreak.Core.Enums;

namespace Skntbreak.Core.Dto.Schedules
{
    public class CreateScheduleDto
    {
        public string Name { get; set; }
        public TimeSpan StartTime { get; set; }
        public TimeSpan EndTime { get; set; }
        public ShiftType ShiftType { get; set; }
    }
}


--- C:\Users\boobi\source\workmain\src\Skntbreak.Core\Dto\Schedules\ScheduleDto.cs ---
namespace Skntbreak.Core.Dto.Schedules
{
    public class ScheduleDto
    {
        public int Id { get; set; }
        public string Name { get; set; }
        public TimeSpan StartTime { get; set; }
        public TimeSpan EndTime { get; set; }
    }
}


--- C:\Users\boobi\source\workmain\src\Skntbreak.Core\Dto\Schedules\UpdateScheduleDto.cs ---
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Skntbreak.Core.Enums;

namespace Skntbreak.Core.Dto.Schedules
{
    public class UpdateScheduleDto
    {
        public string Name { get; set; }
        public TimeSpan StartTime { get; set; }
        public TimeSpan EndTime { get; set; }
        public ShiftType ShiftType { get; set; }
    }
}


--- C:\Users\boobi\source\workmain\src\Skntbreak.Core\Dto\Users\CreateUserDto.cs ---
using Skntbreak.Core.Enums;

namespace Skntbreak.Core.Dto.Users
{
    public class CreateUserDto
    {
        public string Name { get; set; }
        public RoleType Role { get; set; }
        public string ScheduleName { get; set; }
    }
}


--- C:\Users\boobi\source\workmain\src\Skntbreak.Core\Dto\Users\LoginUserRequest.cs ---
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Skntbreak.Core.Dto.Users
{
    public class LoginUserRequest
    {
        public string Login {  get; set; }
        public string Password { get; set; }
    }
}


--- C:\Users\boobi\source\workmain\src\Skntbreak.Core\Dto\Users\RegisterUserRequest.cs ---
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Skntbreak.Core.Enums;

namespace Skntbreak.Core.Dto.Users
{
    public class RegisterUserRequest
    {
        public string UserName { get; set; }
        public string Login { get; set; }
        public string Password { get; set; }
    }
}


--- C:\Users\boobi\source\workmain\src\Skntbreak.Core\Dto\Users\UpdateProfileDto.cs ---
namespace Skntbreak.Core.Dto.Users
{
    public class UpdateProfileDto
    {
        public string? UserName { get; set; }
    }
}


--- C:\Users\boobi\source\workmain\src\Skntbreak.Core\Dto\Users\UserDto.cs ---
using Skntbreak.Core.Enums;

namespace Skntbreak.Core.Dto.Users
{
    public class UserDto
    {
        public int Id { get; set; }
        public string UserName { get; set; }
        public RoleType Role { get; set; }
    }
}


--- C:\Users\boobi\source\workmain\src\Skntbreak.Core\Dto\Users\UserProfileDto.cs ---
namespace Skntbreak.Core.Dto.Users
{
    public class UserProfileDto
    {
        public int Id { get; set; }
        public string UserName { get; set; }
        public string Login { get; set; }
        public string Role { get; set; }
        public int TotalShifts { get; set; }
        public int TotalBreaks { get; set; }
        public int CompletedBreaks { get; set; }
        public int SkippedBreaks { get; set; }
    }
}


--- C:\Users\boobi\source\workmain\src\Skntbreak.Core\Dto\UserShift\ColleagueDto.cs ---
namespace Skntbreak.Core.Dto.UserShift
{
    public class ColleagueDto
    {
        public int UserId { get; set; }
        public string UserName { get; set; } = string.Empty;
        public string Group { get; set; } = string.Empty;
        public bool IsCurrentUser { get; set; }
        public int ActiveBreaksCount { get; set; }
        public int CompletedBreaksCount { get; set; }
    }
}


--- C:\Users\boobi\source\workmain\src\Skntbreak.Core\Dto\UserShift\StartShiftRequest.cs ---
using System;
using Skntbreak.Core.Enums;

namespace Skntbreak.Core.Dto.UserShift
{
    public class StartShiftRequest
    {
        public int UserId { get; set; }
        public int ScheduleId { get; set; }
    }
}


--- C:\Users\boobi\source\workmain\src\Skntbreak.Core\Entities\Break.cs ---
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Skntbreak.Core.Enums;

namespace Skntbreak.Core.Entities
{
    public class Break
    {
        public int Id { get; set; }

        public int UserShiftId { get; set; }
        public UserShift UserShift { get; set; }

        public BreakStatus Status { get; set; }
        public int DurationMinutes { get; set; }
        public int BreakNumber { get; set; }       // 1-й, 2-й и т.д.
        public DateTime StartTime { get; set; }
        public DateTime? EndTime { get; set; }

        public DateOnly WorkDate { get; set; }
    }
}




--- C:\Users\boobi\source\workmain\src\Skntbreak.Core\Entities\BreakChat.cs ---
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Skntbreak.Core.Enums;

namespace Skntbreak.Core.Entities
{
    public class BreakChat
    {
        public int Id { get; set; }
        public int UserId { get; set; }
        public User User { get; set; }
        public int BreakNumber { get; set; }
        public DateTime StartTime {  get; set; }
        public DateTime EndTime { get; set; }
        public bool IsReserved { get; set; }
    }
}


--- C:\Users\boobi\source\workmain\src\Skntbreak.Core\Entities\BreakPoolDay.cs ---
using Skntbreak.Core.Enums;

namespace Skntbreak.Core.Entities
{
    public class BreakPoolDay
    {
        public int Id { get; set; }
        public ShiftType Group { get; set; }
        public DateOnly WorkDate { get; set; }
        public int TotalBreaks { get; set; }
        public int AvailableBreaks { get; set; }
        public int? Total10MinBreaks { get; set; }
        public int? Remaining10MinBreaks { get; set; }
        public int? Total20MinBreaks { get; set; }
        public int? Remaining20MinBreaks { get; set; }
        public uint Version { get; set; } // Для xmin Concurrency Token
    }
}

--- C:\Users\boobi\source\workmain\src\Skntbreak.Core\Entities\BreakQueue.cs ---
// Skntbreak.Core/Entities/BreakQueue.cs
using Skntbreak.Core.Enums;

namespace Skntbreak.Core.Entities
{
    public class BreakQueue
    {
        public int Id { get; set; }

        // К какой дате+смене привязана очередь
        public DateOnly WorkDate { get; set; }
        public ShiftType Group { get; set; }

        // Какой номер перерыва (волна): 1, 2, 3...
        public int BreakRound { get; set; }

        // Позиция в очереди (1 = первый)
        public int Position { get; set; }

        // Пользователь
        public int UserShiftId { get; set; }
        public UserShift UserShift { get; set; } = null!;

        // Что выбрал (для 18-02: 10 или 20; для остальных — из шаблона)
        public int DurationMinutes { get; set; }

        // Статус в очереди
        public QueueStatus Status { get; set; } = QueueStatus.Waiting;

        // Когда встал в очередь
        public DateTime EnqueuedAt { get; set; }

        // Когда получил уведомление "твоя очередь"
        public DateTime? NotifiedAt { get; set; }

        // Приоритетный перерыв от тимлида
        public bool IsPriority { get; set; } = false;
    }
}


--- C:\Users\boobi\source\workmain\src\Skntbreak.Core\Entities\Schedule.cs ---
using System;
using System.Collections.Generic;
using Skntbreak.Core.Enums;

namespace Skntbreak.Core.Entities
{
    public class Schedule
    {
        public int Id { get; set; }
        public string Name { get; set; } = string.Empty;
        public TimeSpan StartTime { get; set; }
        public TimeSpan EndTime { get; set; }
        public ShiftType ShiftType { get; set; }
        public bool AllowDurationChoice { get; set; } = false; // true для 18-02

        // Navigation properties
        public ICollection<UserShift> UserShifts { get; set; } = new List<UserShift>();
        public ICollection<ShiftBreakTemplate> BreakTemplates { get; set; } = new List<ShiftBreakTemplate>();
    }
}


--- C:\Users\boobi\source\workmain\src\Skntbreak.Core\Entities\ShiftBreakTemplate.cs ---
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Skntbreak.Core.Enums;

namespace Skntbreak.Core.Entities
{
    public class ShiftBreakTemplate
    {
        public int Id { get; set; }
        public int ScheduleId { get; set; }
        public Schedule? Schedule { get; set; }

        public int Order { get; set; } // (1,2,3) - порядковый номер
        public int DurationMinutes { get; set; } // 10 чи 20
    }
}


--- C:\Users\boobi\source\workmain\src\Skntbreak.Core\Entities\User.cs ---
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Skntbreak.Core.Enums;

namespace Skntbreak.Core.Entities
{
    public class User
    {
        public int Id { get; set; }
        public string UserName { get; set; } = string.Empty;
        public string Login { get; set; } = null!;
        public string PasswordHash { get; set; } = string.Empty;
        public RoleType Role { get; set; }

        public ICollection<UserShift> UserShifts { get; set; } = new List<UserShift>();
        public ICollection<BreakChat> BreakChats { get; set; } = new List<BreakChat>();
    }
}


--- C:\Users\boobi\source\workmain\src\Skntbreak.Core\Entities\UserShift.cs ---
using System;
using System.Collections.Generic;
using Skntbreak.Core.Enums;

namespace Skntbreak.Core.Entities
{
    public class UserShift
    {
        public int Id { get; set; }
        public int UserId { get; set; }
        public int ScheduleId { get; set; }
        public DateOnly WorkDate { get; set; }
        public ShiftType Group { get; set; }
        public DateTime StartedAt { get; set; }
        public DateTime? EndedAt { get; set; }
        public User User { get; set; } = null!;
        public Schedule Schedule { get; set; } = null!;
        public ICollection<Break> Breaks { get; set; } = new List<Break>();
        public ICollection<BreakQueue> QueueEntries { get; set; } = new List<BreakQueue>();
        public bool IsActive => EndedAt == null;
    }
}


--- C:\Users\boobi\source\workmain\src\Skntbreak.Core\Enums\BreakStatus.cs ---
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Skntbreak.Core.Enums
{
    public enum BreakStatus
    {
        Available,
        Taken,
        Finished,
        Skipped
    }
}


--- C:\Users\boobi\source\workmain\src\Skntbreak.Core\Enums\BreakType.cs ---
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Skntbreak.Core.Enums
{
    public enum BreakType
    {
        First,
        Second,
        Third,
        Fourth
    }
}


--- C:\Users\boobi\source\workmain\src\Skntbreak.Core\Enums\QueueStatus.cs ---
// Skntbreak.Core/Enums/QueueStatus.cs
namespace Skntbreak.Core.Enums
{
    public enum QueueStatus
    {
        Waiting,        // В очереди, ждёт
        Notified,       // Получил уведомление "твоя очередь"
        Confirmed,      // Подтвердил — перерыв начался
        Postponed,      // Нажал "пока не могу" → сдвиг на +2
        Expired,        // Не ответил за 90 сек → в конец
        Cancelled       // Отменил
    }
}


--- C:\Users\boobi\source\workmain\src\Skntbreak.Core\Enums\RoleType.cs ---
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Skntbreak.Core.Enums
{
    public enum RoleType
    {
        SL1,
        SL2,
        Chatter,
        TeamLead,
        Admin
    }
}


--- C:\Users\boobi\source\workmain\src\Skntbreak.Core\Enums\ShiftType.cs ---
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Skntbreak.Core.Enums
{
    public enum ShiftType
    {
        Day,
        Evening
    }
}


--- C:\Users\boobi\source\workmain\src\Skntbreak.Core\Interfaces\IAdminService.cs ---
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using Skntbreak.Core.Dto.Admin;
using Skntbreak.Core.Dto.BreakPoolDay;
using Skntbreak.Core.Dto.Schedules;
using Skntbreak.Core.Entities;
using Skntbreak.Core.Enums;

namespace Skntbreak.Core.Interfaces
{
    public interface IAdminService
    {
        // Пользователи
        Task<List<AdminUserDto>> GetAllUsers();
        Task<AdminUserDto> GetUserById(int userId);
        Task<AdminUserDto> CreateUser(CreateUserAdminDto request);
        Task<AdminUserDto> UpdateUser(int userId, UpdateUserAdminDto request);
        Task DeleteUser(int userId);

        // Статистика
        Task<DashboardStatsDto> GetDashboardStats();
        Task<List<UserShiftDetailDto>> GetTodayShifts();

        // Расписания
        Task<List<Schedule>> GetAllSchedules();
        Task<Schedule> GetScheduleById(int id);
        Task<Schedule> CreateSchedule(CreateScheduleDto request);
        Task<Schedule> UpdateSchedule(int id, UpdateScheduleDto request);
        Task DeleteSchedule(int id);

        // Пулы перерывов
        Task<List<BreakPoolDayDto>> GetAllBreakPools();
        Task<BreakPoolDayDto> GetBreakPoolByDateAndShift(DateOnly date, ShiftType shift);
        Task<BreakPoolDayDto> CreateOrUpdateBreakPool(CreateBreakPoolDayDto request);
        Task<UserShift> EndUserShiftAsync(int userShiftId);
    }
}


--- C:\Users\boobi\source\workmain\src\Skntbreak.Core\Interfaces\IBreakChatRepository.cs ---
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Skntbreak.Core.Entities;

namespace Skntbreak.Application.Interfaces
{
    public interface IBreakChatRepository
    {
        Task<BreakChat?> GetByIdAsync(int id);
        Task<IEnumerable<BreakChat>> GetAllAsync();
        Task<IEnumerable<BreakChat>> GetByUserAsync(int userId);

        Task<BreakChat> AddAsync(BreakChat chatBreak);
        Task UpdateAsync(BreakChat chatBreak);
        Task DeleteAsync(int id);
    }
}


--- C:\Users\boobi\source\workmain\src\Skntbreak.Core\Interfaces\IBreakPoolDayRepository.cs ---
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Skntbreak.Core.Entities;
using Skntbreak.Core.Enums;

namespace Skntbreak.Core.Interfaces
{
    public interface IBreakPoolDayRepository
    {
        Task<IEnumerable<BreakPoolDay>> GetAllAsync();
        Task<BreakPoolDay?> GetByIdAsync(int id);
        Task<BreakPoolDay?> GetByDateAndShiftAsync(DateOnly workDate, ShiftType shiftType);
        Task<BreakPoolDay> AddAsync(BreakPoolDay breakPoolDay);
        Task<BreakPoolDay> UpdateAsync(BreakPoolDay breakPoolDay);
        Task DeleteAsync(int id);
    }
}


--- C:\Users\boobi\source\workmain\src\Skntbreak.Core\Interfaces\IBreakQueueClient.cs ---
// Skntbreak.Core/Interfaces/IBreakQueueClient.cs
using Skntbreak.Core.Dto.Queue;

namespace Skntbreak.Core.Interfaces
{
    public interface IBreakQueueClient
    {
        Task YourTurn(int queueEntryId, int durationMinutes, int timeoutSeconds);
        Task NotificationExpired(int queueEntryId, int newPosition);
        Task QueueUpdated(List<QueueEntryDto> queue, int availableSlots, int currentRound);
        Task BreakEnded(int userId, string userName, int breakRound);
    }
}


--- C:\Users\boobi\source\workmain\src\Skntbreak.Core\Interfaces\IBreakQueueNotifier.cs ---
// Skntbreak.Core/Interfaces/IBreakQueueNotifier.cs
using Skntbreak.Core.Dto.Queue;

namespace Skntbreak.Core.Interfaces
{
    public interface IBreakQueueNotifier
    {
        Task NotifyYourTurnAsync(int userId, int queueEntryId, int durationMinutes, int timeoutSeconds);
        Task NotifyExpiredAsync(int userId, int queueEntryId, int newPosition);
        Task BroadcastQueueUpdateAsync(DateOnly workDate, int group, List<QueueEntryDto> queue, int availableSlots, int currentRound);
        Task BroadcastBreakEndedAsync(DateOnly workDate, int group, int userId, string userName, int breakRound);
    }
}


--- C:\Users\boobi\source\workmain\src\Skntbreak.Core\Interfaces\IBreakQueueRepository.cs ---
using Skntbreak.Core.Entities;
using Skntbreak.Core.Enums;

namespace Skntbreak.Core.Interfaces
{
    public interface IBreakQueueRepository
    {
        Task<BreakQueue?> GetByIdAsync(int id);
        Task<List<BreakQueue>> GetQueueAsync(DateOnly workDate, ShiftType group, int breakRound);
        Task<BreakQueue?> GetUserEntryAsync(int userShiftId, int breakRound);
        Task<BreakQueue?> GetNextWaitingAsync(DateOnly workDate, ShiftType group, int breakRound);
        Task<BreakQueue?> GetNextEligibleWaitingAsync(DateOnly workDate, ShiftType group, int breakRound, TimeSpan interval); // НОВЫЙ МЕТОД
        Task<int> GetMaxPositionAsync(DateOnly workDate, ShiftType group, int breakRound);
        Task<bool> IsRoundCompleteAsync(DateOnly workDate, ShiftType group, int breakRound, int totalUsersInShift);
        Task<List<BreakQueue>> GetExpiredNotificationsAsync(TimeSpan timeout);
        Task<BreakQueue> AddAsync(BreakQueue entry);
        Task UpdateAsync(BreakQueue entry);
        Task UpdateRangeAsync(IEnumerable<BreakQueue> entries);
        Task DeleteAsync(int id);
        Task<int> CountActiveInRoundAsync(DateOnly workDate, ShiftType group, int breakRound);
        Task<bool> HasNotifiedEntryAsync(DateOnly workDate, ShiftType group, int breakRound);
    }
}

--- C:\Users\boobi\source\workmain\src\Skntbreak.Core\Interfaces\IBreakQueueService.cs ---
using Skntbreak.Core.Dto.Queue;
using Skntbreak.Core.Dto.Break;
using Skntbreak.Core.Enums;

namespace Skntbreak.Core.Interfaces
{
    public interface IBreakQueueService
    {
        Task<QueuePositionDto> EnqueueAsync(int userId, int? durationMinutes = null);
        Task<QueueStateDto> GetQueueStateAsync(int userId);
        Task<ActiveBreakDto> ConfirmBreakAsync(int userId, int queueEntryId);
        Task<QueuePositionDto> PostponeAsync(int userId, int queueEntryId);
        Task ExpireNotificationAsync(int queueEntryId);
        Task<QueuePositionDto> EnqueuePriorityAsync(int targetUserId, int requestingUserId, int? durationMinutes = null);
        Task SkipBreakRoundAsync(int userId);
        Task ProcessNextInQueueAsync(DateOnly workDate, ShiftType group, int breakRound);
    }
}


--- C:\Users\boobi\source\workmain\src\Skntbreak.Core\Interfaces\IBreakRepository.cs ---
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Skntbreak.Core.Entities;
using Skntbreak.Core.Enums;

namespace Skntbreak.Core.Interfaces
{
    public interface IBreakRepository
    {
        Task<Break?> GetByIdAsync(int id);
        Task<IEnumerable<Break>> GetAllAsync();
        Task<IEnumerable<Break>> GetActiveBreaksByUserAsync(int userId);
        Task<Break> GetActiveBreakByUserAsync(int userId);
        Task<IEnumerable<Break>> GetActiveBreaksByScheduleAsync(int scheduleId);
        Task<Break?> GetAvailableBreakAsync(int userShiftId);
        Task<Break?> GetLastFinishedBreakByUserAsync(int userId);
        Task<Break?> GetNextAvailableBreakByUserAsync(int userId);
        Task<Break?> GetLastBreakByUserAsync(int userId);
        Task<Break?> GetLastBreakByUserShiftAsync(int userShiftId);
        Task<Break?> GetActiveBreakByUserShiftAsync(int userShiftId);

        Task<IEnumerable<Break>> GetBreaksByDateAndGroupAsync(DateOnly workDate, ShiftType group);
        Task<Break> AddAsync(Break brk);
        Task UpdateAsync(Break brk);
        Task DeleteAsync(int id);
    }
}


--- C:\Users\boobi\source\workmain\src\Skntbreak.Core\Interfaces\IBreakService.cs ---
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using Skntbreak.Core.Dto.Break;

namespace Skntbreak.Core.Interfaces
{
    public interface IBreakService
    {
        Task<ActiveBreakDto> StartBreakAsync(StartBreakDto request, int userId);
        Task<BreakDetailsDto> SkipBreakAsync(SkipBreakDto request, int userId);
        Task<BreakDetailsDto> EndBreakAsync(int breakId, int userId);
        Task<BreakDetailsDto> SkipBreakAsync(int breakId, int userId);
        Task<List<ActiveBreakDto>> GetActiveBreaksAsync();
        Task<List<ActiveBreakDto>> GetActiveBreaksByScheduleAsync(int scheduleId);
        Task<ActiveBreakDto?> GetUserActiveBreakAsync(int userId);
        Task<List<BreakDetailsDto>> GetUserBreakHistoryAsync(int userId, DateOnly date);
        Task<BreakStatisticsDto> GetBreakStatisticsAsync(int userId, DateOnly date);
        Task<BreakStatisticsDto> GetScheduleStatisticsAsync(int scheduleId, DateOnly date);
        Task InitializeUserShiftBreaksAsync(int userShiftId);
        Task<List<BreakDetailsDto>> GetAvailableBreaksAsync(int userId, DateOnly date);
        Task<List<ActiveBreakDto>> GetActiveBreaksByDateAsync(DateOnly workDate, int currentUserId);

        // НОВЫЙ МЕТОД
        Task<BreakPoolInfoDto> GetBreakPoolInfoAsync(DateOnly workDate, int userId);
    }
}


--- C:\Users\boobi\source\workmain\src\Skntbreak.Core\Interfaces\IJwtProvider.cs ---
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Skntbreak.Core.Entities;

namespace Skntbreak.Core.Interfaces
{
    public interface IJwtProvider
    {
        public string GenerateToken(User user);
    }
}


--- C:\Users\boobi\source\workmain\src\Skntbreak.Core\Interfaces\IPasswordHasher.cs ---
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Skntbreak.Core.Interfaces
{
    public interface IPasswordHasher
    {
        string Generate(string password);
        bool Verify(string password, string hashedPassword);
    }
}


--- C:\Users\boobi\source\workmain\src\Skntbreak.Core\Interfaces\IScheduleRepository.cs ---
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Skntbreak.Core.Entities;

namespace Skntbreak.Application.Interfaces
{
    public interface IScheduleRepository
    {
        Task<Schedule?> GetByIdAsync(int id);
        Task<IEnumerable<Schedule>> GetAllAsync();
        Task<Schedule?> GetWithRulesAsync(int id);
        Task<Schedule?> GetWithUsersAsync(int id);

        Task<Schedule> AddAsync(Schedule schedule);
        Task UpdateAsync(Schedule schedule);
        Task DeleteAsync(int id);
    }
}



--- C:\Users\boobi\source\workmain\src\Skntbreak.Core\Interfaces\IScheduleService.cs ---
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Skntbreak.Core.Dto.Schedules;
using Skntbreak.Core.Entities;

namespace Skntbreak.Core.Interfaces
{
    public interface IScheduleService
    {
        Task<Schedule> CreateSchedule(CreateScheduleDto createScheduleDto);
        Task<List<Schedule>> GetAllSchedules();
        Task<Schedule> GetScheduleById(int id);
        Task<Schedule> DeleteSchedule(int id);
        Task<Schedule> UpdateSchedule(int id, UpdateScheduleDto updateScheduleDto);
    }
}


--- C:\Users\boobi\source\workmain\src\Skntbreak.Core\Interfaces\IShiftBreakTemplateRepository.cs ---
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Skntbreak.Core.Entities;

namespace Skntbreak.Core.Interfaces
{
    public interface IShiftBreakTemplateRepository
    {
        Task<ShiftBreakTemplate?> GetByIdAsync(int id);
        Task<IEnumerable<ShiftBreakTemplate>> GetAllAsync();
        Task<IEnumerable<ShiftBreakTemplate>> GetByScheduleAsync(int scheduleId);

        Task<ShiftBreakTemplate> AddAsync(ShiftBreakTemplate template);
        Task UpdateAsync(ShiftBreakTemplate template);
        Task DeleteAsync(int id);
    }
}


--- C:\Users\boobi\source\workmain\src\Skntbreak.Core\Interfaces\IUserRepository.cs ---
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Skntbreak.Core.Entities;

namespace Skntbreak.Application.Interfaces
{
    public interface IUserRepository
    {
        Task<User?> GetByIdAsync(int id);
        Task<IEnumerable<User>> GetAllAsync();
        Task<User?> GetByLoginAsync(string login);
        Task<IEnumerable<User>> GetByScheduleAsync(int scheduleId);

        Task<User> AddAsync(User user);
        Task UpdateAsync(User user);
        Task DeleteAsync(int id);
        Task<IEnumerable<User>> GetAllWithShiftsAndBreaksAsync();
        Task<User?> GetByIdWithShiftsAndBreaksAsync(int userId);
    }
}

--- C:\Users\boobi\source\workmain\src\Skntbreak.Core\Interfaces\IUserService.cs ---
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Skntbreak.Core.Dto.Users;

namespace Skntbreak.Core.Interfaces
{
    public interface IUserService
    {
        public Task Register(string userName, string login, string password);
        public Task<string> Login(string login, string password);
        public Task<UserProfileDto> GetProfile(int userId);
        public Task UpdateProfile(int userId, UpdateProfileDto request);
    }
}


--- C:\Users\boobi\source\workmain\src\Skntbreak.Core\Interfaces\IUserShiftRepository.cs ---
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using Skntbreak.Core.Entities;
using Skntbreak.Core.Enums;

namespace Skntbreak.Core.Interfaces
{
    public interface IUserShiftRepository
    {
        Task<UserShift?> GetByIdAsync(int id);
        Task<IEnumerable<UserShift>> GetAllAsync();
        Task<UserShift?> GetByUserAndDateAsync(int userId, DateOnly workDate);
        Task<IEnumerable<UserShift>> GetByUserAsync(int userId);
        Task<IEnumerable<UserShift>> GetByScheduleAsync(int scheduleId);
        Task<IEnumerable<UserShift>> GetByDateAsync(DateOnly workDate);
        Task<IEnumerable<UserShift>> GetByDateAndGroupAsync(DateOnly workDate, ShiftType group);
        Task<UserShift> AddAsync(UserShift userShift);
        Task UpdateAsync(UserShift userShift);
        Task DeleteAsync(int id);
        Task<IEnumerable<UserShift>> GetByScheduleAndDateAsync(int scheduleId, DateOnly date);
        Task<UserShift?> GetActiveShiftAsync(int userId);
    }
}


--- C:\Users\boobi\source\workmain\src\Skntbreak.Core\Interfaces\IUserShiftService.cs ---
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using Skntbreak.Core.Dto.UserShift;
using Skntbreak.Core.Entities;
using Skntbreak.Core.Enums;

namespace Skntbreak.Core.Interfaces
{
    public interface IUserShiftService
    {
        Task<UserShift> StartShiftAsync(int userId, int scheduleId);
        //Task<UserShift> StartShiftAutoAsync(int userId); // Новый метод
        Task<UserShift?> GetUserShiftAsync(int userId, DateOnly workDate);
        Task<List<UserShift>> GetUserShiftsAsync(int userId);
        Task DeleteUserShiftAsync(int userShiftId, int requestingUserId);
        Task<List<UserShift>> GetShiftsByDateAndGroupAsync(DateOnly workDate, ShiftType group);
        Task<List<ColleagueDto>> GetColleaguesAsync(int scheduleId, DateOnly workDate, int currentUserId);
        Task<UserShift> EndShiftAsync(int userId);
        Task<List<Schedule>> GetAvailableSchedulesAsync();

    }
}


--- C:\Users\boobi\source\workmain\src\SkntBreak.Infrastructure\Data\Configurations\BreakChatConfiguration.cs ---
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;
using Skntbreak.Core.Entities;

namespace SkntBreak.Infrastructure.Data.Configurations
{
    public class BreakChatConfiguration : IEntityTypeConfiguration<BreakChat>
    {
        public void Configure(EntityTypeBuilder<BreakChat> builder)
        {
            builder.HasKey(bc => bc.Id);

            builder.Property(bc => bc.BreakNumber)
                .IsRequired();

            builder.Property(bc => bc.IsReserved)
                .IsRequired();

            builder.HasOne(bc => bc.User)
                .WithMany(u => u.BreakChats)
                .HasForeignKey(bc => bc.UserId);
        }
    }
}


--- C:\Users\boobi\source\workmain\src\SkntBreak.Infrastructure\Data\Configurations\BreakConfiguration.cs ---
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;
using Skntbreak.Core.Entities;

namespace SkntBreak.Infrastructure.Data.Configurations
{
    public class BreakConfiguration : IEntityTypeConfiguration<Break>
    {
        public void Configure(EntityTypeBuilder<Break> builder)
        {
            builder.HasKey(b => b.Id);

            builder.Property(b => b.Status)
                .IsRequired();

            builder.Property(b => b.StartTime)
                .IsRequired();

            builder.Property(b => b.EndTime)
                .IsRequired(false);

            builder.Property(b => b.DurationMinutes)
                .IsRequired();

            builder.Property(b => b.BreakNumber)
                .IsRequired();

            builder.Property(b => b.WorkDate)
                .IsRequired();

            builder.HasOne(b => b.UserShift)
                .WithMany(us => us.Breaks)
                .HasForeignKey(b => b.UserShiftId)
                .OnDelete(DeleteBehavior.Cascade);
        }
    }
}


--- C:\Users\boobi\source\workmain\src\SkntBreak.Infrastructure\Data\Configurations\BreakPoolDayConfiguration.cs ---
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;
using Skntbreak.Core.Entities;

namespace Skntbreak.Infrastructure.Data.Configurations
{
    public class BreakPoolDayConfiguration : IEntityTypeConfiguration<BreakPoolDay>
    {
        public void Configure(EntityTypeBuilder<BreakPoolDay> builder)
        {
            builder.HasKey(bpd => bpd.Id);
            builder.Property(bpd => bpd.WorkDate).IsRequired();
            builder.Property(bpd => bpd.Group).IsRequired();

            // Исправленная строка: используем стандартный метод IsRowVersion() 
            // Npgsql автоматически свяжет это поле типа uint с системной колонкой xmin в PostgreSQL
            builder.Property(bpd => bpd.Version).IsRowVersion();
        }
    }
}

--- C:\Users\boobi\source\workmain\src\SkntBreak.Infrastructure\Data\Configurations\BreakQueueConfiguration.cs ---
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;
using Skntbreak.Core.Entities;

namespace SkntBreak.Infrastructure.Data.Configurations
{
    public class BreakQueueConfiguration : IEntityTypeConfiguration<BreakQueue>
    {
        public void Configure(EntityTypeBuilder<BreakQueue> builder)
        {
            builder.HasKey(q => q.Id);

            builder.Property(q => q.WorkDate).IsRequired();
            builder.Property(q => q.Group).IsRequired();
            builder.Property(q => q.BreakRound).IsRequired();
            builder.Property(q => q.Position).IsRequired();
            builder.Property(q => q.DurationMinutes).IsRequired();
            builder.Property(q => q.Status).IsRequired();
            builder.Property(q => q.EnqueuedAt).IsRequired();
            builder.Property(q => q.IsPriority).IsRequired().HasDefaultValue(false);

            builder.HasOne(q => q.UserShift)
                .WithMany(us => us.QueueEntries)
                .HasForeignKey(q => q.UserShiftId)
                .OnDelete(DeleteBehavior.Cascade);

            builder.HasIndex(q => new { q.WorkDate, q.Group, q.BreakRound, q.Position })
                .HasDatabaseName("IX_BreakQueues_WorkDate_Group_Round_Pos");

            builder.HasIndex(q => new { q.Status, q.NotifiedAt })
                .HasDatabaseName("IX_BreakQueues_Status_NotifiedAt");
        }
    }
}

--- C:\Users\boobi\source\workmain\src\SkntBreak.Infrastructure\Data\Configurations\ScheduleConfiguration.cs ---
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;
using Skntbreak.Core.Entities;

namespace SkntBreak.Infrastructure.Data.Configurations
{
    public class ScheduleConfiguration : IEntityTypeConfiguration<Schedule>
    {
        public void Configure(EntityTypeBuilder<Schedule> builder)
        {
            builder.HasKey(s => s.Id);

            builder.Property(s => s.Name)
                .IsRequired()
                .HasMaxLength(100);

            builder.Property(s => s.StartTime)
                .IsRequired();

            builder.Property(s => s.EndTime)
                .IsRequired();

            builder.HasMany(s => s.UserShifts)
                .WithOne(us => us.Schedule)
                .HasForeignKey(us => us.ScheduleId)
                .OnDelete(DeleteBehavior.Restrict);

            builder.HasMany(s => s.BreakTemplates)
                .WithOne(bt => bt.Schedule)
                .HasForeignKey(bt => bt.ScheduleId)
                .OnDelete(DeleteBehavior.Cascade);
        }
    }
}


--- C:\Users\boobi\source\workmain\src\SkntBreak.Infrastructure\Data\Configurations\ShiftBreakTemplateConfiguration.cs ---
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;
using Skntbreak.Core.Entities;

namespace SkntBreak.Infrastructure.Data.Configurations
{
    public class ShiftBreakTemplateConfiguration : IEntityTypeConfiguration<ShiftBreakTemplate>
    {
        public void Configure(EntityTypeBuilder<ShiftBreakTemplate> builder)
        {
            builder.HasKey(sbt => sbt.Id);

            builder.Property(sbt => sbt.Order)
                .IsRequired();

            builder.Property(sbt => sbt.DurationMinutes)
                .IsRequired();

            builder.HasOne(sbt => sbt.Schedule)
                .WithMany(s => s.BreakTemplates)
                .HasForeignKey(sbt => sbt.ScheduleId)
                .OnDelete(DeleteBehavior.Cascade);
        }
    }
}


--- C:\Users\boobi\source\workmain\src\SkntBreak.Infrastructure\Data\Configurations\UserConfiguration.cs ---
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.EntityFrameworkCore;
using Skntbreak.Core.Entities;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace SkntBreak.Infrastructure.Data.Configurations
{
    public class UserConfiguration : IEntityTypeConfiguration<User>
    {
        public void Configure(EntityTypeBuilder<User> builder)
        {
            builder.HasKey(u => u.Id);

            builder.Property(u => u.UserName)
                .IsRequired()
                .HasMaxLength(100);

            builder.Property(u => u.Login)
                .IsRequired()
                .HasMaxLength(50);

            builder.Property(u => u.PasswordHash)
                .IsRequired()
                .HasMaxLength(255);

            builder.Property(u => u.Role)
                .IsRequired();

            builder.HasMany(u => u.UserShifts)
                .WithOne(us => us.User)
                .HasForeignKey(us => us.UserId)
                .OnDelete(DeleteBehavior.Cascade);

            builder.HasMany(u => u.BreakChats)
                .WithOne(bc => bc.User)
                .HasForeignKey(bc => bc.UserId)
                .OnDelete(DeleteBehavior.Cascade);
        }
    }
}


--- C:\Users\boobi\source\workmain\src\SkntBreak.Infrastructure\Data\Configurations\UserShiftConfiguration.cs ---
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;
using Skntbreak.Core.Entities;

namespace SkntBreak.Infrastructure.Data.Configurations
{
    public class UserShiftConfiguration : IEntityTypeConfiguration<UserShift>
    {
        public void Configure(EntityTypeBuilder<UserShift> builder)
        {
            builder.HasKey(us => us.Id);

            builder.Property(us => us.WorkDate)
                .IsRequired();

            builder.Property(us => us.Group)
                .IsRequired();

            builder.HasOne(us => us.User)
                .WithMany(u => u.UserShifts)
                .HasForeignKey(us => us.UserId)
                .OnDelete(DeleteBehavior.Cascade);

            builder.HasOne(us => us.Schedule)
                .WithMany(s => s.UserShifts)
                .HasForeignKey(us => us.ScheduleId)
                .OnDelete(DeleteBehavior.Restrict);

            builder.HasMany(us => us.Breaks)
                .WithOne(b => b.UserShift)
                .HasForeignKey(b => b.UserShiftId)
                .OnDelete(DeleteBehavior.Cascade);

            builder.HasIndex(us => new { us.UserId, us.WorkDate })
                .IsUnique();
        }
    }
}


--- C:\Users\boobi\source\workmain\src\SkntBreak.Infrastructure\Data\Repositories\BreakChatRepository.cs ---
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.EntityFrameworkCore;
using Skntbreak.Application.Interfaces;
using Skntbreak.Core.Entities;
using SkntBreak.Infrastructure.Data;

namespace Skntbreak.Infrastructure.Data.Repositories
{
    public class BreakChatRepository : IBreakChatRepository
    {
        private readonly SkntbreakDbContext _context;

        public BreakChatRepository(SkntbreakDbContext context)
        {
            _context = context;
        }

        public async Task<BreakChat?> GetByIdAsync(int id)
        {
            return await _context.BreakChats
                .Include(bc => bc.User)
                .AsNoTracking()
                .FirstOrDefaultAsync(bc => bc.Id == id);
        }

        public async Task<IEnumerable<BreakChat>> GetAllAsync()
        {
            return await _context.BreakChats
                .Include(bc => bc.User)
                .AsNoTracking()
                .OrderByDescending(bc => bc.StartTime)
                .ToListAsync();
        }

        public async Task<IEnumerable<BreakChat>> GetByUserAsync(int userId)
        {
            return await _context.BreakChats
                .Include(bc => bc.User)
                .AsNoTracking()
                .Where(bc => bc.UserId == userId)
                .OrderByDescending(bc => bc.StartTime)
                .ToListAsync();
        }

        public async Task<BreakChat> AddAsync(BreakChat chatBreak)
        {
            if (chatBreak.UserId <= 0)
                throw new ArgumentException("Поле с UserId не может быть пустым");

            if (chatBreak.StartTime >= chatBreak.EndTime)
                throw new ArgumentException("Время начала должно быть меньше времени окончания");

            var overlappingBreaks = await _context.BreakChats
                .AnyAsync(bc => bc.UserId == chatBreak.UserId &&
                               ((bc.StartTime <= chatBreak.StartTime && bc.EndTime > chatBreak.StartTime) ||
                                (bc.StartTime < chatBreak.EndTime && bc.EndTime >= chatBreak.EndTime) ||
                                (bc.StartTime >= chatBreak.StartTime && bc.EndTime <= chatBreak.EndTime)));

            if (overlappingBreaks)
                throw new InvalidOperationException("Перерыв пересекается с существующими перерывами пользователя");

            await _context.BreakChats.AddAsync(chatBreak);
            await _context.SaveChangesAsync();

            return chatBreak;
        }

        public async Task UpdateAsync(BreakChat chatBreak)
        {
            var chatBreakEntity = await _context.BreakChats.FindAsync(chatBreak.Id);
            if (chatBreakEntity == null)
            {
                throw new InvalidOperationException($"Запись перерыва с Id - {chatBreak.Id} не найдена");
            }

            if (chatBreak.StartTime >= chatBreak.EndTime)
                throw new ArgumentException("Время начала должно быть меньше времени окончания");

            var overlappingBreaks = await _context.BreakChats
                .AnyAsync(bc => bc.UserId == chatBreak.UserId &&
                               bc.Id != chatBreak.Id &&
                               ((bc.StartTime <= chatBreak.StartTime && bc.EndTime > chatBreak.StartTime) ||
                                (bc.StartTime < chatBreak.EndTime && bc.EndTime >= chatBreak.EndTime) ||
                                (bc.StartTime >= chatBreak.StartTime && bc.EndTime <= chatBreak.EndTime)));

            if (overlappingBreaks)
                throw new InvalidOperationException("Перерыв пересекается с существующими перерывами пользователя");

            _context.BreakChats.Update(chatBreak);
            await _context.SaveChangesAsync();
        }

        public async Task DeleteAsync(int id)
        {
            var chatBreak = await _context.BreakChats
                .Include(bc => bc.User)
                .FirstOrDefaultAsync(bc => bc.Id == id);

            if (chatBreak == null)
            {
                throw new InvalidOperationException($"Запись перерыва с данным Id - {id} не найдена");
            }

            _context.BreakChats.Remove(chatBreak);
            await _context.SaveChangesAsync();
        }
    }
}


--- C:\Users\boobi\source\workmain\src\SkntBreak.Infrastructure\Data\Repositories\BreakPoolDayRepository.cs ---
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.EntityFrameworkCore;
using Skntbreak.Core.Entities;
using Skntbreak.Core.Enums;
using Skntbreak.Core.Interfaces;
using SkntBreak.Infrastructure.Data;

namespace Skntbreak.Infrastructure.Data.Repositories
{
    public class BreakPoolDayRepository : IBreakPoolDayRepository
    {
        private readonly SkntbreakDbContext _context;

        public BreakPoolDayRepository(SkntbreakDbContext context)
        {
            _context = context;
        }

        public async Task<IEnumerable<BreakPoolDay>> GetAllAsync()
        {
            return await _context.BreakPoolDays
                .AsNoTracking()
                .OrderBy(b => b.Id)
                .ToListAsync();
        }

        public async Task<BreakPoolDay?> GetByIdAsync(int id)
        {
            return await _context.BreakPoolDays
                .AsNoTracking()
                .FirstOrDefaultAsync(b => b.Id == id);
        }

        public async Task<BreakPoolDay?> GetByDateAndShiftAsync(DateOnly workDate, ShiftType shiftType)
        {
            return await _context.BreakPoolDays
                .FirstOrDefaultAsync(b => b.WorkDate == workDate && b.Group == shiftType);
        }

        public async Task<BreakPoolDay> AddAsync(BreakPoolDay breakPoolDay)
        {
            _context.BreakPoolDays.Add(breakPoolDay);
            await _context.SaveChangesAsync();
            return breakPoolDay;
        }

        public async Task<BreakPoolDay> UpdateAsync(BreakPoolDay breakPoolDay)
        {
            _context.BreakPoolDays.Update(breakPoolDay);
            await _context.SaveChangesAsync();
            return breakPoolDay;
        }

        public async Task DeleteAsync(int id)
        {
            var breakPoolDay = await _context.BreakPoolDays.FindAsync(id);
            if (breakPoolDay != null)
            {
                _context.BreakPoolDays.Remove(breakPoolDay);
                await _context.SaveChangesAsync();
            }
        }
    }
}


--- C:\Users\boobi\source\workmain\src\SkntBreak.Infrastructure\Data\Repositories\BreakQueueRepository.cs ---
using Microsoft.EntityFrameworkCore;
using Skntbreak.Core.Entities;
using Skntbreak.Core.Enums;
using Skntbreak.Core.Interfaces;
using SkntBreak.Infrastructure.Data;

namespace Skntbreak.Infrastructure.Data.Repositories
{
    public class BreakQueueRepository : IBreakQueueRepository
    {
        private readonly SkntbreakDbContext _context;

        public BreakQueueRepository(SkntbreakDbContext context)
        {
            _context = context;
        }

        public async Task<BreakQueue?> GetByIdAsync(int id)
        {
            return await _context.BreakQueues
               .Include(q => q.UserShift).ThenInclude(us => us.User)
               .Include(q => q.UserShift).ThenInclude(us => us.Schedule)
               .FirstOrDefaultAsync(q => q.Id == id);
        }

        public async Task<List<BreakQueue>> GetQueueAsync(DateOnly workDate, ShiftType group, int breakRound)
        {
            return await _context.BreakQueues
               .Include(q => q.UserShift).ThenInclude(us => us.User)
               .Include(q => q.UserShift).ThenInclude(us => us.Schedule)
               .Where(q => q.WorkDate == workDate && q.Group == group && q.BreakRound == breakRound)
               .OrderBy(q => q.Position)
               .ToListAsync();
        }

        public async Task<BreakQueue?> GetUserEntryAsync(int userShiftId, int breakRound)
        {
            return await _context.BreakQueues
               .Include(q => q.UserShift).ThenInclude(us => us.User)
               .Where(q => q.UserShiftId == userShiftId && q.BreakRound == breakRound && q.Status != QueueStatus.Cancelled && q.Status != QueueStatus.Expired)
               .FirstOrDefaultAsync();
        }

        public async Task<BreakQueue?> GetNextWaitingAsync(DateOnly workDate, ShiftType group, int breakRound)
        {
            return await _context.BreakQueues
               .Include(q => q.UserShift).ThenInclude(us => us.User)
               .Where(q => q.WorkDate == workDate && q.Group == group && q.BreakRound == breakRound && q.Status == QueueStatus.Waiting)
               .OrderBy(q => q.Position)
               .FirstOrDefaultAsync();
        }

        // НОВЫЙ МЕТОД: Устраняет проблему N+1, проверяя интервал перерывов прямо в SQL-запросе
        public async Task<BreakQueue?> GetNextEligibleWaitingAsync(DateOnly workDate, ShiftType group, int breakRound, TimeSpan interval)
        {
            var cutoffTime = DateTime.UtcNow.Subtract(interval);
            return await _context.BreakQueues
               .Include(q => q.UserShift).ThenInclude(us => us.User)
               .Where(q => q.WorkDate == workDate && q.Group == group && q.BreakRound == breakRound && q.Status == QueueStatus.Waiting)
               .Where(q => !_context.Breaks.Any(b => b.UserShift.UserId == q.UserShift.UserId && b.Status == BreakStatus.Finished && b.EndTime > cutoffTime))
               .OrderBy(q => q.Position)
               .FirstOrDefaultAsync();
        }

        public async Task<int> GetMaxPositionAsync(DateOnly workDate, ShiftType group, int breakRound)
        {
            var maxPos = await _context.BreakQueues
               .Where(q => q.WorkDate == workDate && q.Group == group && q.BreakRound == breakRound && q.Status != QueueStatus.Cancelled)
               .MaxAsync(q => (int?)q.Position);
            return maxPos ?? 0;
        }

        public async Task<bool> IsRoundCompleteAsync(DateOnly workDate, ShiftType group, int breakRound, int totalUsersInShift)
        {
            var completedCount = await _context.Breaks
               .Where(b => b.WorkDate == workDate && b.UserShift.Group == group && b.BreakNumber == breakRound && (b.Status == BreakStatus.Finished || b.Status == BreakStatus.Skipped))
               .Select(b => b.UserShift.UserId)
               .Distinct()
               .CountAsync();
            return completedCount >= totalUsersInShift;
        }

        public async Task<List<BreakQueue>> GetExpiredNotificationsAsync(TimeSpan timeout)
        {
            var cutoff = DateTime.UtcNow - timeout;
            return await _context.BreakQueues
               .Include(q => q.UserShift).ThenInclude(us => us.User)
               .Where(q => q.Status == QueueStatus.Notified && q.NotifiedAt != null && q.NotifiedAt < cutoff)
               .ToListAsync();
        }

        public async Task<BreakQueue> AddAsync(BreakQueue entry)
        {
            _context.BreakQueues.Add(entry);
            await _context.SaveChangesAsync();
            return entry;
        }

        public async Task UpdateAsync(BreakQueue entry)
        {
            _context.BreakQueues.Update(entry);
            await _context.SaveChangesAsync();
        }

        public async Task UpdateRangeAsync(IEnumerable<BreakQueue> entries)
        {
            _context.BreakQueues.UpdateRange(entries);
            await _context.SaveChangesAsync();
        }

        public async Task DeleteAsync(int id)
        {
            var entry = await _context.BreakQueues.FindAsync(id);
            if (entry != null)
            {
                _context.BreakQueues.Remove(entry);
                await _context.SaveChangesAsync();
            }
        }

        public async Task<int> CountActiveInRoundAsync(DateOnly workDate, ShiftType group, int breakRound)
        {
            return await _context.BreakQueues
               .CountAsync(q => q.WorkDate == workDate && q.Group == group && q.BreakRound == breakRound && (q.Status == QueueStatus.Waiting || q.Status == QueueStatus.Notified));
        }

        public async Task<bool> HasNotifiedEntryAsync(DateOnly workDate, ShiftType group, int breakRound)
        {
            return await _context.BreakQueues
               .AnyAsync(q => q.WorkDate == workDate && q.Group == group && q.BreakRound == breakRound && q.Status == QueueStatus.Notified);
        }
    }
}

--- C:\Users\boobi\source\workmain\src\SkntBreak.Infrastructure\Data\Repositories\BreakRepository.cs ---
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.EntityFrameworkCore;
using Skntbreak.Core.Entities;
using Skntbreak.Core.Enums;
using Skntbreak.Core.Interfaces;

namespace SkntBreak.Infrastructure.Data.Repositories
{
    public class BreakRepository : IBreakRepository
    {
        private readonly SkntbreakDbContext _context;

        public BreakRepository(SkntbreakDbContext context)
        {
            _context = context;
        }
        public async Task<Break?> GetByIdAsync(int id)
        {
            return await _context.Breaks
                .Include(b => b.UserShift)
                    .ThenInclude(us => us.User)
                .Include(b => b.UserShift)
                    .ThenInclude(us => us.Schedule)
                .AsNoTracking()
                .FirstOrDefaultAsync(b => b.Id == id);
        }
        public async Task<IEnumerable<Break>> GetAllAsync()
        {
            return await _context.Breaks
                .Include(b => b.UserShift)
                    .ThenInclude(us => us.User)
                .Include(b => b.UserShift)
                    .ThenInclude(us => us.Schedule)
                .AsNoTracking()
                .OrderBy(b => b.Id)
                .ToListAsync();
        }
        public async Task<IEnumerable<Break>> GetActiveBreaksByUserAsync(int userId)
        {
            return await _context.Breaks
                .Include(b => b.UserShift)
                    .ThenInclude(us => us.User)
                .Include(b => b.UserShift)
                    .ThenInclude(us => us.Schedule)
                .AsNoTracking()
                .Where(b => b.UserShift.UserId == userId && b.Status == BreakStatus.Taken)
                .OrderByDescending(b => b.StartTime)
                .ToListAsync();
        }
        public async Task<Break> GetActiveBreakByUserAsync(int userId)
        {
            return await _context.Breaks
                .Include(b => b.UserShift)
                .ThenInclude(us => us.User)
                .AsNoTracking()
                .Where(b => b.UserShift.UserId == userId && b.Status == BreakStatus.Taken)
                .FirstOrDefaultAsync();
        }
        public async Task<IEnumerable<Break>> GetActiveBreaksByScheduleAsync(int scheduleId)
        {
            return await _context.Breaks
                .Include(b => b.UserShift)
                    .ThenInclude(us => us.User)
                .Include(b => b.UserShift)
                    .ThenInclude(us => us.Schedule)
                .AsNoTracking()
                .Where(b => b.UserShift.ScheduleId == scheduleId && b.Status == BreakStatus.Taken)
                .OrderByDescending(b => b.StartTime)
                .ToListAsync();
        }
        public async Task<Break?> GetAvailableBreakAsync(int userShiftId)
        {
            return await _context.Breaks
                .Include(b => b.UserShift)
                    .ThenInclude(us => us.User)
                .Include(b => b.UserShift)
                    .ThenInclude(us => us.Schedule)
                .Where(b => b.UserShiftId == userShiftId && b.Status == BreakStatus.Available)
                .AsNoTracking()
                .FirstOrDefaultAsync();
        }
        public async Task<Break?> GetNextAvailableBreakByUserAsync(int userId)
        {
            return await _context.Breaks
                .Include(b => b.UserShift)
                .Where(b => b.UserShift.UserId == userId &&
                           b.Status == BreakStatus.Available)
                .OrderBy(b => b.BreakNumber)
                .FirstOrDefaultAsync();
        }


        public async Task<Break?> GetLastFinishedBreakByUserAsync(int userId)
        {
            return await _context.Breaks
                .Include(b => b.UserShift)
                    .ThenInclude(us => us.User)
                .Where(b => b.UserShift.UserId == userId && b.Status == BreakStatus.Finished && b.EndTime.HasValue)
                .OrderByDescending(b => b.EndTime)
                .AsNoTracking()
                .FirstOrDefaultAsync();
        }

        public async Task<Break?> GetLastBreakByUserAsync(int userId)
        {
            return await _context.Breaks
                .Include(b => b.UserShift)
                .Where(b => b.UserShift.UserId == userId)
                .OrderByDescending(b => b.BreakNumber)
                .AsNoTracking()
                .FirstOrDefaultAsync();
        }

        public async Task<IEnumerable<Break>> GetBreaksByDateAndGroupAsync(DateOnly workDate, ShiftType group)
        {
            return await _context.Breaks
                .Include(b => b.UserShift)
                    .ThenInclude(us => us.User)
                .Include(b => b.UserShift)
                    .ThenInclude(us => us.Schedule)
                .AsNoTracking()
                .Where(b => b.WorkDate == workDate && b.UserShift.Group == group)
                .OrderBy(b => b.BreakNumber)
                    .ThenBy(b => b.UserShift.User.UserName)
                .ToListAsync();
        }

        public async Task<Break> AddAsync(Break brk)
        {
            if (brk.UserShiftId <= 0)
                throw new ArgumentException("Поле с UserShiftId не может быть пустым");

            var userShift = await _context.UserShifts
                .Include(us => us.Breaks)
                .FirstOrDefaultAsync(us => us.Id == brk.UserShiftId);

            if (userShift == null)
                throw new ArgumentException($"UserShift с Id '{brk.UserShiftId}' не найден");

            if (userShift.Breaks.Any(b => b.Status == BreakStatus.Taken))
                throw new InvalidOperationException($"У пользователя уже есть активный перерыв");

            await _context.Breaks.AddAsync(brk);
            await _context.SaveChangesAsync();

            return brk;
        }

        public async Task<Break?> GetLastBreakByUserShiftAsync(int userShiftId)
        {
            return await _context.Breaks
                .Include(b => b.UserShift)
                .Where(b => b.UserShiftId == userShiftId)
                .OrderByDescending(b => b.BreakNumber)
                .AsNoTracking()
                .FirstOrDefaultAsync();
        }

        public async Task<Break?> GetActiveBreakByUserShiftAsync(int userShiftId)
        {
            return await _context.Breaks
                .Include(b => b.UserShift)
                    .ThenInclude(us => us.User)
                .AsNoTracking()
                .Where(b => b.UserShiftId == userShiftId && b.Status == BreakStatus.Taken)
                .FirstOrDefaultAsync();
        }

        public async Task UpdateAsync(Break brk)
        {
            var breakEntity = await _context.Breaks
                .Include(b => b.UserShift)
                .FirstOrDefaultAsync(b => b.Id == brk.Id);  // ← убрать AsNoTracking

            if (breakEntity == null)
                throw new InvalidOperationException($"Break с Id {brk.Id} не найден");

            if (brk.Status == BreakStatus.Taken && breakEntity.Status != BreakStatus.Taken)
            {
                var hasActiveBreak = await _context.Breaks
                    .AnyAsync(b => b.UserShift.UserId == breakEntity.UserShift.UserId
                                && b.Status == BreakStatus.Taken
                                && b.Id != brk.Id);
                if (hasActiveBreak)
                    throw new InvalidOperationException("Уже есть активный перерыв");
            }

            // Обновляем поля через уже отслеживаемую сущность — без context.Update()
            breakEntity.Status = brk.Status;
            breakEntity.EndTime = brk.EndTime;
            breakEntity.DurationMinutes = brk.DurationMinutes;
            breakEntity.BreakNumber = brk.BreakNumber;
            breakEntity.StartTime = brk.StartTime;
            breakEntity.WorkDate = brk.WorkDate;

            await _context.SaveChangesAsync();
        }



        public async Task DeleteAsync(int id)
        {
            var brk = await _context.Breaks
                .Include(b => b.UserShift)
                    .ThenInclude(us => us.User)
                .FirstOrDefaultAsync(b => b.Id == id);

            if (brk == null)
            {
                throw new InvalidOperationException($"Перерыв с данным Id - {id} не найден");
            }

            if (brk.Status == BreakStatus.Taken)
            {
                throw new InvalidOperationException($"Нельзя удалить активный перерыв");
            }

            _context.Breaks.Remove(brk);
            await _context.SaveChangesAsync();
        }
    }
}


--- C:\Users\boobi\source\workmain\src\SkntBreak.Infrastructure\Data\Repositories\ScheduleRepository.cs ---
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.EntityFrameworkCore;
using Skntbreak.Application.Interfaces;
using Skntbreak.Core.Dto.Schedules;
using Skntbreak.Core.Entities;
using Skntbreak.Core.Enums;

namespace SkntBreak.Infrastructure.Data.Repositories
{
    public class ScheduleRepository : IScheduleRepository
    {
        private readonly SkntbreakDbContext _context;

        public ScheduleRepository(SkntbreakDbContext context)
        {
            _context = context;
        }

        public async Task<Schedule?> GetByIdAsync(int id)
        {
            return await _context.Schedules
                .AsNoTracking()
                .FirstOrDefaultAsync(s => s.Id == id);
        }

        public async Task<IEnumerable<Schedule>> GetAllAsync()
        {
            return await _context.Schedules
                .AsNoTracking()
                .OrderBy(s => s.Name)
                .ToListAsync();
        }

        public async Task<Schedule?> GetWithRulesAsync(int id)
        {
            return await _context.Schedules
                .Include(s => s.BreakTemplates)
                .AsNoTracking()
                .FirstOrDefaultAsync(s => s.Id == id);
        }

        public async Task<Schedule?> GetWithUsersAsync(int id)
        {
            return await _context.Schedules
                .Include(s => s.UserShifts)
                    .ThenInclude(us => us.User)
                .AsNoTracking()
                .FirstOrDefaultAsync(s => s.Id == id);
        }

        public async Task<Schedule> AddAsync(Schedule schedule)
        {
            if (string.IsNullOrWhiteSpace(schedule.Name))
                throw new ArgumentException("Поле с именем не может быть пустым");

            await _context.Schedules.AddAsync(schedule);
            await _context.SaveChangesAsync();

            return schedule;
        }

        public async Task UpdateAsync(Schedule schedule)
        {
            var scheduleEntity = await _context.Schedules.FindAsync(schedule.Id);
            if (scheduleEntity == null)
            {
                throw new InvalidOperationException($"Расписание с Id - {schedule.Id} не найдено");
            }

            _context.Schedules.Update(schedule);
            await _context.SaveChangesAsync();
        }

        public async Task DeleteAsync(int id)
        {
            var schedule = await _context.Schedules
                .FirstOrDefaultAsync(u => u.Id == id);

            if (schedule == null)
            {
                throw new InvalidOperationException($"Расписание с данным Id - {id} не найден");
            }

            _context.Schedules.Remove(schedule);
            await _context.SaveChangesAsync();
        }
    }
}


--- C:\Users\boobi\source\workmain\src\SkntBreak.Infrastructure\Data\Repositories\ShiftBreakTemplateRepository.cs ---
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.EntityFrameworkCore;
using Skntbreak.Core.Entities;
using Skntbreak.Core.Interfaces;
using SkntBreak.Infrastructure.Data;

namespace SkntBreak.Infrastructure.Data.Repositories
{
    public class ShiftBreakTemplateRepository : IShiftBreakTemplateRepository
    {
        private readonly SkntbreakDbContext _context;

        public ShiftBreakTemplateRepository(SkntbreakDbContext context)
        {
            _context = context;
        }

        public async Task<ShiftBreakTemplate?> GetByIdAsync(int id)
        {
            return await _context.ShiftBreakTemplates
                .Include(sbt => sbt.Schedule)
                .AsNoTracking()
                .FirstOrDefaultAsync(sbt => sbt.Id == id);
        }
        
        public async Task<IEnumerable<ShiftBreakTemplate>> GetAllAsync()
        {
            return await _context.ShiftBreakTemplates
                .Include(sbt => sbt.Schedule)
                .AsNoTracking()
                .OrderBy(sbt => sbt.ScheduleId)
                .ThenBy(sbt => sbt.Order)
                .ToListAsync();
        }
        
        public async Task<IEnumerable<ShiftBreakTemplate>> GetByScheduleAsync(int scheduleId)
        {
            return await _context.ShiftBreakTemplates
                .Include(sbt => sbt.Schedule)
                .AsNoTracking()
                .Where(sbt => sbt.ScheduleId == scheduleId)
                .OrderBy(sbt => sbt.Order)
                .ToListAsync();
        }

        public async Task<ShiftBreakTemplate> AddAsync(ShiftBreakTemplate template)
        {
            if (template.ScheduleId <= 0)
                throw new ArgumentException("Поле с ScheduleId не может быть пустым");

            if (template.Order <= 0)
                throw new ArgumentException("Порядковый номер должен быть больше 0");

            // Проверяем, что нет дубликата по порядку в рамках расписания
            if (await _context.ShiftBreakTemplates.AnyAsync(sbt => sbt.ScheduleId == template.ScheduleId && sbt.Order == template.Order))
                throw new InvalidOperationException($"Шаблон перерыва с порядком '{template.Order}' для расписания с Id '{template.ScheduleId}' уже существует");

            await _context.ShiftBreakTemplates.AddAsync(template);
            await _context.SaveChangesAsync();

            return template;
        }

        public async Task UpdateAsync(ShiftBreakTemplate template)
        {
            var templateEntity = await _context.ShiftBreakTemplates.FindAsync(template.Id);
            if (templateEntity == null)
            {
                throw new InvalidOperationException($"Шаблон перерыва с Id - {template.Id} не найден");
            }

            // Проверяем дублирование по порядку если изменился порядок или расписание
            if (templateEntity.Order != template.Order || templateEntity.ScheduleId != template.ScheduleId)
            {
                if (await _context.ShiftBreakTemplates.AnyAsync(sbt => sbt.ScheduleId == template.ScheduleId && sbt.Order == template.Order && sbt.Id != template.Id))
                {
                    throw new InvalidOperationException($"Шаблон перерыва с порядком '{template.Order}' для расписания с Id '{template.ScheduleId}' уже существует");
                }
            }

            _context.ShiftBreakTemplates.Update(template);
            await _context.SaveChangesAsync();
        }

        public async Task DeleteAsync(int id)
        {
            var template = await _context.ShiftBreakTemplates
                .Include(sbt => sbt.Schedule)
                .FirstOrDefaultAsync(sbt => sbt.Id == id);

            if (template == null)
            {
                throw new InvalidOperationException($"Шаблон перерыва с данным Id - {id} не найден");
            }

            _context.ShiftBreakTemplates.Remove(template);
            await _context.SaveChangesAsync();
        }
    }
}


--- C:\Users\boobi\source\workmain\src\SkntBreak.Infrastructure\Data\Repositories\UserRepository.cs ---
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.EntityFrameworkCore;
using Skntbreak.Application.Interfaces;
using Skntbreak.Core.Entities;
using Skntbreak.Core.Enums;

namespace SkntBreak.Infrastructure.Data.Repositories
{
    public class UserRepository : IUserRepository
    {
        private readonly SkntbreakDbContext _context;

        public UserRepository(SkntbreakDbContext context)
        {
            _context = context;
        }

        public async Task<User?> GetByIdAsync(int id)
        {
            return await _context.Users
                .Include(u => u.UserShifts)
                    .ThenInclude(us => us.Schedule)
                .Include(u => u.BreakChats)
                .AsNoTracking()
                .FirstOrDefaultAsync(u => u.Id == id);
        }
        public async Task<IEnumerable<User>> GetAllAsync()
        {
            return await _context.Users
                .Include(u => u.UserShifts)
                    .ThenInclude(us => us.Schedule)
                .AsNoTracking()
                .OrderBy(u => u.UserName)
                .ToListAsync();
        }

        public async Task<User?> GetByLoginAsync(string login)
        {
            if (string.IsNullOrEmpty(login))
                throw new ArgumentException("Логин не может быть пустым");
            
            return await _context.Users
                .Include(u => u.UserShifts)
                    .ThenInclude(us => us.Schedule)
                .AsNoTracking()
                .FirstOrDefaultAsync(u => u.Login == login);
        }

        public async Task<IEnumerable<User>> GetByScheduleAsync(int scheduleId)
        {
            return await _context.Users
                .Include(u => u.UserShifts)
                    .ThenInclude(us => us.Schedule)
                .AsNoTracking()
                .Where(u => u.UserShifts.Any(us => us.ScheduleId == scheduleId))
                .ToListAsync();
        }

        public async Task<User> AddAsync(User user)
        {
            if (string.IsNullOrWhiteSpace(user.Login))
                throw new ArgumentException("Поле с логином не может быть пустым");

            if (await _context.Users.AnyAsync(u => u.Login == user.Login))
                throw new InvalidOperationException($"Пользователь с логином '{user.Login}' уже существует");

            await _context.Users.AddAsync(user);
            await _context.SaveChangesAsync();

            return user;
        }

        public async Task UpdateAsync(User user)
        {
            var userEntity = await _context.Users.FindAsync(user.Id);
            if (userEntity == null)
            {
                throw new InvalidOperationException($"Пользователь с Id - {user.Id} не найден");
            }

            if (userEntity.Login != user.Login)
            {
                if (await _context.Users.AnyAsync(u => u.Login == user.Login && u.Id != user.Id))
                {
                    throw new InvalidOperationException($"Пользователь с логином '{user.Login}' уже существует");
                }
            }

            _context.Users.Update(user);
            await _context.SaveChangesAsync();
        }

        public async Task DeleteAsync(int id)
        {
            var user = await _context.Users
                .Include(u => u.UserShifts)
                    .ThenInclude(us => us.Breaks)
                .FirstOrDefaultAsync(u => u.Id == id);

            if (user == null)
            {
                throw new InvalidOperationException($"Пользователь с данным Id - {id} не найден");
            }

            var activeBreak = user.UserShifts
                .SelectMany(us => us.Breaks)
                .FirstOrDefault(b => b.Status == BreakStatus.Taken);
            
            if (activeBreak != null)
            {
                throw new InvalidOperationException($"Нельзя удалить пользователя с активным перерывом");
            }

            _context.Users.Remove(user);
            await _context.SaveChangesAsync();
        }
        public async Task<IEnumerable<User>> GetAllWithShiftsAndBreaksAsync()
        {
            return await _context.Users
                .Include(u => u.UserShifts)
                .ThenInclude(s => s.Breaks)
                .ToListAsync();
        }
        public async Task<User?> GetByIdWithShiftsAndBreaksAsync(int userId)
        {
            return await _context.Users
                .Include(u => u.UserShifts)
                    .ThenInclude(s => s.Breaks)
                .FirstOrDefaultAsync(u => u.Id == userId);
        }
    }
}


--- C:\Users\boobi\source\workmain\src\SkntBreak.Infrastructure\Data\Repositories\UserShiftRepository.cs ---
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.EntityFrameworkCore;
using Skntbreak.Core.Entities;
using Skntbreak.Core.Enums;
using Skntbreak.Core.Interfaces;
using SkntBreak.Infrastructure.Data;

namespace SkntBreak.Infrastructure.Data.Repositories
{
    public class UserShiftRepository : IUserShiftRepository
    {
        private readonly SkntbreakDbContext _context;

        public UserShiftRepository(SkntbreakDbContext context)
        {
            _context = context;
        }

        public async Task<UserShift> AddAsync(UserShift userShift)
        {
            await _context.UserShifts.AddAsync(userShift);
            await _context.SaveChangesAsync();

            // РџРѕСЃР»Рµ СЃРѕР·РґР°РЅРёСЏ Р·Р°РіСЂСѓР¶Р°РµРј СЃРІСЏР·Р°РЅРЅС‹Рµ РґР°РЅРЅС‹Рµ
            return await _context.UserShifts
                .Include(us => us.User)
                .Include(us => us.Schedule)
                .Include(us => us.Breaks)
                .FirstOrDefaultAsync(us => us.Id == userShift.Id);
        }

        public async Task<UserShift?> GetByIdAsync(int id)
        {
            return await _context.UserShifts
                .Include(us => us.User)
                .Include(us => us.Schedule)
                .Include(us => us.Breaks)
                .FirstOrDefaultAsync(us => us.Id == id);
        }

        public async Task<UserShift?> GetByUserAndDateAsync(int userId, DateOnly workDate)
        {
            return await _context.UserShifts
                .Include(us => us.User)
                .Include(us => us.Schedule)
                .Include(us => us.Breaks)
                .FirstOrDefaultAsync(us => us.UserId == userId && us.WorkDate == workDate);
        }

        public async Task<IEnumerable<UserShift>> GetByScheduleAndDateAsync(int scheduleId, DateOnly date)
        {
            return await _context.UserShifts
                .Include(us => us.User)
                .Include(us => us.Schedule)
                .Include(us => us.Breaks)
                .Where(us => us.ScheduleId == scheduleId && us.WorkDate == date)
                .OrderBy(us => us.User.UserName)
                .ToListAsync();
        }


        public async Task<IEnumerable<UserShift>> GetByUserAsync(int userId)
        {
            return await _context.UserShifts
                .Include(us => us.User)
                .Include(us => us.Schedule)
                .Include(us => us.Breaks)
                .Where(us => us.UserId == userId)
                .OrderByDescending(us => us.WorkDate)
                .ToListAsync();
        }

        public async Task<IEnumerable<UserShift>> GetByScheduleAsync(int scheduleId)
        {
            return await _context.UserShifts
                .Include(us => us.User)
                .Include(us => us.Schedule)
                .Include(us => us.Breaks)
                .Where(us => us.ScheduleId == scheduleId)
                .OrderByDescending(us => us.WorkDate)
                .ToListAsync();
        }

        public async Task<IEnumerable<UserShift>> GetByDateAsync(DateOnly date)
        {
            return await _context.UserShifts
                .Include(us => us.User)
                .Include(us => us.Schedule)
                .Include(us => us.Breaks)
                .Where(us => us.WorkDate == date)
                .ToListAsync();
        }

        public async Task<UserShift?> GetActiveShiftAsync(int userId)
        {
            return await _context.UserShifts
                .Include(us => us.User)
                .Include(us => us.Schedule)
                .Include(us => us.Breaks)
                .Include(us => us.QueueEntries)
                .Where(us => us.UserId == userId && us.EndedAt == null)
                .OrderByDescending(us => us.StartedAt)
                .FirstOrDefaultAsync();
        }

        public async Task<IEnumerable<UserShift>> GetByDateAndGroupAsync(DateOnly date, ShiftType group)
        {
            return await _context.UserShifts
                .Include(us => us.User)
                .Include(us => us.Schedule)
                .Include(us => us.Breaks)
                .Where(us => us.WorkDate == date && us.Group == group)
                .ToListAsync();
        }

        public async Task<IEnumerable<UserShift>> GetAllAsync()
        {
            return await _context.UserShifts
                .Include(us => us.User)
                .Include(us => us.Schedule)
                .Include(us => us.Breaks)
                .OrderByDescending(us => us.WorkDate)
                .ToListAsync();
        }

        public async Task UpdateAsync(UserShift userShift)
        {
            _context.UserShifts.Update(userShift);
            await _context.SaveChangesAsync();
        }

        public async Task DeleteAsync(int id)
        {
            var userShift = await _context.UserShifts.FindAsync(id);
            if (userShift != null)
            {
                _context.UserShifts.Remove(userShift);
                await _context.SaveChangesAsync();
            }
        }
    }
}


--- C:\Users\boobi\source\workmain\src\SkntBreak.Infrastructure\Data\SkntbreakDbContext.cs ---
// SkntBreak.Infrastructure/Data/SkntbreakDbContext.cs

using Microsoft.EntityFrameworkCore;
using Skntbreak.Core.Entities;
using Skntbreak.Infrastructure.Data.Configurations;
using SkntBreak.Infrastructure.Data.Configurations;

namespace SkntBreak.Infrastructure.Data
{
    public class SkntbreakDbContext : DbContext
    {
        public SkntbreakDbContext(DbContextOptions<SkntbreakDbContext> options) : base(options) { }

        public DbSet<User> Users { get; set; }
        public DbSet<Schedule> Schedules { get; set; }
        public DbSet<ShiftBreakTemplate> ShiftBreakTemplates { get; set; }
        public DbSet<UserShift> UserShifts { get; set; }
        public DbSet<Break> Breaks { get; set; }
        public DbSet<BreakChat> BreakChats { get; set; }
        public DbSet<BreakPoolDay> BreakPoolDays { get; set; }
        public DbSet<BreakQueue> BreakQueues { get; set; }  // <<< ДОБАВЬ ЭТУ СТРОКУ

        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            base.OnModelCreating(modelBuilder);

            modelBuilder.ApplyConfiguration(new UserConfiguration());
            modelBuilder.ApplyConfiguration(new ScheduleConfiguration());
            modelBuilder.ApplyConfiguration(new ShiftBreakTemplateConfiguration());
            modelBuilder.ApplyConfiguration(new UserShiftConfiguration());
            modelBuilder.ApplyConfiguration(new BreakConfiguration());
            modelBuilder.ApplyConfiguration(new BreakChatConfiguration());
            modelBuilder.ApplyConfiguration(new BreakPoolDayConfiguration());
            modelBuilder.ApplyConfiguration(new BreakQueueConfiguration());  // <<< ДОБАВЬ ЭТУ СТРОКУ
        }
    }
}


--- C:\Users\boobi\source\workmain\src\SkntBreak.Infrastructure\Helpers\JwtOptions.cs ---
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Skntbreak.Infrastructure.Helpers
{
    public class JwtOptions
    {
        public string SecretKey { get; set; } = string.Empty;
        public int ExpiresHours { get; set; }
    }
}


--- C:\Users\boobi\source\workmain\src\SkntBreak.Infrastructure\Helpers\JwtProvider.cs ---
using System;
using System.Collections.Generic;
using System.IdentityModel.Tokens.Jwt;
using System.Linq;
using System.Security.Claims;
using System.Text;
using System.Threading.Tasks;
using Microsoft.Extensions.Options;
using Microsoft.IdentityModel.Tokens;
using Skntbreak.Core.Entities;
using Skntbreak.Core.Interfaces;
using System.Security.Claims;

namespace Skntbreak.Infrastructure.Helpers
{
    public class JwtProvider : IJwtProvider
    {
        private readonly JwtOptions _options;
        public JwtProvider(IOptions<JwtOptions> options)
        {
            _options = options.Value;
        }
        public string GenerateToken(User user)
        {
            var claims = new List<Claim>
            {
                new Claim("userId", user.Id.ToString()),
                new Claim(ClaimTypes.NameIdentifier, user.Id.ToString()),
                new Claim(ClaimTypes.Name, user.UserName),
                new Claim(ClaimTypes.Role, user.Role.ToString())
            };

            var signingCredentials = new SigningCredentials(
                new SymmetricSecurityKey(Encoding.UTF8.GetBytes(_options.SecretKey)),
                SecurityAlgorithms.HmacSha256);

            var token = new JwtSecurityToken(
                claims: claims,
                signingCredentials: signingCredentials,
                expires: DateTime.UtcNow.AddHours(_options.ExpiresHours)); 

            var tokenValue = new JwtSecurityTokenHandler().WriteToken(token);

            return tokenValue;
        }
    }
}


--- C:\Users\boobi\source\workmain\src\SkntBreak.Infrastructure\Helpers\PasswordHasher.cs ---
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Skntbreak.Core.Interfaces;

namespace Skntbreak.Infrastructure.Helpers
{
    public class PasswordHasher : IPasswordHasher
    {
        public string Generate(string password) =>
            BCrypt.Net.BCrypt.EnhancedHashPassword(password);

        public bool Verify(string password, string hashedPassword) =>
            BCrypt.Net.BCrypt.EnhancedVerify(password, hashedPassword);
    }
}
 

--- C:\Users\boobi\source\workmain\src\frontend\src\App.css ---
@import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');

:root {
    /* Цветовая палитра на основе макета */
    --bg-global: #FFFFFF;
    --bg-surface-main: #F8F9FB; /* Очень светлый серо-голубой для центральной панели */
    --bg-surface-side: #F4F5F7; /* Светло-серый для боковых панелей */

    --text-primary: #111827;
    --text-secondary: #6B7280;
    --status-green: #7CCC63; /* Зеленый "В линии" и часы */
    --status-red: #C13333; /* Красный "Перерыв" и кнопка "На месте" */

    --queue-alert-bg: #FFFBEB;
    --queue-alert-border: #FEF08A;
    --radius-large: 24px;
    --radius-medium: 16px;
    --radius-pill: 9999px;
    --font-family: 'Inter', system-ui, -apple-system, sans-serif;
}

body {
    margin: 0;
    padding: 0;
    background-color: var(--bg-global);
    color: var(--text-primary);
    font-family: var(--font-family);
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
}

/* Глобальный Layout приложения */
.app {
    min-height: 100vh;
    display: flex;
    flex-direction: column;
}

.app__main {
    flex: 1;
    display: flex;
    flex-direction: column;
}

.app__content {
    flex: 1;
    padding: 0 40px 40px 40px;
    max-width: 1440px;
    margin: 0 auto;
    width: 100%;
    box-sizing: border-box;
}

/* Верхний колонтитул (Хедер с часами) */
.header-container {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    padding: 40px 40px 20px 40px;
    max-width: 1440px;
    margin: 0 auto;
    width: 100%;
    box-sizing: border-box;
}

.header-clock-module {
    display: flex;
    flex-direction: column;
    gap: 4px;
}

.day-text {
    font-size: 32px;
    font-weight: 600;
    color: var(--text-primary);
    margin: 0;
    line-height: 1.2;
}

.time-text {
    font-size: 40px;
    font-weight: 500;
    color: var(--status-green);
    font-variant-numeric: tabular-nums;
    line-height: 1;
}

.header-profile {
    display: flex;
    align-items: center;
    gap: 16px;
}

.profile-info {
    display: flex;
    align-items: center;
    gap: 8px;
    font-weight: 600;
}

.profile-role {
    color: var(--status-green);
    font-size: 14px;
}

.profile-avatar {
    width: 48px;
    height: 48px;
    border-radius: 50%;
    background-color: var(--bg-surface-side);
    object-fit: cover;
}

.logout-btn {
    background: transparent;
    border: 1px solid var(--text-secondary);
    border-radius: var(--radius-pill);
    padding: 6px 16px;
    color: var(--text-secondary);
    cursor: pointer;
    font-weight: 500;
    transition: all 0.2s ease;
}

    .logout-btn:hover {
        background: var(--text-secondary);
        color: var(--bg-global);
    }

/* Сетка дашборда */
.dashboard-layout {
    display: grid;
    grid-template-columns: 1fr 340px; /* Левая часть тянется, правая фиксированная */
    gap: 40px;
    align-items: start;
}

/* Карточки и панели */
.panel-main {
    background-color: var(--bg-surface-main);
    border-radius: var(--radius-large);
    padding: 40px;
}

.panel-side {
    background-color: var(--bg-surface-side);
    border-radius: var(--radius-large);
    padding: 32px;
    margin-bottom: 24px;
}

/* Таблицы (без рамок, как на макете) */
.borderless-table {
    width: 100%;
    border-collapse: collapse;
}

    .borderless-table th {
        text-align: left;
        color: var(--text-primary);
        font-weight: 700;
        font-size: 16px;
        padding: 0 0 24px 0;
        border: none;
    }

    .borderless-table td {
        padding: 16px 0;
        font-size: 16px;
        color: var(--text-primary);
        border: none;
    }

.user-name-cell {
    display: flex;
    align-items: center;
    gap: 12px;
}

.user-icon {
    color: var(--text-secondary);
    font-size: 18px;
}

/* Типографика и утилиты */
.text-green {
    color: var(--status-green);
}

.text-red {
    color: var(--status-red);
}

.text-muted {
    color: var(--text-secondary);
}

.fw-bold {
    font-weight: 700;
}

.fw-medium {
    font-weight: 500;
}

.tabular-nums {
    font-variant-numeric: tabular-nums;
}

.mt-3 {
    margin-top: 16px;
}

.mt-4 {
    margin-top: 24px;
}

.mb-4 {
    margin-bottom: 24px;
}

.ml-2 {
    margin-left: 8px;
}

/* Боковая карточка "Смена" */
.shift-status-card {
    display: flex;
    flex-direction: column;
    align-items: center;
    text-align: center;
}

.shift-status-header {
    display: flex;
    justify-content: space-between;
    width: 100%;
    font-size: 16px;
    margin-bottom: 8px;
}

.shift-emoji {
    font-size: 72px;
    margin: 24px 0;
}

.shift-main-timer {
    font-size: 48px;
    font-weight: 600;
    margin-bottom: 24px;
    color: var(--text-primary);
    font-variant-numeric: tabular-nums;
    line-height: 1;
}

/* Кнопки */
.btn-solid-red {
    background-color: var(--status-red);
    color: white;
    border: none;
    border-radius: var(--radius-pill);
    padding: 16px 32px;
    font-weight: 600;
    font-size: 18px;
    width: 100%;
    cursor: pointer;
    transition: transform 0.1s ease, opacity 0.2s ease;
}

    .btn-solid-red:hover {
        opacity: 0.9;
        transform: translateY(-2px);
    }

.btn-solid-green {
    background-color: var(--status-green);
    color: white;
    border: none;
    border-radius: var(--radius-pill);
    padding: 12px 24px;
    font-weight: 600;
    font-size: 16px;
    cursor: pointer;
    transition: transform 0.1s ease, opacity 0.2s ease;
}

    .btn-solid-green:hover {
        opacity: 0.9;
        transform: translateY(-2px);
    }

.btn-outline-green {
    background-color: transparent;
    color: var(--status-green);
    border: 2px solid var(--status-green);
    border-radius: var(--radius-pill);
    padding: 14px 24px;
    font-weight: 600;
    font-size: 16px;
    width: 100%;
    cursor: pointer;
    transition: all 0.2s ease;
}

    .btn-outline-green:hover {
        background-color: var(--status-green);
        color: white;
    }

.btn-outline-secondary {
    background-color: transparent;
    color: var(--text-secondary);
    border: 1px solid #D1D5DB;
    border-radius: var(--radius-pill);
    padding: 12px 24px;
    font-weight: 600;
    font-size: 16px;
    cursor: pointer;
    transition: all 0.2s ease;
}

    .btn-outline-secondary:hover {
        background-color: #F3F4F6;
    }

/* Блок "Сегодня на смене" и Pill-бейджи */
.roles-title {
    font-size: 18px;
    font-weight: 700;
    margin: 0 0 24px 0;
}

.role-group {
    margin-bottom: 24px;
}

.role-label {
    font-size: 14px;
    color: var(--text-secondary);
    margin-bottom: 12px;
}

.role-items {
    display: flex;
    flex-direction: column;
    gap: 12px;
}

.role-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 14px;
}

.pill-badge-green {
    background-color: var(--status-green);
    color: white;
    padding: 4px 16px;
    border-radius: var(--radius-pill);
    font-weight: 600;
}

/* Стили Очереди */
.queue-alert-box {
    background-color: var(--queue-alert-bg);
    border: 1px solid var(--queue-alert-border);
    border-radius: var(--radius-medium);
    padding: 24px;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.queue-alert-info {
    display: flex;
    align-items: center;
    gap: 16px;
}

.queue-alert-icon {
    font-size: 24px;
}

.queue-alert-actions {
    display: flex;
    gap: 8px;
}

/* Формы и инпуты (для админки и логина) */
.clean-input {
    width: 100%;
    padding: 16px;
    border: 1px solid #E5E7EB;
    border-radius: 12px;
    font-size: 16px;
    outline: none;
    transition: border-color 0.2s ease;
    box-sizing: border-box;
}

    .clean-input:focus {
        border-color: var(--status-green);
    }

/* Вкладки для админки */
.tab-button {
    padding: 12px 24px;
    border-radius: var(--radius-pill);
    border: none;
    font-weight: 600;
    cursor: pointer;
    background: transparent;
    color: var(--text-secondary);
    transition: all 0.2s ease;
    font-size: 16px;
}

    .tab-button.active {
        background: var(--status-green);
        color: white;
    }

/* Страницы авторизации */
.auth-wrapper {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: calc(100vh - 150px);
}

.auth-card {
    background: var(--bg-surface-main);
    padding: 48px;
    border-radius: var(--radius-large);
    width: 100%;
    max-width: 450px;
    box-sizing: border-box;
}


--- C:\Users\boobi\source\workmain\src\frontend\src\App.tsx ---
import React from 'react';
import { BrowserRouter, Routes, Route, Navigate, Outlet } from 'react-router-dom';
import { Toaster } from 'react-hot-toast';

import { LoginPage } from './pages/LoginPage';
import { RegisterPage } from './pages/RegisterPage';
import { DashboardPage } from './pages/DashboardPage';
import { ProfilePage } from './pages/ProfilePage';
import { AdminPage } from './pages/AdminPage';
import { Header } from './components/Header';
import './App.css';

// Простая проверка наличия JWT токена в localStorage
const isAuthenticated = (): boolean => {
    return !!localStorage.getItem('token');
};

// Компонент-защитник маршрутов
const RequireAuth = () => {
    if (!isAuthenticated()) {
        return <Navigate to="/login" replace />;
    }
    return <Outlet />;
};

// Главная оболочка (Layout) приложения для авторизованных пользователей
const AppShell = () => {
    return (
        <div className="app">
            <div className="app__main">
                {/* Хедер с часами и профилем теперь заменяет боковое меню */}
                <Header />
                <main className="app__content">
                    <Outlet />
                </main>
            </div>
        </div>
    );
};

export default function App() {
    return (
        <>
            {/* Глобальная настройка уведомлений под новую светлую стилистику */}
            <Toaster
                position="top-right"
                toastOptions={{
                    style: {
                        borderRadius: '16px',
                        background: '#F8F9FB', // Подложка как у основных карточек
                        color: '#111827',
                        fontWeight: 500,
                        boxShadow: '0 4px 12px rgba(0,0,0,0.05)',
                        padding: '16px 24px',
                    },
                    success: {
                        iconTheme: {
                            primary: '#7CCC63',
                            secondary: '#FFFFFF',
                        },
                    },
                    error: {
                        iconTheme: {
                            primary: '#C13333',
                            secondary: '#FFFFFF',
                        },
                    },
                }}
            />

            <BrowserRouter>
                <Routes>
                    {/* Публичные маршруты аутентификации */}
                    <Route path="/login" element={<LoginPage />} />
                    <Route path="/register" element={<RegisterPage />} />

                    {/* Защищенные маршруты (доступны только после входа) */}
                    <Route element={<RequireAuth />}>
                        <Route element={<AppShell />}>
                            <Route path="/" element={<Navigate to="/dashboard" replace />} />
                            <Route path="/dashboard" element={<DashboardPage />} />
                            <Route path="/profile" element={<ProfilePage />} />
                            <Route path="/admin" element={<AdminPage />} />
                        </Route>
                    </Route>

                    {/* Перехват неизвестных URL-адресов */}
                    <Route path="*" element={<Navigate to="/" replace />} />
                </Routes>
            </BrowserRouter>
        </>
    );
}

--- C:\Users\boobi\source\workmain\src\frontend\src\index.css ---
:root {
    font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif;
    line-height: 1.6;
    font-weight: 400;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
}

* {
    box-sizing: border-box;
}

html, body {
    height: 100%;
}

body {
    margin: 0;
    min-width: 320px;
    background: #f5f5f5;
    color: #111827;
}

#root {
    min-height: 100%;
}


--- C:\Users\boobi\source\workmain\src\frontend\src\main.tsx ---
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import App from './App'

createRoot(document.getElementById('root') as HTMLElement).render(
    <StrictMode>
        <App />
    </StrictMode>,
)


--- C:\Users\boobi\source\workmain\src\frontend\src\api\client.ts ---
import axios, { AxiosInstance, AxiosError } from 'axios';

// Базовый URL API (замените на ваш продакшен URL при деплое)
const API_BASE_URL = import.meta.env.VITE_API_URL || 'https://localhost:7059/api';

const apiClient: AxiosInstance = axios.create({
    baseURL: API_BASE_URL,
    withCredentials: true,
    headers: {
        'Content-Type': 'application/json',
    },
});

// Перехватчик для добавления JWT токена во все запросы
apiClient.interceptors.request.use(
    (config) => {
        const token = localStorage.getItem('token');
        if (token) {
            config.headers.Authorization = `Bearer ${token}`;
        }
        return config;
    },
    (error) => Promise.reject(error)
);

// Перехватчик ответов для обработки просроченного токена (401)
apiClient.interceptors.response.use(
    (response) => response,
    (error: AxiosError) => {
        if (error.response?.status === 401) {
            localStorage.removeItem('token');
            window.location.href = '/login';
        }
        return Promise.reject(error);
    }
);

// Утилиты авторизации
export const setAuthToken = (token: string) => {
    apiClient.defaults.headers.common['Authorization'] = `Bearer ${token}`;
    localStorage.setItem('token', token);
};

export const clearAuth = () => {
    delete apiClient.defaults.headers.common['Authorization'];
    localStorage.removeItem('token');
};

// ========================================
// ПОЛНЫЙ КЛИЕНТ API
// ========================================
export const api = {
    // Авторизация и профиль (UsersController)
    Users: {
        login: (login: string, password: string) =>
            apiClient.post('/Users/login', { login, password }),

        register: (userName: string, login: string, password: string) =>
            apiClient.post('/Users/register', { userName, login, password }),

        getProfile: () =>
            apiClient.get('/Users/profile'),

        updateProfile: (data: { userName?: string }) =>
            apiClient.put('/Users/profile', data),
    },

    // Управление сменами (UserShiftsController)
    Shifts: {
        getAvailableSchedules: () =>
            apiClient.get('/UserShifts/available'),

        startShift: (data: { scheduleId: number }) =>
            apiClient.post('/UserShifts/start', data),

        endShift: () =>
            apiClient.post('/UserShifts/end'),

        getMyShifts: () =>
            apiClient.get('/UserShifts/my'),

        getMyShift: (date: string) =>
            apiClient.get(`/UserShifts/my/${date}`),

        deleteShift: (id: number) =>
            apiClient.delete(`/UserShifts/${id}`),

        getColleagues: (scheduleId: number, workDate: string) =>
            apiClient.get('/UserShifts/colleagues', { params: { scheduleId, workDate } }),

        getShiftsByDateAndGroup: (workDate: string, group: string) =>
            apiClient.get(`/UserShifts/by-date-group/${workDate}/${group}`)
    },

    // Расписания (ScheduleController)
    Schedules: {
        getAllSchedules: () =>
            apiClient.get('/Schedule/getall'),

        getSchedule: (id: number) =>
            apiClient.get(`/Schedule/${id}`),

        createSchedule: (data: { name: string; startTime: string; endTime: string; shiftType?: number; }) =>
            apiClient.post('/Schedule/create', data),

        updateSchedule: (id: number, data: { name?: string; startTime?: string; endTime?: string; shiftType?: number; }) =>
            apiClient.put(`/Schedule/update/${id}`, data),

        deleteSchedule: (id: number) =>
            apiClient.delete(`/Schedule/${id}`),
    },

    // Очередь (BreakQueueController)
    Queue: {
        enqueue: (durationMinutes?: number) =>
            apiClient.post('/BreakQueue/enqueue', { durationMinutes }),

        getState: () =>
            apiClient.get('/BreakQueue/state'),

        confirm: (queueEntryId: number) =>
            apiClient.post(`/BreakQueue/confirm/${queueEntryId}`),

        postpone: (queueEntryId: number) =>
            apiClient.post(`/BreakQueue/postpone/${queueEntryId}`),

        skipRound: () =>
            apiClient.post('/BreakQueue/skip-round'),

        priorityBreak: (targetUserId: number, durationMinutes?: number) =>
            apiClient.post(`/BreakQueue/priority/${targetUserId}`, { durationMinutes }),
    },

    // Перерывы (BreaksController)
    Breaks: {
        startBreak: (data: { breakNumber: number; durationMinutes: number }) =>
            apiClient.post('/Breaks/start', data),

        endBreak: (breakId: number) =>
            apiClient.post(`/Breaks/end/${breakId}`),

        skipBreak: (data: { breakNumber: number; durationMinutes: number }) =>
            apiClient.post('/Breaks/skip', data),

        getMyActiveBreak: () =>
            apiClient.get('/Breaks/my-active'),

        getActiveBreaksInShift: (date: string) =>
            apiClient.get(`/Breaks/active-in-shift?date=${date}`),

        getMyHistory: (date: string) =>
            apiClient.get(`/Breaks/my-history?date=${date}`),

        getBreakPoolInfo: (date: string) =>
            apiClient.get(`/Breaks/pool-info?date=${date}`),
    },

    // Административная панель (AdminController)
    Admin: {
        getDashboardStats: () =>
            apiClient.get('/Admin/stats'),

        getTodayShifts: () =>
            apiClient.get('/Admin/shifts/today'),

        getAllUsers: () =>
            apiClient.get('/Admin/users'),

        getUserById: (id: number) =>
            apiClient.get(`/Admin/users/${id}`),

        createUser: (data: { userName: string; login: string; password: string; role: string; }) =>
            apiClient.post('/Admin/users', data),

        updateUser: (id: number, data: { userName?: string; login?: string; password?: string; role?: string; }) =>
            apiClient.put(`/Admin/users/${id}`, data),

        deleteUser: (id: number) =>
            apiClient.delete(`/Admin/users/${id}`),

        getAllBreakPools: () =>
            apiClient.get('/Admin/break-pools'),

        createBreakPool: (data: { workDate: string; group: number; maxCurrentBreaks: number; }) =>
            apiClient.post('/Admin/break-pools', data),

        getBreakPool: (date: string, shift: number) =>
            apiClient.get(`/Admin/break-pools/${date}/${shift}`),

        endUserShift: (userShiftId: number) =>
            apiClient.post(`/Admin/shifts/${userShiftId}/end`),
    },
};

--- C:\Users\boobi\source\workmain\src\frontend\src\assets\react.svg ---
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="35.93" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 228"><path fill="#00D8FF" d="M210.483 73.824a171.49 171.49 0 0 0-8.24-2.597c.465-1.9.893-3.777 1.273-5.621c6.238-30.281 2.16-54.676-11.769-62.708c-13.355-7.7-35.196.329-57.254 19.526a171.23 171.23 0 0 0-6.375 5.848a155.866 155.866 0 0 0-4.241-3.917C100.759 3.829 77.587-4.822 63.673 3.233C50.33 10.957 46.379 33.89 51.995 62.588a170.974 170.974 0 0 0 1.892 8.48c-3.28.932-6.445 1.924-9.474 2.98C17.309 83.498 0 98.307 0 113.668c0 15.865 18.582 31.778 46.812 41.427a145.52 145.52 0 0 0 6.921 2.165a167.467 167.467 0 0 0-2.01 9.138c-5.354 28.2-1.173 50.591 12.134 58.266c13.744 7.926 36.812-.22 59.273-19.855a145.567 145.567 0 0 0 5.342-4.923a168.064 168.064 0 0 0 6.92 6.314c21.758 18.722 43.246 26.282 56.54 18.586c13.731-7.949 18.194-32.003 12.4-61.268a145.016 145.016 0 0 0-1.535-6.842c1.62-.48 3.21-.974 4.76-1.488c29.348-9.723 48.443-25.443 48.443-41.52c0-15.417-17.868-30.326-45.517-39.844Zm-6.365 70.984c-1.4.463-2.836.91-4.3 1.345c-3.24-10.257-7.612-21.163-12.963-32.432c5.106-11 9.31-21.767 12.459-31.957c2.619.758 5.16 1.557 7.61 2.4c23.69 8.156 38.14 20.213 38.14 29.504c0 9.896-15.606 22.743-40.946 31.14Zm-10.514 20.834c2.562 12.94 2.927 24.64 1.23 33.787c-1.524 8.219-4.59 13.698-8.382 15.893c-8.067 4.67-25.32-1.4-43.927-17.412a156.726 156.726 0 0 1-6.437-5.87c7.214-7.889 14.423-17.06 21.459-27.246c12.376-1.098 24.068-2.894 34.671-5.345a134.17 134.17 0 0 1 1.386 6.193ZM87.276 214.515c-7.882 2.783-14.16 2.863-17.955.675c-8.075-4.657-11.432-22.636-6.853-46.752a156.923 156.923 0 0 1 1.869-8.499c10.486 2.32 22.093 3.988 34.498 4.994c7.084 9.967 14.501 19.128 21.976 27.15a134.668 134.668 0 0 1-4.877 4.492c-9.933 8.682-19.886 14.842-28.658 17.94ZM50.35 144.747c-12.483-4.267-22.792-9.812-29.858-15.863c-6.35-5.437-9.555-10.836-9.555-15.216c0-9.322 13.897-21.212 37.076-29.293c2.813-.98 5.757-1.905 8.812-2.773c3.204 10.42 7.406 21.315 12.477 32.332c-5.137 11.18-9.399 22.249-12.634 32.792a134.718 134.718 0 0 1-6.318-1.979Zm12.378-84.26c-4.811-24.587-1.616-43.134 6.425-47.789c8.564-4.958 27.502 2.111 47.463 19.835a144.318 144.318 0 0 1 3.841 3.545c-7.438 7.987-14.787 17.08-21.808 26.988c-12.04 1.116-23.565 2.908-34.161 5.309a160.342 160.342 0 0 1-1.76-7.887Zm110.427 27.268a347.8 347.8 0 0 0-7.785-12.803c8.168 1.033 15.994 2.404 23.343 4.08c-2.206 7.072-4.956 14.465-8.193 22.045a381.151 381.151 0 0 0-7.365-13.322Zm-45.032-43.861c5.044 5.465 10.096 11.566 15.065 18.186a322.04 322.04 0 0 0-30.257-.006c4.974-6.559 10.069-12.652 15.192-18.18ZM82.802 87.83a323.167 323.167 0 0 0-7.227 13.238c-3.184-7.553-5.909-14.98-8.134-22.152c7.304-1.634 15.093-2.97 23.209-3.984a321.524 321.524 0 0 0-7.848 12.897Zm8.081 65.352c-8.385-.936-16.291-2.203-23.593-3.793c2.26-7.3 5.045-14.885 8.298-22.6a321.187 321.187 0 0 0 7.257 13.246c2.594 4.48 5.28 8.868 8.038 13.147Zm37.542 31.03c-5.184-5.592-10.354-11.779-15.403-18.433c4.902.192 9.899.29 14.978.29c5.218 0 10.376-.117 15.453-.343c-4.985 6.774-10.018 12.97-15.028 18.486Zm52.198-57.817c3.422 7.8 6.306 15.345 8.596 22.52c-7.422 1.694-15.436 3.058-23.88 4.071a382.417 382.417 0 0 0 7.859-13.026a347.403 347.403 0 0 0 7.425-13.565Zm-16.898 8.101a358.557 358.557 0 0 1-12.281 19.815a329.4 329.4 0 0 1-23.444.823c-7.967 0-15.716-.248-23.178-.732a310.202 310.202 0 0 1-12.513-19.846h.001a307.41 307.41 0 0 1-10.923-20.627a310.278 310.278 0 0 1 10.89-20.637l-.001.001a307.318 307.318 0 0 1 12.413-19.761c7.613-.576 15.42-.876 23.31-.876H128c7.926 0 15.743.303 23.354.883a329.357 329.357 0 0 1 12.335 19.695a358.489 358.489 0 0 1 11.036 20.54a329.472 329.472 0 0 1-11 20.722Zm22.56-122.124c8.572 4.944 11.906 24.881 6.52 51.026c-.344 1.668-.73 3.367-1.15 5.09c-10.622-2.452-22.155-4.275-34.23-5.408c-7.034-10.017-14.323-19.124-21.64-27.008a160.789 160.789 0 0 1 5.888-5.4c18.9-16.447 36.564-22.941 44.612-18.3ZM128 90.808c12.625 0 22.86 10.235 22.86 22.86s-10.235 22.86-22.86 22.86s-22.86-10.235-22.86-22.86s10.235-22.86 22.86-22.86Z"></path></svg>

--- C:\Users\boobi\source\workmain\src\frontend\src\components\ActiveBreaksList.tsx ---
import React, { useState, useEffect } from 'react';
import { api } from '../api/client';

interface ActiveBreak {
    id: number;
    userId: number;
    userName: string;
    breakNumber: number;
    durationMinutes: number;
    startTime: string;
    isOverdue: boolean;
}

export const ActiveBreaksList: React.FC = () => {
    const [breaks, setBreaks] = useState<ActiveBreak[]>([]);
    const [loading, setLoading] = useState(true);

    useEffect(() => {
        loadActiveBreaks();
        const interval = setInterval(loadActiveBreaks, 15000); // Обновляем каждые 15 сек
        return () => clearInterval(interval);
    }, []);

    const loadActiveBreaks = async () => {
        try {
            const today = new Date().toISOString().split('T')[0];
            const response = await api.Breaks.getActiveBreaksInShift(today);
            setBreaks(response.data);
        } catch (err) {
            console.error('Error loading active breaks:', err);
        } finally {
            setLoading(false);
        }
    };

    const getElapsedMinutes = (startTime: string) => {
        const now = new Date().getTime();
        const start = new Date(startTime).getTime();
        return Math.floor((now - start) / 60000);
    };

    if (loading) {
        return <div className="card"><p>Загрузка...</p></div>;
    }

    return (
        <div className="card">
            <h3>Активные перерывы в смене ({breaks.length})</h3>
            {breaks.length === 0 ? (
                <p style={{ color: '#9ca3af', textAlign: 'center', padding: '1rem' }}>
                    Никто сейчас не на перерыве
                </p>
            ) : (
                <div style={{ display: 'grid', gap: '0.5rem' }}>
                    {breaks.map((brk) => {
                        const elapsed = getElapsedMinutes(brk.startTime);
                        const remaining = Math.max(0, brk.durationMinutes - elapsed);
                        const isOverdue = remaining === 0;

                        return (
                            <div
                                key={brk.id}
                                style={{
                                    padding: '12px',
                                    border: `1px solid ${isOverdue ? '#fecaca' : '#d1fae5'}`,
                                    borderRadius: '8px',
                                    backgroundColor: isOverdue ? '#fef2f2' : '#f0fdf4',
                                    display: 'flex',
                                    justifyContent: 'space-between',
                                    alignItems: 'center',
                                }}
                            >
                                <div>
                                    <strong>{brk.userName}</strong>
                                    <div style={{ fontSize: '0.875rem', color: '#6b7280' }}>
                                        Перерыв #{brk.breakNumber} • {brk.durationMinutes} мин
                                    </div>
                                </div>
                                <div style={{ textAlign: 'right' }}>
                                    <div style={{
                                        fontSize: '1.25rem',
                                        fontWeight: 'bold',
                                        color: isOverdue ? '#dc2626' : '#16a34a'
                                    }}>
                                        {isOverdue ? '⚠️ Просрочен' : `${remaining} мин`}
                                    </div>
                                    <div style={{ fontSize: '0.75rem', color: '#9ca3af' }}>
                                        {new Date(brk.startTime).toLocaleTimeString('ru-RU')}
                                    </div>
                                </div>
                            </div>
                        );
                    })}
                </div>
            )}
        </div>
    );
};


--- C:\Users\boobi\source\workmain\src\frontend\src\components\BreakPanel.tsx ---
import React, { useState, useEffect } from 'react';
import { api } from '../api/client';
import toast from 'react-hot-toast';

interface ActiveBreak {
    id: number;
    breakNumber: number;
    durationMinutes: number;
    startTime: string;
    expectedEndTime: string;
    elapsedTime: string;
    remainingTime: string;
    isOverdue: boolean;
}

interface BreakPanelProps {
    onBreakEnded?: () => void;
}

export const BreakPanel: React.FC<BreakPanelProps> = ({ onBreakEnded }) => {
    const = useState<ActiveBreak | null>(null);
    const [loading, setLoading] = useState(false);
    const = useState(0);
    const [elapsedMinutes, setElapsedMinutes] = useState(0);

    useEffect(() => {
        loadActiveBreak();
        const interval = setInterval(loadActiveBreak, 10000); 
        return () => clearInterval(interval);
    },);

    // Исключительно презентационный таймер без вызовов API
    useEffect(() => {
        if (!activeBreak) return;

        const interval = setInterval(() => {
            const now = new Date().getTime();
            const start = new Date(activeBreak.startTime).getTime();
            const elapsed = Math.floor((now - start) / 60000);
            const remaining = activeBreak.durationMinutes - elapsed;

            setElapsedMinutes(elapsed);
            setRemainingMinutes(remaining); // Позволяем уходить в минус для отображения просрочки
        }, 1000);

        return () => clearInterval(interval);
    },);

    const loadActiveBreak = async () => {
        try {
            const response = await api.Breaks.getMyActiveBreak();
            if (response.data.hasActiveBreak) {
                setActiveBreak(response.data.breakData);
            } else {
                setActiveBreak(null);
            }
        } catch (err) {
            console.error('Error loading active break:', err);
        }
    };

    const handleEndBreak = async () => {
        if (!activeBreak) return;
        if (window.confirm('Завершить перерыв?')) {
            try {
                setLoading(true);
                await api.Breaks.endBreak(activeBreak.id);
                toast.success('Перерыв завершён!');
                setActiveBreak(null);
                onBreakEnded?.();
            } catch (err: any) {
                toast.error(err.response?.data?.error |

| 'Ошибка завершения перерыва');
            } finally {
                setLoading(false);
            }
        }
    };

    if (activeBreak) {
        const isOverdue = remainingMinutes < 0;
        return (
            <div className="card" style={{
                border: isOverdue? '2px solid #ef4444' : '2px solid #10b981',
                backgroundColor: isOverdue? '#fee' : '#f0fdf4'
            }}>
                <h3 style={{ color: isOverdue? '#dc2626' : '#16a34a' }}>
                    {isOverdue? '⚠️ Перерыв просрочен!' : '☕ Вы на перерыве'}
                </h3>
                <div style={{ marginBottom: '1rem' }}>
                    <p><strong>Перерыв #{activeBreak.breakNumber}</strong></p>
                    <p><strong>Длительность:</strong> {activeBreak.durationMinutes} минут</p>
                    <p><strong>Начало:</strong> {new Date(activeBreak.startTime).toLocaleTimeString('ru-RU')}</p>
                    <p><strong>Прошло:</strong> {elapsedMinutes} мин</p>
                    <p style={{
                        fontSize: '1.5rem',
                        fontWeight: 'bold',
                        color: isOverdue? '#dc2626' : '#16a34a'
                    }}>
                        {isOverdue? `Просрочено на ${Math.abs(remainingMinutes)} мин` : `Осталось: ${remainingMinutes} мин`}
                    </p>
                </div>
                <button
                    className="btn btn-primary"
                    onClick={handleEndBreak}
                    disabled={loading}
                >
                    Завершить перерыв
                </button>
            </div>
        );
    }

    return (
        <div className="card">
            <h3>Перерыв</h3>
            <p style={{ marginBottom: '1rem' }}>У вас нет активного перерыва</p>
            <p style={{ color: '#6b7280', fontSize: '0.85rem' }}>Для начала отдыха встаньте в очередь.</p>
        </div>
    );
};

--- C:\Users\boobi\source\workmain\src\frontend\src\components\BreakQueue.tsx ---
import React, { useState, useEffect, useRef, useCallback } from "react";
import { api } from "../api/client";
import { startConnection } from "../services/signalRService";
import toast from "react-hot-toast";

interface QueueEntry {
    id: number;
    userId: number;
    userName: string;
    position: number;
    durationMinutes: number;
    status:
    | "Waiting"
    | "Notified"
    | "Confirmed"
    | "Postponed"
    | "Expired"
    | "Cancelled";
    isPriority: boolean;
    enqueuedAt: string;
    notifiedAt: string | null;
}

interface QueueState {
    currentRound: number;
    isRoundComplete: boolean;
    queue: QueueEntry[]; // ✅ массив
    availableSlots: number;
    activeBreaks: number;
    allowDurationChoice: boolean;
    remaining10Min: number | null;
    remaining20Min: number | null;
    myEntry: QueueEntry | null;
}

interface BreakQueueProps {
    activeBreak: any;
    onBreakStateChange: () => void;
}

export const BreakQueue: React.FC<BreakQueueProps> = ({
    activeBreak,
    onBreakStateChange,
}) => {
    const [state, setState] = useState<QueueState | null>(null); // ✅
    const [loading, setLoading] = useState(true);
    const [actionLoading, setActionLoading] = useState(false);
    const [notificationCountdown, setNotificationCountdown] = useState<number>(0);
    const countdownRef = useRef<ReturnType<typeof setInterval>>();

    const loadState = useCallback(async () => {
        try {
            const response = await api.Queue.getState();
            setState(response.data);
        } catch (err) {
            console.error("Ошибка загрузки состояния очереди:", err);
        } finally {
            setLoading(false);
        }
    }, []); // ✅

    useEffect(() => {
        let mounted = true;

        const setupSignalR = async () => {
            try {
                const conn = await startConnection();

                conn.on(
                    "QueueUpdated",
                    (
                        queue: QueueEntry[],
                        availableSlots: number,
                        currentRound: number,
                    ) => {
                        if (!mounted) return;
                        setState((prev) =>
                            prev ? { ...prev, queue, availableSlots, currentRound } : prev,
                        );
                    },
                );

                conn.on(
                    "YourTurn",
                    (
                        queueEntryId: number,
                        durationMinutes: number,
                        timeoutSeconds: number,
                    ) => {
                        if (!mounted) return;
                        setNotificationCountdown(timeoutSeconds);
                        loadState();
                    },
                );

                conn.on(
                    "NotificationExpired",
                    (queueEntryId: number, newPosition: number) => {
                        if (!mounted) return;
                        setNotificationCountdown(0);
                        loadState();
                    },
                );

                conn.on("BreakEnded", () => {
                    if (!mounted) return;
                    loadState();
                });
            } catch (err) {
                console.error("Ошибка настройки SignalR в очереди:", err);
            }
        };

        setupSignalR();
        loadState();

        return () => {
            mounted = false;
        };
    }, [loadState]); // ✅

    useEffect(() => {
        if (notificationCountdown > 0) {
            countdownRef.current = setInterval(() => {
                setNotificationCountdown((prev) => {
                    if (prev <= 1) {
                        clearInterval(countdownRef.current);
                        loadState();
                        return 0;
                    }
                    return prev - 1;
                });
            }, 1000);

            return () => clearInterval(countdownRef.current);
        }
    }, [notificationCountdown, loadState]); // ✅

    const handleEnqueue = async () => {
        setActionLoading(true);
        try {
            await api.Queue.enqueue();
            toast.success("Вы успешно встали в очередь");
            await loadState();
        } catch (err: any) {
            toast.error(err.response?.data?.error || "Ошибка постановки в очередь"); // ✅
        } finally {
            setActionLoading(false);
        }
    };

    const handleConfirm = async () => {
        if (!state?.myEntry) return;
        setActionLoading(true);
        try {
            await api.Queue.confirm(state.myEntry.id);
            setNotificationCountdown(0);
            await loadState();
            onBreakStateChange();
        } catch (err: any) {
            toast.error(err.response?.data?.error || "Ошибка подтверждения"); // ✅
        } finally {
            setActionLoading(false);
        }
    };

    const handlePostpone = async () => {
        if (!state?.myEntry) return;
        setActionLoading(true);
        try {
            await api.Queue.postpone(state.myEntry.id);
            setNotificationCountdown(0);
            await loadState();
        } catch (err: any) {
            toast.error(err.response?.data?.error || "Ошибка"); // ✅
        } finally {
            setActionLoading(false);
        }
    };

    if (loading || !state) return null;

    const isInQueue =
        state.myEntry &&
        (state.myEntry.status === "Waiting" || state.myEntry.status === "Notified"); // ✅
    const isNotified = state.myEntry?.status === "Notified";
    const visibleQueue = state.queue.filter(
        (q) => q.status === "Waiting" || q.status === "Notified", // ✅
    );

    return (
        <div className= "panel-main mt-4" >
        <div
        style={
        {
            display: "flex",
                justifyContent: "space-between",
                    alignItems: "center",
                        marginBottom: "24px",
        }
    }
      >
        <h3 style={ { margin: 0, fontSize: "20px", fontWeight: 700 } }>
            { " "}
          Очередь на перерыв{ " " }
    </h3>
        < span className = "text-muted fw-medium" >
            { " "}
          Свободно мест: { state.availableSlots } { " " }
    </span>
        </div>

    {
        isNotified && (
            <div className="queue-alert-box mb-4" >
                <div className="queue-alert-info" >
                    <span className="queue-alert-icon" >🔔</span>
                        < div >
                        <div
                className="fw-bold"
        style = {{ fontSize: "18px", color: "#111827" }
    }
              >
        Ваша очередь!
            </div>
            < div
    className = "text-red fw-bold tabular-nums"
    style = {{ marginTop: "4px" }
}
              >
    Подтвердите в течение { notificationCountdown } сек.
              </div>
        </div>
        </div>
        < div className = "queue-alert-actions" >
            <button
              className="btn-solid-green"
onClick = { handleConfirm }
disabled = { actionLoading }
    >
    Иду на перерыв
        </button>
        < button
className = "btn-outline-secondary"
onClick = { handlePostpone }
disabled = { actionLoading }
    >
    Позже
    </button>
    </div>
    </div>
      )}

<table className="borderless-table" >
    <thead>
    <tr>
    <th style={ { width: "80px" } }> Позиция </th>
        < th > Имя </th>
        < th > Длительность </th>
        </tr>
        </thead>
        <tbody>
{
    visibleQueue.map((entry) => {
        const isMe = entry.id === state.myEntry?.id;
        return (
            <tr key= { entry.id } >
            <td className="text-muted tabular-nums fw-bold" >
                  #{ entry.position } { " " }
        </td>
            < td >
            <div className="user-name-cell" >
                {!isMe && <span className="user-icon" >👤</span>
    }
                    <span
                      className={ isMe? "fw-bold": "fw-medium" }
                      style = {{ color: "#111827" }}
                    >
    { isMe? `(Вы) ${entry.userName}` : entry.userName}
{
    entry.isPriority && (
        <span
                          title="Приоритет"
    style = {{ marginLeft: "8px", fontSize: "14px" }
}
                        >
                          ⭐
</span>
                      )}
</span>
    </div>
    </td>
    < td className = "text-muted fw-medium tabular-nums" >
        { " "}
{ entry.durationMinutes } мин{ " " }
</td>
    </tr>
            );
          })}
{
    visibleQueue.length === 0 && (
        <tr>
        <td
                colSpan={ 3 }
    style = {{
        padding: "24px 0",
            textAlign: "center",
                color: "#9CA3AF",
                }
}
              >
    Очередь пуста
        </td>
        </tr>
          )}
</tbody>
    </table>

{
    !isInQueue && !activeBreak && (
        <div style={ { marginTop: "32px" } }>
            <button
            className="btn-outline-green"
    onClick = { handleEnqueue }
    disabled = { actionLoading }
        >
        { actionLoading? "Загрузка...": "Встать в очередь" }
        </button>
        </div>
      )
}

{
    isInQueue && !isNotified && (
        <div
          className="text-green fw-medium mt-4"
    style = {{
        textAlign: "center",
            backgroundColor: "#F0FDF4",
                padding: "16px",
                    borderRadius: "16px",
          }
}
        >
    Вы находитесь в очереди.Ваша позиция: #{ state.myEntry?.position }
</div>
      )}
</div>
  );
};


--- C:\Users\boobi\source\workmain\src\frontend\src\components\Header.tsx ---
import React, { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import { authService } from '../services/authService';
import { api } from '../api/client';

export const Header: React.FC = () => {
    const navigate = useNavigate();
    const [time, setTime] = useState(new Date()); // вњ…
    const [profile, setProfile] = useState<{ userName: string, role: string } | null>(null);

    useEffect(() => {
        const timer = setInterval(() => setTime(new Date()), 1000);
        return () => clearInterval(timer);
    }, []); // вњ…

    useEffect(() => {
        api.Users.getProfile()
            .then(res => setProfile(res.data))
            .catch(() => console.error("РќРµ СѓРґР°Р»РѕСЃСЊ Р·Р°РіСЂСѓР·РёС‚СЊ РїСЂРѕС„РёР»СЊ"));
    }, []); // вњ…

    const days = ['Р’РѕСЃРєСЂРµСЃРµРЅСЊРµ', 'РџРѕРЅРµРґРµР»СЊРЅРёРє', 'Р’С‚РѕСЂРЅРёРє', 'РЎСЂРµРґР°', 'Р§РµС‚РІРµСЂРі', 'РџСЏС‚РЅРёС†Р°', 'РЎСѓР±Р±РѕС‚Р°'];
    const dayName = days[time.getDay()]; // вњ…

    const formatTime = (date: Date) => {
        return date.toLocaleTimeString('ru-RU', { hour: '2-digit', minute: '2-digit' });
    };

    return (
        <div className="header-container">
            <div className="header-clock-module">
                <h1 className="day-text">{dayName}</h1>
                <div className="time-text">{formatTime(time)}</div>
            </div>
            <div className="header-profile">
                <div className="profile-info">
                    <span style={{ color: '#111827', fontSize: '16px' }}>
                        {profile?.userName || 'Р—Р°РіСЂСѓР·РєР°...'}
                    </span>
                    <span className="profile-role">
                        {profile?.role === 'SL2' ? 'SL2' : profile?.role || ''}
                    </span>
                </div>
                <img
                    className="profile-avatar"
                    src={`https://api.dicebear.com/7.x/avataaars/svg?seed=${profile?.userName || 'User'}&backgroundColor=F4F5F7`}
                    alt="avatar"
                />
                <button
                    className="logout-btn"
                    onClick={() => {
                        authService.logout();
                        navigate('/login');
                    }}
                >
                    Р’С‹С…РѕРґ
                </button>
            </div>
        </div>
    );
};


--- C:\Users\boobi\source\workmain\src\frontend\src\components\Sidebar.tsx ---
import React from 'react';
import { useNavigate, useLocation } from 'react-router-dom';

interface NavItem {
    label: string;
    path: string;
    icon: string;
}

const navItems: NavItem[] = [
    { label: 'Р”Р°С€Р±РѕСЂРґ', path: '/dashboard', icon: 'рџ“Љ' },
    { label: 'РџРµСЂРµСЂС‹РІС‹', path: '/breaks', icon: 'в•' },
    { label: 'Р Р°СЃРїРёСЃР°РЅРёРµ', path: '/schedule', icon: 'рџ“…' },
    { label: 'РџСЂРѕС„РёР»СЊ', path: '/profile', icon: 'рџ‘¤' },
];

export const Sidebar: React.FC = () => {
    const navigate = useNavigate();
    const location = useLocation();

    return (
        <div className="sidebar">
            <div className="nav-logo">рџ“‹ Skntbreak</div>
            <nav className="nav-items">
                {navItems.map((item) => (
                    <div
                        key={item.path}
                        className={`nav-item ${location.pathname === item.path ? 'active' : ''}`}
                        onClick={() => navigate(item.path)}
                    >
                        <span>{item.icon}</span>
                        <span>{item.label}</span>
                    </div>
                ))}
            </nav>
        </div>
    );
};

--- C:\Users\boobi\source\workmain\src\frontend\src\components\StartShiftModal.tsx ---
import React, { useState, useEffect } from 'react';
import { api } from '../apiclient';
import toast from 'react-hot-toast';
import { Schedule } from '../types'; // РЈР±РµРґРёС‚РµСЃСЊ, С‡С‚Рѕ РёРјРїРѕСЂС‚ РїСЂР°РІРёР»СЊРЅС‹Р№

interface StartShiftModalProps {
    isOpen: boolean;
    onClose: () => void;
    onSuccess: () => void;
}

export const StartShiftModal: React.FC<StartShiftModalProps> = ({ isOpen, onClose, onSuccess }) => {
    const [schedules, setSchedules] = useState<Schedule[]>([]);
    const [scheduleId, setScheduleId] = useState('');
    const [loading, setLoading] = useState(false);
    const [error, setError] = useState('');
    const [workDate, setWorkDate] = useState(() => {
        const now = new Date();
        // Р”РѕР±Р°РІР»СЏРµРј СЃРјРµС‰РµРЅРёРµ С‡Р°СЃРѕРІРѕРіРѕ РїРѕСЏСЃР° (РґР»СЏ РњРѕСЃРєРІС‹ СЌС‚Рѕ -180 РјРёРЅСѓС‚, С‚.Рµ. +3 С‡Р°СЃР°)
        // РќРѕ РїСЂРѕС‰Рµ РїСЂРѕСЃС‚Рѕ РїРѕР»СѓС‡РёС‚СЊ Р»РѕРєР°Р»СЊРЅСѓСЋ РґР°С‚Сѓ РІ С„РѕСЂРјР°С‚Рµ YYYY-MM-DD
        const offset = now.getTimezoneOffset();
        const localDate = new Date(now.getTime() - (offset * 60000));
        return localDate.toISOString().split('T')[0];
    });
    // 1. Р”РѕР±Р°РІР»СЏРµРј СЃС‚РµР№С‚ РґР»СЏ СЂРѕР»Рё
    const [userRole, setUserRole] = useState<string>('');

    useEffect(() => {
        if (isOpen) {
            loadData();
        }
    }, [isOpen]);

    const loadData = async () => {
        try {
            // 2. Р—Р°РіСЂСѓР¶Р°РµРј Рё РіСЂР°С„РёРєРё, Рё РїСЂРѕС„РёР»СЊ РїРѕР»СЊР·РѕРІР°С‚РµР»СЏ РїР°СЂР°Р»Р»РµР»СЊРЅРѕ
            const [schedulesResponse, profileResponse] = await Promise.all([
                api.Schedules.getAllSchedules(),
                api.Users.getProfile()
            ]);

            setSchedules(schedulesResponse.data);
            setUserRole(profileResponse.data.role); // РЎРѕС…СЂР°РЅСЏРµРј СЂРѕР»СЊ (SL1, SL2 Рё С‚.Рґ.)

        } catch (err) {
            console.error('Error loading data:', err);
            toast.error('РћС€РёР±РєР° Р·Р°РіСЂСѓР·РєРё РґР°РЅРЅС‹С…');
        }
    };

    const handleSubmit = async (e: React.FormEvent) => {
        e.preventDefault();
        if (!scheduleId) {
            setError('Р’С‹Р±РµСЂРёС‚Рµ РіСЂР°С„РёРє');
            return;
        }
        setLoading(true);
        setError('');

        try {
            await api.Shifts.startShift({
                scheduleId: parseInt(scheduleId),
                // workDate РѕС‚РїСЂР°РІР»СЏС‚СЊ РЅРµ РЅСѓР¶РЅРѕ, Р±СЌРєРµРЅРґ Р±РµСЂРµС‚ С‚РµРєСѓС‰СѓСЋ РґР°С‚Сѓ, 
                // РЅРѕ РµСЃР»Рё Сѓ РІР°СЃ РёР·РјРµРЅРµРЅРѕ API РґР»СЏ РїСЂРёРµРјР° РґР°С‚С‹:
                // workDate: workDate 
            });
            toast.success('РЎРјРµРЅР° РЅР°С‡Р°С‚Р°!');
            handleClose();
            onSuccess();
        } catch (err: any) {
            const errorMsg = err.response?.data?.error || 'РќРµ СѓРґР°Р»РѕСЃСЊ РЅР°С‡Р°С‚СЊ СЃРјРµРЅСѓ';
            setError(errorMsg);
            toast.error(errorMsg);
        } finally {
            setLoading(false);
        }
    };

    const handleClose = () => {
        setScheduleId('');
        setError('');
        onClose();
    };

    const selectedSchedule = schedules.find(s => s.id === parseInt(scheduleId));

    if (!isOpen) return null;

    // 3. Р›РѕРіРёРєР° С„РёР»СЊС‚СЂР°С†РёРё
    const filteredSchedules = schedules.filter(schedule => {
        // Р•СЃР»Рё РїРѕР»СЊР·РѕРІР°С‚РµР»СЊ Admin РёР»Рё TeamLead - РїРѕРєР°Р·С‹РІР°РµРј РІСЃС‘
        if (userRole === 'Admin' || userRole === 'TeamLead') return true;

        const name = schedule.name.toUpperCase();

        // Р›РѕРіРёРєР° РґР»СЏ SL1
        if (userRole === 'SL1') {
            // РџРѕРєР°Р·С‹РІР°РµРј РіСЂР°С„РёРєРё РґР»СЏ SL1 Рё РѕР±С‰РёРµ, СЃРєСЂС‹РІР°РµРј СЏРІРЅС‹Рµ SL2
            return !name.includes('SL2');
            // РР›Р: return name.includes('SL1') || name.includes('РћР‘Р©РР™');
        }

        // Р›РѕРіРёРєР° РґР»СЏ SL2
        if (userRole === 'SL2') {
            // РџРѕРєР°Р·С‹РІР°РµРј С‚РѕР»СЊРєРѕ SL2
            return name.includes('SL2');
        }

        return true; // Р”Р»СЏ РѕСЃС‚Р°Р»СЊРЅС‹С… РїРѕРєР°Р·С‹РІР°РµРј РІСЃС‘
    });

    return (
        <div className="modal-overlay" onClick={handleClose}>
            <div className="modal-content" onClick={e => e.stopPropagation()}>
                <div className="modal-header">
                    <h3>РќР°С‡Р°С‚СЊ СЃРјРµРЅСѓ</h3>
                    <button onClick={handleClose} className="close-btn">Г—</button>
                </div>

                <form onSubmit={handleSubmit}>
                    {error && <div className="alert alert-error">{error}</div>}

                    <div className="form-group">
                        <label className="form-label">Р’С‹Р±РµСЂРёС‚Рµ РіСЂР°С„РёРє</label>
                        <select
                            className="form-select"
                            value={scheduleId}
                            onChange={(e) => setScheduleId(e.target.value)}
                            required
                            disabled={loading}
                        >
                            <option value="">-- РќРµ РІС‹Р±СЂР°РЅРѕ --</option>

                            {/* 4. РСЃРїРѕР»СЊР·СѓРµРј filteredSchedules РІРјРµСЃС‚Рѕ schedules */}
                            {filteredSchedules.map(schedule => (
                                <option key={schedule.id} value={schedule.id}>
                                    {schedule.name} ({schedule.startTime.slice(0, 5)} - {schedule.endTime.slice(0, 5)})
                                </option>
                            ))}
                        </select>
                    </div>

                    {selectedSchedule && (
                        <div className="info-box">
                            <p><strong>РўРёРї СЃРјРµРЅС‹:</strong> {selectedSchedule.shiftType === 0 ? 'Р”РЅРµРІРЅР°СЏ' : 'Р’РµС‡РµСЂРЅСЏСЏ'}</p>
                        </div>
                    )}

                    <div className="modal-footer">
                        <button type="button" onClick={handleClose} className="btn btn-secondary" disabled={loading}>
                            РћС‚РјРµРЅР°
                        </button>
                        <button type="submit" className="btn btn-primary" disabled={loading}>
                            {loading ? 'Р—Р°РїСѓСЃРє...' : 'РќР°С‡Р°С‚СЊ СЃРјРµРЅСѓ'}
                        </button>
                    </div>
                </form>
            </div>
        </div>
    );
};


--- C:\Users\boobi\source\workmain\src\frontend\src\components\UserTable.tsx ---
import React from 'react';
import { UserShift } from '../types/dashboard.types';
import { breaksService } from '../services/breaksService';

interface UserTableProps {
    data: UserShift[];
    onDelete?: (id: number) => Promise<void>;
}

export const UserTable: React.FC<UserTableProps> = ({ data, onDelete }) => {
    const handleDelete = async (id: number) => {
        if (window.confirm('Р’С‹ СѓРІРµСЂРµРЅС‹?')) {
            try {
                await onDelete?.(id);
            } catch (error) {
                console.error('Error deleting shift:', error);
            }
        }
    };

    if (data.length === 0) {
        return (
            <table className="table">
                <thead>
                    <tr>
                        <th>Р”Р°С‚Р°</th>
                        <th>РЎРјРµРЅР°</th>
                        <th>Р Р°СЃРїРёСЃР°РЅРёРµ</th>
                        <th>РџРµСЂРµСЂС‹РІС‹</th>
                        <th>Р”РµР№СЃС‚РІРёСЏ</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td colSpan={5} style={{ textAlign: 'center', color: '#9ca3af' }}>
                            РќРµС‚ РґР°РЅРЅС‹С…
                        </td>
                    </tr>
                </tbody>
            </table>
        );
    }

    return (
        <table className="table">
            <thead>
                <tr>
                    <th>Р”Р°С‚Р°</th>
                    <th>РЎРјРµРЅР°</th>
                    <th>Р Р°СЃРїРёСЃР°РЅРёРµ</th>
                    <th>РџРµСЂРµСЂС‹РІС‹</th>
                    <th>Р”РµР№СЃС‚РІРёСЏ</th>
                </tr>
            </thead>
            <tbody>
                {data.map((shift) => (
                    <tr key={shift.id}>
                        <td>{shift.workDate}</td>
                        <td>{shift.group === 'Day' ? 'Р”РµРЅСЊ' : 'Р’РµС‡РµСЂ'}</td>
                        <td>{shift.schedule?.name || '-'}</td>
                        <td>
                            {shift.breaks?.length || 0} / {shift.breaks?.filter(b => b.status === 2).length || 0}
                        </td>
                        <td>
                            <button
                                className="btn btn-danger btn-small"
                                onClick={() => handleDelete(shift.id)}
                            >
                                РЈРґР°Р»РёС‚СЊ
                            </button>
                        </td>
                    </tr>
                ))}
            </tbody>
        </table>
    );
};

--- C:\Users\boobi\source\workmain\src\frontend\src\pages\AdminPage.tsx ---
import React, { useState, useEffect, useCallback } from 'react';
import { api } from '../api/client';
import toast from 'react-hot-toast';

interface Schedule {
    id: number;
    name: string;
    startTime: string;
    endTime: string;
    shiftType?: number;
}

interface User {
    id: number;
    userName: string;
    login: string;
    role: string;
    totalShifts: number;
    totalBreaks: number;
    completedBreaks: number;
    skippedBreaks: number;
}

interface DashboardStats {
    totalUsers: number;
    totalShiftsToday: number;
    activeBreaks: number;
    completedBreaksToday: number;
    skippedBreaksToday: number;
    totalBreaksToday: number;
}

interface BreakPool {
    id: number;
    group: string;
    workDate: string;
    maxCurrentBreaks: number;
    currentBreaksCount: number;
    availableBreaksCount: number;
}

interface UserShift {
    id: number;
    userId: number;
    userName: string;
    scheduleName: string;
    workDate: string;
    group: string;
    totalBreaks: number;
    activeBreaks: number;
    completedBreaks: number;
    skippedBreaks: number;
}

type TabType = 'stats' | 'schedules' | 'users' | 'breaks' | 'shifts';

const StatCard = React.memo(({ label, value, colorClass }: { label: string, value: number, colorClass: string }) => (
    <div className="panel-side" style={{ marginBottom: 0, padding: '24px', display: 'flex', flexDirection: 'column', gap: '8px' }}>
        <div className="text-muted fw-medium" style={{ fontSize: '14px' }}>{label}</div>
        <div className={`tabular-nums fw-bold ${colorClass}`} style={{ fontSize: '36px', lineHeight: 1 }}>{value}</div>
    </div>
));

const FormField = React.memo(({ label, type, value, onChange, placeholder, required, min }: any) => (
    <div style={{ marginBottom: '16px' }}>
        <label style={{ display: 'block', fontSize: '14px', fontWeight: 600, color: '#374151', marginBottom: '8px' }}>{label}</label>
        <input className="clean-input" type={type} value={value} onChange={onChange} placeholder={placeholder} required={required} min={min} />
    </div>
));

export const AdminPage: React.FC = () => {
    // ✅ Все useState с деструктурированием
    const [activeTab, setActiveTab] = useState<TabType>('stats');
    const [stats, setStats] = useState<DashboardStats | null>(null);
    const [schedules, setSchedules] = useState<Schedule[]>([]);
    const [users, setUsers] = useState<User[]>([]);
    const [breakPools, setBreakPools] = useState<BreakPool[]>([]);
    const [todayShifts, setTodayShifts] = useState<UserShift[]>([]);
    const [loading, setLoading] = useState(true);

    const [showScheduleForm, setShowScheduleForm] = useState(false);
    const [showUserForm, setShowUserForm] = useState(false);
    const [showBreakPoolForm, setShowBreakPoolForm] = useState(false);

    const [newSchedule, setNewSchedule] = useState({ name: '', startTime: '', endTime: '', shiftType: 0 });
    const [newUser, setNewUser] = useState({ userName: '', login: '', password: '', role: 'SL1' });
    const [newBreakPool, setNewBreakPool] = useState({
        workDate: new Date().toISOString().split('T')[0], // ✅ строка, не массив
        group: 0,
        maxCurrentBreaks: 5
    });

    const loadData = useCallback(async () => {
        setLoading(true);
        try {
            if (activeTab === 'stats') {
                const response = await api.Admin.getDashboardStats();
                setStats(response.data);
            } else if (activeTab === 'schedules') {
                const response = await api.Schedules.getAllSchedules();
                setSchedules(response.data);
            } else if (activeTab === 'users') {
                const response = await api.Admin.getAllUsers();
                setUsers(response.data);
            } else if (activeTab === 'breaks') {
                const response = await api.Admin.getAllBreakPools();
                setBreakPools(response.data);
            } else if (activeTab === 'shifts') {
                const response = await api.Admin.getTodayShifts();
                setTodayShifts(response.data);
            }
        } catch (err: any) {
            toast.error(err.response?.data?.error || 'Ошибка загрузки данных'); // ✅
        } finally {
            setLoading(false);
        }
    }, [activeTab]); // ✅

    useEffect(() => {
        loadData();
    }, [loadData]); // ✅

    const handleCreateSchedule = async (e: React.FormEvent) => {
        e.preventDefault();
        if (!newSchedule.name || !newSchedule.startTime || !newSchedule.endTime) {
            toast.error('Заполните все обязательные поля');
            return;
        }
        try {
            await api.Schedules.createSchedule({
                name: newSchedule.name,
                startTime: newSchedule.startTime,
                endTime: newSchedule.endTime,
                shiftType: newSchedule.shiftType,
            });
            toast.success('График успешно создан');
            setShowScheduleForm(false);
            setNewSchedule({ name: '', startTime: '', endTime: '', shiftType: 0 });
            await loadData();
        } catch (err: any) {
            toast.error(err.response?.data?.error || 'Ошибка создания графика'); // ✅
        }
    };

    const handleDeleteSchedule = async (id: number) => {
        if (!window.confirm('Вы уверены, что хотите удалить этот график?')) return;
        try {
            await api.Schedules.deleteSchedule(id);
            toast.success('График удалён');
            await loadData();
        } catch (err: any) {
            toast.error(err.response?.data?.error || 'Ошибка удаления графика'); // ✅
        }
    };

    const handleCreateUser = async (e: React.FormEvent) => {
        e.preventDefault();
        if (!newUser.userName || !newUser.login || !newUser.password) {
            toast.error('Заполните все обязательные поля');
            return;
        }
        try {
            await api.Admin.createUser({
                userName: newUser.userName,
                login: newUser.login,
                password: newUser.password,
                role: newUser.role,
            });
            toast.success('Пользователь создан');
            setShowUserForm(false);
            setNewUser({ userName: '', login: '', password: '', role: 'SL1' });
            await loadData();
        } catch (err: any) {
            toast.error(err.response?.data?.error || 'Ошибка создания пользователя'); // ✅
        }
    };

    const handleDeleteUser = async (id: number) => {
        if (!window.confirm('Вы действительно хотите удалить пользователя?')) return;
        try {
            await api.Admin.deleteUser(id);
            toast.success('Пользователь удалён');
            await loadData();
        } catch (err: any) {
            toast.error(err.response?.data?.error || 'Ошибка удаления пользователя'); // ✅
        }
    };

    const handleCreateBreakPool = async (e: React.FormEvent) => {
        e.preventDefault();
        try {
            await api.Admin.createBreakPool({
                workDate: newBreakPool.workDate,
                group: newBreakPool.group,
                maxCurrentBreaks: newBreakPool.maxCurrentBreaks,
            });
            toast.success('Пул перерывов обновлён');
            setShowBreakPoolForm(false);
            setNewBreakPool({
                workDate: new Date().toISOString().split('T')[0], // ✅
                group: 0,
                maxCurrentBreaks: 5
            });
            await loadData();
        } catch (err: any) {
            toast.error(err.response?.data?.error || 'Ошибка управления пулом'); // ✅
        }
    };

    const handleEndUserShift = async (shiftId: number) => {
        if (!window.confirm('Принудительно завершить смену этого сотрудника?')) return;
        try {
            await api.Admin.endUserShift(shiftId);
            toast.success('Смена завершена');
            await loadData();
        } catch (err: any) {
            toast.error(err.response?.data?.error || 'Ошибка завершения смены'); // ✅
        }
    };

    const dangerGhostBtnStyle = {
        backgroundColor: '#FEE2E2',
        color: '#C13333',
        border: 'none',
        borderRadius: '9999px',
        padding: '6px 16px',
        fontSize: '14px',
        fontWeight: 600,
        cursor: 'pointer',
        transition: 'opacity 0.2s'
    };

    return (
        <div style={{ maxWidth: '1000px', margin: '0 auto' }}>
            <h2 className="day-text" style={{ marginBottom: '32px' }}>Панель администратора</h2>

            <div style={{ display: 'flex', gap: '12px', marginBottom: '32px', flexWrap: 'wrap' }}>
                <button className={`tab-button ${activeTab === 'stats' ? 'active' : ''}`} onClick={() => setActiveTab('stats')}>Статистика</button>
                <button className={`tab-button ${activeTab === 'users' ? 'active' : ''}`} onClick={() => setActiveTab('users')}>Пользователи</button>
                <button className={`tab-button ${activeTab === 'schedules' ? 'active' : ''}`} onClick={() => setActiveTab('schedules')}>Графики</button>
                <button className={`tab-button ${activeTab === 'breaks' ? 'active' : ''}`} onClick={() => setActiveTab('breaks')}>Пулы перерывов</button>
                <button className={`tab-button ${activeTab === 'shifts' ? 'active' : ''}`} onClick={() => setActiveTab('shifts')}>Смены сегодня</button>
            </div>

            {loading ? (
                <div className="text-muted fw-medium" style={{ textAlign: 'center', padding: '40px' }}>Загрузка данных...</div>
            ) : (
                <div className="panel-main">

                    {activeTab === 'stats' && stats && (
                        <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))', gap: '24px' }}>
                            <StatCard label="Всего пользователей" value={stats.totalUsers} colorClass="text-primary" />
                            <StatCard label="Смен сегодня" value={stats.totalShiftsToday} colorClass="text-primary" />
                            <StatCard label="Активных перерывов" value={stats.activeBreaks} colorClass="text-red" />
                            <StatCard label="Завершено перерывов" value={stats.completedBreaksToday} colorClass="text-green" />
                            <StatCard label="Пропущено перерывов" value={stats.skippedBreaksToday} colorClass="text-muted" />
                            <StatCard label="Всего перерывов (за день)" value={stats.totalBreaksToday} colorClass="text-primary" />
                        </div>
                    )}

                    {activeTab === 'users' && (
                        <>
                            <div style={{ display: 'flex', justifyContent: 'flex-end', marginBottom: '24px' }}>
                                <button className="btn-solid-green" onClick={() => setShowUserForm(!showUserForm)} style={{ width: 'auto' }}>
                                    {showUserForm ? 'Отменить' : '+ Создать пользователя'}
                                </button>
                            </div>
                            {showUserForm && (
                                <form onSubmit={handleCreateUser} className="panel-side" style={{ marginBottom: '32px' }}>
                                    <h3 className="fw-bold" style={{ marginTop: 0, marginBottom: '24px' }}>Новый пользователь</h3>
                                    <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '16px' }}>
                                        <FormField label="Имя" type="text" value={newUser.userName} onChange={(e: any) => setNewUser({ ...newUser, userName: e.target.value })} required />
                                        <FormField label="Логин" type="text" value={newUser.login} onChange={(e: any) => setNewUser({ ...newUser, login: e.target.value })} required />
                                        <FormField label="Пароль" type="password" value={newUser.password} onChange={(e: any) => setNewUser({ ...newUser, password: e.target.value })} required />
                                        <div style={{ marginBottom: '16px' }}>
                                            <label style={{ display: 'block', fontSize: '14px', fontWeight: 600, color: '#374151', marginBottom: '8px' }}>Роль</label>
                                            <select className="clean-input" value={newUser.role} onChange={(e) => setNewUser({ ...newUser, role: e.target.value })}>
                                                <option value="SL1">SL1</option>
                                                <option value="SL2">SL2</option>
                                                <option value="Chatter">Chatter</option>
                                                <option value="TeamLead">Team Lead</option>
                                                <option value="Admin">Admin</option>
                                            </select>
                                        </div>
                                    </div>
                                    <button type="submit" className="btn-solid-green mt-3" style={{ width: 'auto' }}>Сохранить</button>
                                </form>
                            )}
                            {users.length === 0 ? (
                                <div className="text-muted fw-medium" style={{ textAlign: 'center' }}>Нет пользователей</div>
                            ) : (
                                <table className="borderless-table">
                                    <thead>
                                        <tr>
                                            <th>Имя</th><th>Логин</th><th>Роль</th><th>Смены</th><th>Действия</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        {users.map((u) => (
                                            <tr key={u.id}>
                                                <td className="fw-medium">{u.userName}</td>
                                                <td className="text-muted">{u.login}</td>
                                                <td><span className="pill-badge-green" style={{ backgroundColor: u.role === 'Admin' ? '#C13333' : '#7CCC63' }}>{u.role}</span></td>
                                                <td className="tabular-nums">{u.totalShifts}</td>
                                                <td><button onClick={() => handleDeleteUser(u.id)} style={dangerGhostBtnStyle}>Удалить</button></td>
                                            </tr>
                                        ))}
                                    </tbody>
                                </table>
                            )}
                        </>
                    )}

                    {activeTab === 'schedules' && (
                        <>
                            <div style={{ display: 'flex', justifyContent: 'flex-end', marginBottom: '24px' }}>
                                <button className="btn-solid-green" onClick={() => setShowScheduleForm(!showScheduleForm)} style={{ width: 'auto' }}>
                                    {showScheduleForm ? 'Отменить' : '+ Создать график'}
                                </button>
                            </div>
                            {showScheduleForm && (
                                <form onSubmit={handleCreateSchedule} className="panel-side" style={{ marginBottom: '32px' }}>
                                    <h3 className="fw-bold" style={{ marginTop: 0, marginBottom: '24px' }}>Новый график</h3>
                                    <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '16px' }}>
                                        <FormField label="Название (напр. Общий 09:00)" type="text" value={newSchedule.name} onChange={(e: any) => setNewSchedule({ ...newSchedule, name: e.target.value })} required />
                                        <div style={{ marginBottom: '16px' }}>
                                            <label style={{ display: 'block', fontSize: '14px', fontWeight: 600, color: '#374151', marginBottom: '8px' }}>Тип смены</label>
                                            <select className="clean-input" value={newSchedule.shiftType} onChange={(e) => setNewSchedule({ ...newSchedule, shiftType: parseInt(e.target.value) })}>
                                                <option value={0}>Дневная (Day)</option>
                                                <option value={1}>Вечерняя (Evening)</option>
                                            </select>
                                        </div>
                                        <FormField label="Время начала" type="time" value={newSchedule.startTime} onChange={(e: any) => setNewSchedule({ ...newSchedule, startTime: e.target.value })} required />
                                        <FormField label="Время окончания" type="time" value={newSchedule.endTime} onChange={(e: any) => setNewSchedule({ ...newSchedule, endTime: e.target.value })} required />
                                    </div>
                                    <button type="submit" className="btn-solid-green mt-3" style={{ width: 'auto' }}>Создать</button>
                                </form>
                            )}
                            {schedules.length === 0 ? (
                                <div className="text-muted fw-medium" style={{ textAlign: 'center' }}>Нет графиков</div>
                            ) : (
                                <table className="borderless-table">
                                    <thead>
                                        <tr>
                                            <th>Название</th><th>Тип</th><th>Время</th><th>Действия</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        {schedules.map((s) => (
                                            <tr key={s.id}>
                                                <td className="fw-medium">{s.name}</td>
                                                <td>{s.shiftType === 0 ? 'День' : 'Вечер'}</td>
                                                <td className="tabular-nums text-muted">{s.startTime.slice(0, 5)} - {s.endTime.slice(0, 5)}</td>
                                                <td><button onClick={() => handleDeleteSchedule(s.id)} style={dangerGhostBtnStyle}>Удалить</button></td>
                                            </tr>
                                        ))}
                                    </tbody>
                                </table>
                            )}
                        </>
                    )}

                    {activeTab === 'breaks' && (
                        <>
                            <div style={{ display: 'flex', justifyContent: 'flex-end', marginBottom: '24px' }}>
                                <button className="btn-solid-green" onClick={() => setShowBreakPoolForm(!showBreakPoolForm)} style={{ width: 'auto' }}>
                                    {showBreakPoolForm ? 'Отменить' : '+ Изменить пул'}
                                </button>
                            </div>
                            {showBreakPoolForm && (
                                <form onSubmit={handleCreateBreakPool} className="panel-side" style={{ marginBottom: '32px' }}>
                                    <h3 className="fw-bold" style={{ marginTop: 0, marginBottom: '24px' }}>Управление пулом</h3>
                                    <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr 1fr', gap: '16px' }}>
                                        <FormField label="Дата" type="date" value={newBreakPool.workDate} onChange={(e: any) => setNewBreakPool({ ...newBreakPool, workDate: e.target.value })} required />
                                        <div style={{ marginBottom: '16px' }}>
                                            <label style={{ display: 'block', fontSize: '14px', fontWeight: 600, color: '#374151', marginBottom: '8px' }}>Смена</label>
                                            <select className="clean-input" value={newBreakPool.group} onChange={(e) => setNewBreakPool({ ...newBreakPool, group: parseInt(e.target.value) })}>
                                                <option value={0}>Дневная (Day)</option>
                                                <option value={1}>Вечерняя (Evening)</option>
                                            </select>
                                        </div>
                                        <FormField label="Макс. мест (в линии)" type="number" min="1" value={newBreakPool.maxCurrentBreaks} onChange={(e: any) => setNewBreakPool({ ...newBreakPool, maxCurrentBreaks: parseInt(e.target.value) })} required />
                                    </div>
                                    <button type="submit" className="btn-solid-green mt-3" style={{ width: 'auto' }}>Применить</button>
                                </form>
                            )}
                            {breakPools.length === 0 ? (
                                <div className="text-muted fw-medium" style={{ textAlign: 'center' }}>Нет активных пулов</div>
                            ) : (
                                <table className="borderless-table">
                                    <thead>
                                        <tr>
                                            <th>Дата</th><th>Группа</th><th>Свободно мест</th><th>Всего мест</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        {breakPools.map((pool) => (
                                            <tr key={pool.id}>
                                                <td className="tabular-nums fw-medium">{pool.workDate}</td>
                                                <td>{pool.group === 'Day' ? 'День' : 'Вечер'}</td>
                                                <td className="tabular-nums text-green fw-bold">{pool.availableBreaksCount}</td>
                                                <td className="tabular-nums text-muted">{pool.maxCurrentBreaks}</td>
                                            </tr>
                                        ))}
                                    </tbody>
                                </table>
                            )}
                        </>
                    )}

                    {activeTab === 'shifts' && (
                        <>
                            {todayShifts.length === 0 ? (
                                <div className="text-muted fw-medium" style={{ textAlign: 'center' }}>Сегодня нет активных смен</div>
                            ) : (
                                <table className="borderless-table">
                                    <thead>
                                        <tr>
                                            <th>Сотрудник</th><th>График</th><th>Группа</th><th>Статус перерывов</th><th>Действия</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        {todayShifts.map((shift) => (
                                            <tr key={shift.id}>
                                                <td className="fw-medium">{shift.userName}</td>
                                                <td className="text-muted">{shift.scheduleName}</td>
                                                <td>{shift.group === 'Day' ? 'День' : 'Вечер'}</td>
                                                <td className="tabular-nums text-muted">
                                                    {shift.completedBreaks} / {shift.totalBreaks} ({shift.activeBreaks > 0 ? <span className="text-red">На перерыве</span> : 'В линии'})
                                                </td>
                                                <td>
                                                    <button onClick={() => handleEndUserShift(shift.id)} style={dangerGhostBtnStyle}>
                                                        Завершить смену
                                                    </button>
                                                </td>
                                            </tr>
                                        ))}
                                    </tbody>
                                </table>
                            )}
                        </>
                    )}
                </div>
            )}
        </div>
    );
};


--- C:\Users\boobi\source\workmain\src\frontend\src\pages\DashboardPage.tsx ---
import React, { useState, useEffect } from 'react';
import { api } from '../api/client';
import toast from 'react-hot-toast';
import { BreakQueue } from '../components/BreakQueue';

interface Schedule {
    id: number;
    name: string;
    startTime: string;
    endTime: string;
}

interface Colleague {
    userId: number;
    userName: string;
    group: string;
    isCurrentUser: boolean;
    activeBreaksCount: number;
    completedBreaksCount: number;
}

export const DashboardPage: React.FC = () => {
    const [currentShift, setCurrentShift] = useState<any | null>(null);       // вњ…
    const [colleagues, setColleagues] = useState<Colleague[]>([]);             // вњ…
    const [schedules, setSchedules] = useState<Schedule[]>([]);                // вњ…
    const [activeBreak, setActiveBreak] = useState<any | null>(null);         // вњ…
    const [poolInfo, setPoolInfo] = useState<any | null>(null);
    const [selectedScheduleId, setSelectedScheduleId] = useState('');         // вњ…
    const [shiftElapsed, setShiftElapsed] = useState(0);                      // вњ…
    const [breakRemaining, setBreakRemaining] = useState(0);                  // вњ…

    const getMskDateString = () => {
        const now = new Date();
        const msk = new Date(now.getTime() + (now.getTimezoneOffset() * 60000) + (3 * 3600000));
        return msk.toISOString().split('T')[0]; // вњ… СЃС‚СЂРѕРєР°, РЅРµ РјР°СЃСЃРёРІ
    };

    const loadData = async () => {
        const todayStr = getMskDateString();
        try {
            const schedRes = await api.Shifts.getAvailableSchedules();
            setSchedules(schedRes.data);
            if (schedRes.data.length > 0 && !selectedScheduleId) {
                setSelectedScheduleId(schedRes.data[0].id.toString()); // вњ…
            }

            const shiftRes = await api.Shifts.getMyShift(todayStr);
            setCurrentShift(shiftRes.data);

            if (shiftRes.data?.scheduleId) {
                const colRes = await api.Shifts.getColleagues(shiftRes.data.scheduleId, todayStr);
                setColleagues(colRes.data);

                const poolRes = await api.Breaks.getBreakPoolInfo(todayStr);
                setPoolInfo(poolRes.data);

                const breakRes = await api.Breaks.getMyActiveBreak();
                setActiveBreak(breakRes.data.hasActiveBreak ? breakRes.data.breakData : null);
            }
        } catch (err: any) {
            if (err.response?.status !== 404) {
                console.error(err);
            }
        }
    };

    useEffect(() => {
        loadData();
    }, []); // вњ…

    useEffect(() => {
        if (!currentShift) return;
        const start = new Date(currentShift.startedAt).getTime();
        const interval = setInterval(() => {
            setShiftElapsed(Math.floor((Date.now() - start) / 1000));
        }, 1000);
        return () => clearInterval(interval);
    }, [currentShift]); // вњ… Р·Р°РІРёСЃРёРјРѕСЃС‚СЊ РѕС‚ currentShift

    useEffect(() => {
        if (!activeBreak) {
            setBreakRemaining(0);
            return;
        }
        const interval = setInterval(() => {
            const startTime = new Date(activeBreak.startTime).getTime();
            const elapsed = Math.floor((Date.now() - startTime) / 1000);
            const total = activeBreak.durationMinutes * 60;
            setBreakRemaining(Math.max(0, total - elapsed));
        }, 1000);
        return () => clearInterval(interval);
    }, [activeBreak]); // вњ… Р·Р°РІРёСЃРёРјРѕСЃС‚СЊ РѕС‚ activeBreak

    const handleStartShift = async (e: React.FormEvent) => {
        e.preventDefault();
        if (!selectedScheduleId) return;
        try {
            await api.Shifts.startShift({ scheduleId: parseInt(selectedScheduleId) });
            toast.success('РЎРјРµРЅР° РЅР°С‡Р°С‚Р°!');
            await loadData();
        } catch (err: any) {
            toast.error(err.response?.data?.error || 'РћС€РёР±РєР° РЅР°С‡Р°Р»Р° СЃРјРµРЅС‹'); // вњ…
        }
    };

    const handleEndBreak = async () => {
        if (!activeBreak) return;
        try {
            await api.Breaks.endBreak(activeBreak.id);
            toast.success('РџРµСЂРµСЂС‹РІ Р·Р°РІРµСЂС€С‘РЅ!');
            setActiveBreak(null);
            await loadData();
        } catch (err: any) {
            toast.error(err.response?.data?.error || 'РћС€РёР±РєР° Р·Р°РІРµСЂС€РµРЅРёСЏ РїРµСЂРµСЂС‹РІР°'); // вњ…
        }
    };

    const formatDuration = (seconds: number) => {
        const h = Math.floor(seconds / 3600);
        const m = Math.floor((seconds % 3600) / 60);
        const s = seconds % 60;
        if (h > 0) return `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
        return `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
    };

    if (!currentShift) {
        return (
            <div className="panel-main" style={{ maxWidth: '600px', margin: '0 auto' }}>
                <h2 style={{ marginTop: 0, fontSize: '24px' }}>РќР°С‡Р°С‚СЊ СЃРјРµРЅСѓ</h2>
                <form onSubmit={handleStartShift}>
                    <select
                        className="clean-input mt-3"
                        value={selectedScheduleId}
                        onChange={(e) => setSelectedScheduleId(e.target.value)}
                        required
                    >
                        <option value="">Р’С‹Р±РµСЂРёС‚Рµ СЂР°СЃРїРёСЃР°РЅРёРµ</option>
                        {schedules.map(s => (
                            <option key={s.id} value={s.id}>
                                {s.name} ({s.startTime.slice(0, 5)} - {s.endTime.slice(0, 5)})
                            </option>
                        ))}
                    </select>
                    <button type="submit" className="btn-solid-green mt-4" style={{ width: '100%' }}>
                        РќР°С‡Р°С‚СЊ СЂР°Р±РѕС‚Сѓ
                    </button>
                </form>
            </div>
        );
    }

    const currentUser = colleagues.find(c => c.isCurrentUser);
    const sortedColleagues = [...colleagues].sort((a, b) =>
        a.isCurrentUser === b.isCurrentUser ? 0 : a.isCurrentUser ? -1 : 1
    );
    const breaksRemaining = currentShift?.breaks
        ? Math.max(0, 2 - currentShift.breaks.filter((b: any) => b.status === 'Finished').length)
        : 0;

    return (
        <div className="dashboard-layout">
            <div>
                <div className="panel-main">
                    {currentUser && (
                        <h2 style={{ fontSize: '32px', marginBottom: '32px', marginTop: 0 }}>
                            (Р’С‹) {currentUser.userName}
                        </h2>
                    )}
                    <table className="borderless-table">
                        <thead>
                            <tr>
                                <th>РРјСЏ</th>
                                <th>РЎС‚Р°С‚СѓСЃ</th>
                                <th>РџРµСЂРµСЂС‹РІРѕРІ</th>
                                <th>РўР°Р№РјРµСЂ</th>
                            </tr>
                        </thead>
                        <tbody>
                            {sortedColleagues.map(c => {
                                const isOnBreak = c.activeBreaksCount > 0;
                                return (
                                    <tr key={c.userId}>
                                        <td>
                                            <div className="user-name-cell">
                                                {!c.isCurrentUser && <span className="user-icon">рџ‘¤</span>}
                                                <span className={c.isCurrentUser ? 'fw-bold' : 'fw-medium'}>
                                                    {c.isCurrentUser ? `(Р’С‹) ${c.userName}` : c.userName}
                                                </span>
                                            </div>
                                        </td>
                                        <td className={`fw-bold ${isOnBreak ? 'text-red' : 'text-green'}`}>
                                            {isOnBreak ? 'РџРµСЂРµСЂС‹РІ' : 'Р’ Р»РёРЅРёРё'}
                                        </td>
                                        <td>{c.completedBreaksCount}/2</td>
                                        <td className="tabular-nums text-muted fw-medium">
                                            {c.isCurrentUser && !isOnBreak
                                                ? formatDuration(shiftElapsed)
                                                : (isOnBreak ? '15:03 (20)' : '02:34:42')}
                                        </td>
                                    </tr>
                                );
                            })}
                        </tbody>
                    </table>
                </div>
                <BreakQueue activeBreak={activeBreak} onBreakStateChange={loadData} />
            </div>

            <div>
                <div className="panel-side shift-status-card">
                    <div className="shift-status-header">
                        <span className="fw-bold">РЎРјРµРЅР°</span>
                        <span className="tabular-nums fw-medium">
                            {currentShift.schedule?.startTime.slice(0, 5)}-{currentShift.schedule?.endTime.slice(0, 5)}
                        </span>
                    </div>
                    <div className="text-muted mt-3" style={{ fontSize: '14px' }}>
                        РџРµСЂРµСЂС‹РІРѕРІ РѕСЃС‚Р°Р»РѕСЃСЊ: {breaksRemaining}
                    </div>
                    <div className="shift-emoji">
                        {activeBreak ? 'в•' : 'рџ«Ў'}
                    </div>
                    <div className="shift-main-timer">
                        {activeBreak ? formatDuration(breakRemaining) : formatDuration(shiftElapsed)}
                    </div>
                    {activeBreak && (
                        <button className="btn-solid-red" onClick={handleEndBreak}>
                            РќР° РјРµСЃС‚Рµ
                        </button>
                    )}
                    <div className="text-muted mt-4 fw-medium" style={{ fontSize: '14px' }}>
                        РџРµСЂРµСЂС‹РІРѕРІ СЃРІРѕР±РѕРґРЅРѕ: {poolInfo?.availableBreaks || 0} // вњ…
                    </div>
                </div>

                <div className="panel-side" style={{ marginBottom: 0 }}>
                    <h3 className="roles-title">РЎРµРіРѕРґРЅСЏ РЅР° СЃРјРµРЅРµ</h3>
                    <div className="role-group">
                        <div className="role-label">Р›РёРґС‹</div>
                        <div className="role-items">
                            <div className="role-item">
                                <span className="pill-badge-green">РЎР°С€Р°</span>
                                <span className="tabular-nums fw-medium text-muted">16-00</span>
                            </div>
                            <div className="role-item">
                                <span className="pill-badge-green">РќР°СЃС‚СЏ</span>
                                <span className="tabular-nums fw-medium text-muted">16-00</span>
                            </div>
                        </div>
                    </div>
                    <div className="role-group">
                        <div className="role-label">РљРѕРѕСЂРґРёРЅР°С‚РѕСЂ</div>
                        <div className="role-items">
                            <div className="role-item">
                                <span className="pill-badge-green">РСЂРёРЅР°</span>
                                <span className="tabular-nums fw-medium text-muted">10-19</span>
                            </div>
                        </div>
                    </div>
                    <div className="role-group" style={{ marginBottom: 0 }}>
                        <div className="role-label">РђРґРјРёРЅС‹</div>
                        <div className="role-items">
                            <div className="role-item">
                                <span className="pill-badge-green">Р’Р°СЃСЏ</span>
                                <span className="tabular-nums fw-medium text-muted">16-00</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    );
};


--- C:\Users\boobi\source\workmain\src\frontend\src\pages\LoginPage.tsx ---
import React, { useState } from 'react';
import { useNavigate, Link } from 'react-router-dom';
import { api, setAuthToken } from '../api/client';
import toast from 'react-hot-toast';

export const LoginPage: React.FC = () => {
    const [login, setLogin] = useState('');
    const [password, setPassword] = useState('');
    const [loading, setLoading] = useState(false);
    const navigate = useNavigate();

    const handleSubmit = async (e: React.FormEvent) => {
        e.preventDefault();
        setLoading(true);
        try {
            const response = await api.Users.login(login, password);
            // РЎРѕС…СЂР°РЅСЏРµРј С‚РѕРєРµРЅ Рё СѓСЃС‚Р°РЅР°РІР»РёРІР°РµРј РµРіРѕ РІ axios
            setAuthToken(response.data.token);
            toast.success('Р’С…РѕРґ РІС‹РїРѕР»РЅРµРЅ СѓСЃРїРµС€РЅРѕ!');
            navigate('/dashboard');
        } catch (err: any) {
            toast.error(err.response?.data?.error || 'РћС€РёР±РєР° Р°РІС‚РѕСЂРёР·Р°С†РёРё. РџСЂРѕРІРµСЂСЊС‚Рµ Р»РѕРіРёРЅ Рё РїР°СЂРѕР»СЊ.');
        } finally {
            setLoading(false);
        }
    };

    return (
        <div className="auth-wrapper">
            <div className="auth-card">
                <h2 className="day-text" style={{ textAlign: 'center', marginBottom: '40px', fontSize: '32px' }}>
                    Р’С…РѕРґ РІ СЃРёСЃС‚РµРјСѓ
                </h2>

                <form onSubmit={handleSubmit}>
                    <div style={{ marginBottom: '24px' }}>
                        <label style={{ display: 'block', marginBottom: '8px', fontWeight: 600, color: '#374151', fontSize: '14px' }}>
                            Р›РѕРіРёРЅ
                        </label>
                        <input
                            className="clean-input"
                            type="text"
                            placeholder="Р’РІРµРґРёС‚Рµ Р»РѕРіРёРЅ"
                            value={login}
                            onChange={e => setLogin(e.target.value)}
                            required
                            disabled={loading}
                        />
                    </div>

                    <div style={{ marginBottom: '32px' }}>
                        <label style={{ display: 'block', marginBottom: '8px', fontWeight: 600, color: '#374151', fontSize: '14px' }}>
                            РџР°СЂРѕР»СЊ
                        </label>
                        <input
                            className="clean-input"
                            type="password"
                            placeholder="Р’РІРµРґРёС‚Рµ РїР°СЂРѕР»СЊ"
                            value={password}
                            onChange={e => setPassword(e.target.value)}
                            required
                            disabled={loading}
                        />
                    </div>

                    <button className="btn-solid-green" type="submit" disabled={loading} style={{ width: '100%' }}>
                        {loading ? 'Р—Р°РіСЂСѓР·РєР°...' : 'Р’РѕР№С‚Рё'}
                    </button>
                </form>

                <div style={{ textAlign: 'center', marginTop: '32px' }}>
                    <Link to="/register" className="text-muted fw-medium" style={{ textDecoration: 'none', transition: 'color 0.2s' }}>
                        РќРµС‚ Р°РєРєР°СѓРЅС‚Р°? <span className="text-green">Р—Р°СЂРµРіРёСЃС‚СЂРёСЂРѕРІР°С‚СЊСЃСЏ</span>
                    </Link>
                </div>
            </div>
        </div>
    );
};

--- C:\Users\boobi\source\workmain\src\frontend\src\pages\ProfilePage.tsx ---
import React, { useState, useEffect } from 'react';
import { api } from '../api/client';
import toast from 'react-hot-toast';

interface UserProfile {
    id: number;
    userName: string;
    login: string;
    role: string;
    totalShifts: number;
    totalBreaks: number;
    completedBreaks: number;
    skippedBreaks: number;
}

export const ProfilePage: React.FC = () => {
    const [profile, setProfile] = useState<UserProfile | null>(null);
    const [loading, setLoading] = useState(true);
    const [editing, setEditing] = useState(false);
    const [newUserName, setNewUserName] = useState('');

    const loadProfile = async () => {
        try {
            setLoading(true);
            const response = await api.Users.getProfile();
            setProfile(response.data);
            setNewUserName(response.data.userName);
        } catch (err: any) {
            toast.error('Ошибка загрузки профиля');
        } finally {
            setLoading(false);
        }
    };

    useEffect(() => {
        loadProfile();
    }, []); // ✅

    const handleUpdateProfile = async () => {
        if (!newUserName.trim()) {
            toast.error('Введите имя');
            return;
        }
        try {
            await api.Users.updateProfile({ userName: newUserName });
            toast.success('Профиль обновлён');
            setEditing(false);
            await loadProfile();
        } catch (err: any) {
            toast.error(err.response?.data?.error || 'Ошибка обновления профиля'); // ✅
        }
    };

    if (loading) {
        return <div className="text-muted fw-medium" style={{ padding: '40px', textAlign: 'center' }}>Загрузка профиля...</div>;
    }

    if (!profile) return null;

    return (
        <div style={{ maxWidth: '800px', margin: '0 auto' }}>
            <h2 className="day-text" style={{ marginBottom: '32px' }}>Профиль</h2>

            <div className="panel-main" style={{ marginBottom: '24px' }}>
                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start' }}>
                    <div style={{ display: 'flex', gap: '24px', alignItems: 'center' }}>
                        <div style={{
                            width: '80px', height: '80px', borderRadius: '50%',
                            backgroundColor: 'var(--bg-surface-side)', display: 'flex',
                            alignItems: 'center', justifyContent: 'center', fontSize: '32px'
                        }}>
                            👤
                        </div>
                        <div>
                            <h3 style={{ margin: '0 0 4px 0', fontSize: '24px', color: '#111827' }}>
                                {profile.userName}
                            </h3>
                            <div className="text-muted fw-medium" style={{ marginBottom: '8px' }}>
                                @{profile.login}
                            </div>
                            <span className="pill-badge-green">{profile.role}</span>
                        </div>
                    </div>
                    <button
                        onClick={() => setEditing(!editing)}
                        className="btn-outline-secondary"
                        style={{ padding: '8px 16px', fontSize: '14px', width: 'auto' }}
                    >
                        {editing ? 'Отмена' : 'Редактировать'}
                    </button>
                </div>

                {editing && (
                    <div style={{ marginTop: '32px', borderTop: '1px solid #E5E7EB', paddingTop: '24px' }}>
                        <label style={{ display: 'block', fontSize: '14px', fontWeight: 600, color: '#374151', marginBottom: '8px' }}>
                            Имя пользователя
                        </label>
                        <div style={{ display: 'flex', gap: '12px' }}>
                            <input
                                className="clean-input"
                                type="text"
                                value={newUserName}
                                onChange={(e) => setNewUserName(e.target.value)}
                            />
                            <button className="btn-solid-green" onClick={handleUpdateProfile} style={{ width: 'auto', whiteSpace: 'nowrap' }}>
                                Сохранить
                            </button>
                        </div>
                    </div>
                )}
            </div>

            <h3 className="fw-bold" style={{ fontSize: '20px', marginBottom: '24px' }}>Статистика</h3>
            <div style={{ display: 'grid', gridTemplateColumns: 'repeat(2, 1fr)', gap: '24px' }}>
                <div className="panel-side" style={{ marginBottom: 0 }}>
                    <div className="text-muted fw-medium" style={{ fontSize: '14px', marginBottom: '8px' }}>Всего смен</div>
                    <div className="tabular-nums fw-bold text-main" style={{ fontSize: '40px', lineHeight: 1 }}>{profile.totalShifts}</div>
                </div>
                <div className="panel-side" style={{ marginBottom: 0 }}>
                    <div className="text-muted fw-medium" style={{ fontSize: '14px', marginBottom: '8px' }}>Всего перерывов</div>
                    <div className="tabular-nums fw-bold text-main" style={{ fontSize: '40px', lineHeight: 1 }}>{profile.totalBreaks}</div>
                </div>
                <div className="panel-side" style={{ marginBottom: 0 }}>
                    <div className="text-muted fw-medium" style={{ fontSize: '14px', marginBottom: '8px' }}>Завершённые перерывы</div>
                    <div className="tabular-nums fw-bold text-green" style={{ fontSize: '40px', lineHeight: 1 }}>{profile.completedBreaks}</div>
                </div>
                <div className="panel-side" style={{ marginBottom: 0 }}>
                    <div className="text-muted fw-medium" style={{ fontSize: '14px', marginBottom: '8px' }}>Пропущенные перерывы</div>
                    <div className="tabular-nums fw-bold text-red" style={{ fontSize: '40px', lineHeight: 1 }}>{profile.skippedBreaks}</div>
                </div>
            </div>
        </div>
    );
};


--- C:\Users\boobi\source\workmain\src\frontend\src\pages\RegisterPage.tsx ---
import React, { useState } from 'react';
import { useNavigate, Link } from 'react-router-dom';
import { api } from '../api/client';
import toast from 'react-hot-toast';

export const RegisterPage: React.FC = () => {
    const [userName, setUserName] = useState('');
    const [login, setLogin] = useState('');
    const [password, setPassword] = useState('');
    const [confirmPassword, setConfirmPassword] = useState('');
    const [loading, setLoading] = useState(false);
    const navigate = useNavigate();

    const handleSubmit = async (e: React.FormEvent) => {
        e.preventDefault();

        if (password !== confirmPassword) {
            toast.error('РџР°СЂРѕР»Рё РЅРµ СЃРѕРІРїР°РґР°СЋС‚');
            return;
        }

        setLoading(true);
        try {
            await api.Users.register(userName, login, password);
            toast.success('Р РµРіРёСЃС‚СЂР°С†РёСЏ СѓСЃРїРµС€РЅР°! РўРµРїРµСЂСЊ РІС‹ РјРѕР¶РµС‚Рµ РІРѕР№С‚Рё.');
            navigate('/login');
        } catch (err: any) {
            toast.error(err.response?.data?.error || 'РћС€РёР±РєР° РїСЂРё СЂРµРіРёСЃС‚СЂР°С†РёРё');
        } finally {
            setLoading(false);
        }
    };

    return (
        <div className="auth-wrapper">
            <div className="auth-card">
                <h2 className="day-text" style={{ textAlign: 'center', marginBottom: '40px', fontSize: '32px' }}>
                    Р РµРіРёСЃС‚СЂР°С†РёСЏ
                </h2>

                <form onSubmit={handleSubmit}>
                    <div style={{ marginBottom: '20px' }}>
                        <label style={{ display: 'block', marginBottom: '8px', fontWeight: 600, color: '#374151', fontSize: '14px' }}>
                            РРјСЏ РїРѕР»СЊР·РѕРІР°С‚РµР»СЏ (РћС‚РѕР±СЂР°Р¶Р°РµРјРѕРµ)
                        </label>
                        <input
                            className="clean-input"
                            type="text"
                            placeholder="РќР°РїСЂРёРјРµСЂ: РРІР°РЅ РРІР°РЅРѕРІ"
                            value={userName}
                            onChange={e => setUserName(e.target.value)}
                            required
                            disabled={loading}
                        />
                    </div>

                    <div style={{ marginBottom: '20px' }}>
                        <label style={{ display: 'block', marginBottom: '8px', fontWeight: 600, color: '#374151', fontSize: '14px' }}>
                            Р›РѕРіРёРЅ
                        </label>
                        <input
                            className="clean-input"
                            type="text"
                            placeholder="ivanov"
                            value={login}
                            onChange={e => setLogin(e.target.value)}
                            required
                            disabled={loading}
                        />
                    </div>

                    <div style={{ marginBottom: '20px' }}>
                        <label style={{ display: 'block', marginBottom: '8px', fontWeight: 600, color: '#374151', fontSize: '14px' }}>
                            РџР°СЂРѕР»СЊ
                        </label>
                        <input
                            className="clean-input"
                            type="password"
                            placeholder="РњРёРЅРёРјСѓРј 6 СЃРёРјРІРѕР»РѕРІ"
                            value={password}
                            onChange={e => setPassword(e.target.value)}
                            required
                            disabled={loading}
                        />
                    </div>

                    <div style={{ marginBottom: '32px' }}>
                        <label style={{ display: 'block', marginBottom: '8px', fontWeight: 600, color: '#374151', fontSize: '14px' }}>
                            РџРѕРґС‚РІРµСЂРґРёС‚Рµ РїР°СЂРѕР»СЊ
                        </label>
                        <input
                            className="clean-input"
                            type="password"
                            placeholder="РџРѕРІС‚РѕСЂРёС‚Рµ РїР°СЂРѕР»СЊ"
                            value={confirmPassword}
                            onChange={e => setConfirmPassword(e.target.value)}
                            required
                            disabled={loading}
                        />
                    </div>

                    <button className="btn-solid-green" type="submit" disabled={loading} style={{ width: '100%' }}>
                        {loading ? 'РЎРѕР·РґР°РЅРёРµ...' : 'РЎРѕР·РґР°С‚СЊ Р°РєРєР°СѓРЅС‚'}
                    </button>
                </form>

                <div style={{ textAlign: 'center', marginTop: '32px' }}>
                    <Link to="/login" className="text-muted fw-medium" style={{ textDecoration: 'none', transition: 'color 0.2s' }}>
                        РЈР¶Рµ РµСЃС‚СЊ Р°РєРєР°СѓРЅС‚? <span className="text-green">Р’РѕР№С‚Рё</span>
                    </Link>
                </div>
            </div>
        </div>
    );
};

--- C:\Users\boobi\source\workmain\src\frontend\src\services\adminService.ts ---
import apiClient from '../api/client';  
import {
    AdminUserDto,
    CreateUserAdminDto,
    UpdateUserAdminDto,
    DashboardStatsDto,
    UserShiftDetailDto,
    BreakPoolDayDto,
    CreateBreakPoolDayDto,
    Schedule,
    CreateScheduleDto,
    UpdateScheduleDto,
} from '../types/admin';

export const adminService = {
    // Статистика
    getDashboardStats: async (): Promise<DashboardStatsDto> => {
        const response = await apiClient.get('/admin/stats');
        return response.data;
    },

    getTodayShifts: async (): Promise<UserShiftDetailDto[]> => {
        const response = await apiClient.get('/admin/shifts/today');
        return response.data;
    },

    // Пользователи
    getAllUsers: async (): Promise<AdminUserDto[]> => {
        const response = await apiClient.get('/admin/users');
        return response.data;
    },

    getUserById: async (id: number): Promise<AdminUserDto> => {
        const response = await apiClient.get(`/admin/users/${id}`);
        return response.data;
    },

    createUser: async (data: CreateUserAdminDto): Promise<AdminUserDto> => {
        const response = await apiClient.post('/admin/users', data);
        return response.data;
    },

    updateUser: async (id: number, data: UpdateUserAdminDto): Promise<AdminUserDto> => {
        const response = await apiClient.put(`/admin/users/${id}`, data);
        return response.data;
    },

    deleteUser: async (userId: number): Promise<void> => {
        await apiClient.delete(`/admin/users/${userId}`);
    },

    // Расписания
    getAllSchedules: async (): Promise<Schedule[]> => {
        const response = await apiClient.get('/admin/schedules');
        return response.data;
    },

    getScheduleById: async (id: number): Promise<Schedule> => {
        const response = await apiClient.get(`/admin/schedules/${id}`);
        return response.data;
    },

    createSchedule: async (data: CreateScheduleDto): Promise<Schedule> => {
        const response = await apiClient.post('/admin/schedules', data);
        return response.data;
    },

    updateSchedule: async (id: number, data: UpdateScheduleDto): Promise<Schedule> => {
        const response = await apiClient.put(`/admin/schedules/${id}`, data);
        return response.data;
    },

    deleteSchedule: async (id: number): Promise<void> => {
        await apiClient.delete(`/admin/schedules/${id}`);
    },

    // Пулы перерывов
    getAllBreakPools: async (): Promise<BreakPoolDayDto[]> => {
        const response = await apiClient.get('/admin/break-pools');
        return response.data;
    },

    createOrUpdateBreakPool: async (data: CreateBreakPoolDayDto): Promise<BreakPoolDayDto> => {
        const response = await apiClient.post('/admin/break-pools', data);
        return response.data;
    },
};


--- C:\Users\boobi\source\workmain\src\frontend\src\services\api111.ts ---
import axios, { AxiosInstance, AxiosError } from 'axios';

const API_BASE = 'https://localhost:7059/api';

let axiosInstance: AxiosInstance = axios.create({
    baseURL: API_BASE,
    headers: {
        'Content-Type': 'application/json'
    },
    withCredentials: true
});

// Interceptor РґР»СЏ РґРѕР±Р°РІР»РµРЅРёСЏ С‚РѕРєРµРЅР°
axiosInstance.interceptors.request.use(
    (config) => {
        const token = localStorage.getItem('token');
        if (token) {
            config.headers.Authorization = `Bearer ${token}`;
        }
        return config;
    },
    (error) => Promise.reject(error)
);

// Interceptor РґР»СЏ РѕР±СЂР°Р±РѕС‚РєРё РѕС€РёР±РѕРє
axiosInstance.interceptors.response.use(
    (response) => response,
    (error: AxiosError) => {
        if (error.response?.status === 401) {
            localStorage.removeItem('token');
            localStorage.removeItem('auth_user');
            window.location.href = '/login';
        }
        return Promise.reject(error);
    }
);

export const setAuthToken = (token: string) => {
    axiosInstance.defaults.headers.common['Authorization'] = `Bearer ${token}`;
    localStorage.setItem('token', token);
};

export const getAuthToken = () => localStorage.getItem('token');

export const clearAuth = () => {
    delete axiosInstance.defaults.headers.common['Authorization'];
    localStorage.removeItem('token');
    localStorage.removeItem('auth_user');
};

export default axiosInstance;

--- C:\Users\boobi\source\workmain\src\frontend\src\services\authService.ts ---
import { api, setAuthToken, clearAuth } from '../api/client';
import { User, AuthResponse } from '../types/auth.types';

const AUTH_USER_STORAGE_KEY = 'auth_user';

export const authService = {
    login: async (login: string, password: string) => {
        const response = await api.Users.login(login, password); // ✅ через api
        if (response.data.token) {
            setAuthToken(response.data.token); // ✅ named import
        }
        return response.data;
    },

    register: async (userName: string, login: string, password: string) => {
        await api.Users.register(userName, login, password); // ✅
    },

    getStoredUser: (): User | null => {
        const user = localStorage.getItem(AUTH_USER_STORAGE_KEY);
        return user ? JSON.parse(user) : null;
    },

    saveUser: (user: User): void => {
        localStorage.setItem(AUTH_USER_STORAGE_KEY, JSON.stringify(user));
    },

    logout: () => {
        clearAuth(); // ✅ named import
    },

    isAuthenticated: (): boolean => {
        return !!localStorage.getItem('token');
    }
};

--- C:\Users\boobi\source\workmain\src\frontend\src\services\breaksService.ts ---
import axiosInstance from './api';
import { Break, StartBreakRequest, SkipBreakRequest } from '../types/break.types';

export const breaksService = {
    startBreak: async (breakNumber: number, durationMinutes: number): Promise<Break> => {
        const response = await axiosInstance.post<Break>('/breaks/create', {
            breakNumber,
            durationMinutes
        } as StartBreakRequest);
        return response.data;
    },

    endBreak: async (breakId: number): Promise<Break> => {
        const response = await axiosInstance.post<Break>(`/breaks/end/${breakId}`);
        return response.data;
    },

    skipBreak: async (breakNumber: number): Promise<Break> => {
        const response = await axiosInstance.post<Break>('/breaks/skip', {
            breakNumber
        } as SkipBreakRequest);
        return response.data;
    },

    getBreakStatusText: (status: number): string => {
        const statuses: Record<number, string> = {
            0: 'Доступен',
            1: 'В процессе',
            2: 'Завершен',
            3: 'Пропущен'
        };
        return statuses[status] || 'Неизвестно';
    },

    getBreakStatusClass: (status: number): string => {
        const classes: Record<number, string> = {
            0: 'badge-info',
            1: 'badge-warning',
            2: 'badge-success',
            3: 'badge-danger'
        };
        return classes[status] || 'badge-info';
    }
};

--- C:\Users\boobi\source\workmain\src\frontend\src\services\scheduleService.ts ---
import axiosInstance from './api';
import { Schedule } from '../types/dashboard.types';

export const scheduleService = {
    getAllSchedules: async (): Promise<Schedule[]> => {
        const response = await axiosInstance.get<Schedule[]>('/schedule/getall');
        return response.data;
    },

    getSchedule: async (id: number): Promise<Schedule> => {
        const response = await axiosInstance.get<Schedule>(`/schedule/${id}`);
        return response.data;
    },

    createSchedule: async (
        name: string,
        startTime: string,
        endTime: string
    ): Promise<Schedule> => {
        const response = await axiosInstance.post<Schedule>('/schedule/create', {
            name,
            startTime,
            endTime
        });
        return response.data;
    },

    updateSchedule: async (id: number, data: Partial<Schedule>): Promise<Schedule> => {
        const response = await axiosInstance.put<Schedule>(`/schedule/update/${id}`, data);
        return response.data;
    },

    deleteSchedule: async (id: number): Promise<void> => {
        await axiosInstance.post(`/schedule/${id}`);
    }
};

--- C:\Users\boobi\source\workmain\src\frontend\src\services\signalRService.ts ---
import { HubConnectionBuilder, HubConnection, LogLevel, HubConnectionState } from '@microsoft/signalr';

let connection: HubConnection | null = null;
let startPromise: Promise<HubConnection> | null = null;

export const getConnection = (): HubConnection | null => connection;

// Автоматически определяем правильный URL на основе VITE_API_URL, 
// чтобы избежать проблем с несоответствием портов или протоколов (CORS/ERR_CONNECTION_REFUSED)
const API_BASE_URL = import.meta.env.VITE_API_URL || 'https://localhost:7059/api';
const HUB_URL = API_BASE_URL.replace(/\/api\/?$/, '') + '/breakQueueHub';

export const startConnection = async (): Promise<HubConnection> => {
    // Если соединение уже установлено, возвращаем его
    if (connection?.state === HubConnectionState.Connected) {
        return connection;
    }

    // Если процесс подключения уже идет, не начинаем новый, а ждем текущий
    if (startPromise) {
        return startPromise;
    }

    connection = new HubConnectionBuilder()
        .withUrl(HUB_URL, {
            // Передаем JWT токен явно, решая проблему с cookie и CORS политиками
            accessTokenFactory: () => localStorage.getItem('token') || ''
        })
        .withAutomaticReconnect()
        .configureLogging(LogLevel.Information)
        .build();

    startPromise = connection.start()
        .then(() => {
            console.log(`SignalR Connected to ${HUB_URL}`);
            return connection!;
        })
        .catch((err) => {
            console.error(`SignalR Connection Error to ${HUB_URL}:`, err);
            startPromise = null;
            throw err;
        });

    return startPromise;
};

export const stopConnection = async () => {
    if (connection) {
        try {
            await connection.stop();
        } catch (err) {
            console.error('Error stopping SignalR connection:', err);
        } finally {
            connection = null;
            startPromise = null;
        }
    }
};

--- C:\Users\boobi\source\workmain\src\frontend\src\services\userService.ts ---
import axiosInstance from '../api/client';

export interface UserProfile {
    id: number;
    userName: string;
    login: string;
    role: string;
    totalShifts: number;
    totalBreaks: number;
    completedBreaks: number;
    skippedBreaks: number;
}

export interface UpdateProfileRequest {
    userName?: string;
}

export const userService = {
    getProfile: async (): Promise<UserProfile> => {
        const response = await axiosInstance.get('/users/profile');
        return response.data;
    },

    updateProfile: async (data: UpdateProfileRequest): Promise<UserProfile> => {
        const response = await axiosInstance.put('/users/profile', data);
        return response.data;
    },
};


--- C:\Users\boobi\source\workmain\src\frontend\src\services\userShiftService.ts ---
import axiosInstance from './api';
import { UserShift } from '../types/dashboard.types';

export const userShiftService = {
    startShift: async (
        scheduleId: number,
    ): Promise<UserShift> => {
        const response = await axiosInstance.post<UserShift>('/usershifts/start', {
            scheduleId,
        });
        return response.data;
    },

    getMyShift: async (workDate: string): Promise<UserShift> => {
        const response = await axiosInstance.get<UserShift>(`/usershifts/my/${workDate}`);
        return response.data;
    },

    getMyShifts: async (): Promise<UserShift[]> => {
        const response = await axiosInstance.get<UserShift[]>('/usershifts/my');
        return response.data;
    },

    deleteShift: async (userShiftId: number): Promise<void> => {
        await axiosInstance.delete(`/usershifts/${userShiftId}`);
    },

    getShiftsByDateAndGroup: async (
        workDate: string,
        group: 'Day' | 'Evening'
    ): Promise<UserShift[]> => {
        const response = await axiosInstance.get<UserShift[]>(
            `/usershifts/by-date-group/${workDate}/${group}`
        );
        return response.data;
    },
};


--- C:\Users\boobi\source\workmain\src\frontend\src\stores\authStore.ts ---
import { create } from 'zustand';
import { persist } from 'zustand/middleware';

interface User {
    id: number;
    userName: string;
    login: string;
    role: number;
}

interface AuthState {
    user: User | null;
    token: string | null;
    isAuthenticated: boolean;
    login: (user: User, token: string) => void;
    logout: () => void;
}

export const useAuthStore = create<AuthState>()(
    persist(
        (set) => ({
            user: null,
            token: null,
            isAuthenticated: false,

            login: (user, token) => {
                localStorage.setItem('token', token);
                set({ user, token, isAuthenticated: true });
            },

            logout: () => {
                localStorage.removeItem('token');
                set({ user: null, token: null, isAuthenticated: false });
            }
        }),
        {
            name: 'auth-storage',
            partialize: (state) => ({
                user: state.user,
                token: state.token,
                isAuthenticated: state.isAuthenticated
            })
        }
    )
);


--- C:\Users\boobi\source\workmain\src\frontend\src\types\admin.ts ---
export interface AdminUserDto {
    id: number;
    userName: string;
    login: string;
    role: string;
    totalShifts: number;
    totalBreaks: number;
    completedBreaks: number;
    skippedBreaks: number;
}

export interface DashboardStatsDto {
    totalUsers: number;
    totalShiftsToday: number;
    activeBreaks: number;
    completedBreaksToday: number;
    skippedBreaksToday: number;
    totalBreaksToday: number;
}

export interface UserShiftDetailDto {
    id: number;
    userId: number;
    userName: string;
    scheduleName: string;
    workDate: string;
    group: string;
    totalBreaks: number;
    activeBreaks: number;
    completedBreaks: number;
    skippedBreaks: number;
}

export interface CreateUserAdminDto {
    userName: string;
    login: string;
    password: string;
    role: string;
}

export interface UpdateUserAdminDto {
    userName?: string;
    login?: string;
    password?: string;
    role?: string;
}

// Пулы перерывов - используем СУЩЕСТВУЮЩИЙ DTO
export interface BreakPoolDayDto {
    id: number;
    group: number;
    workDate: string;
    maxCurrentBreaks: number;
    currentBreaksCount: number;
    availableBreaksCount: number;
}

export interface CreateBreakPoolDayDto {
    group: number;
    workDate: string;
    maxCurrentBreaks: number;
}

// Расписания
export interface Schedule {
    id: number;
    name: string;
    startTime: string;
    endTime: string;
}

export interface CreateScheduleDto {
    name: string;
    startTime: string;
    endTime: string;
}

export interface UpdateScheduleDto {
    name?: string;
    startTime?: string;
    endTime?: string;
}


--- C:\Users\boobi\source\workmain\src\frontend\src\types\auth.types.ts ---
export interface User {
  id: number;
  userName: string;
  login: string;
  role: 'User' | 'TeamLead' | 'Admin';
}

export interface AuthResponse {
  token: string;
}

export interface LoginRequest {
  login: string;
  password: string;
}

export interface RegisterRequest {
  userName: string;
  login: string;
  password: string;
}

export interface AuthContextType {
  user: User | null;
  token: string | null;
  login: (login: string, password: string) => Promise<void>;
  register: (userName: string, login: string, password: string) => Promise<void>;
  logout: () => void;
  isAuthenticated: boolean;
  loading: boolean;
}

--- C:\Users\boobi\source\workmain\src\frontend\src\types\break.ts ---
export interface Break {
    id: number;
    userShiftId: number;
    status: 'Available' | 'Taken' | 'Finished' | 'Skipped';
    durationMinutes: number;
    breakNumber: number;
    startTime?: string;
    endTime?: string;
    workDate: string;
}

export interface ActiveBreak {
    id: number;
    userId: number;
    userShiftId: number;
    status: 'Taken';
    durationMinutes: number;
    breakNumber: number;
    startTime: string;
    workDate: string;
}


--- C:\Users\boobi\source\workmain\src\frontend\src\types\dashboard.types.ts ---
import { Break } from './break.types';

export type ShiftType = 'Day' | 'Evening';

export interface UserShift {
    id: number;
    userId: number;
    scheduleId: number;
    workDate: string;
    group: ShiftType;
    schedule?: Schedule;
    breaks?: Break[];
}

export interface Schedule {
    id: number;
    name: string;
    startTime: string;
    endTime: string;
    shiftType: ShiftType;
}

export interface DashboardStats {
    totalBreaks: number;
    completedBreaks: number;
    remainingBreaks: number;
    currentBreakDuration: number;
}

export interface StartShiftRequest {
    scheduleId: number;
}

export interface BreakPoolDay {
    id: number;
    group: ShiftType;
    workDate: string;
    totalBreaks: number;
    availableBreaks: number;
}


--- C:\Users\boobi\source\workmain\src\frontend\src\types\index.ts ---
export type ShiftType = 'Day' | 'Evening';

export interface Schedule {
    id: number;
    name: string;
    startTime: string;
    endTime: string;
}

interface UserShift {
    id: number;
    userId: number;
    scheduleId: number;
    workDate: string;
    group: 'Day' | 'Evening';  // Добавить тип смены
    startedAt?: string;
    endedAt?: string;
    schedule?: Schedule;
    breaks?: Break[];
}


export interface User {
    id: number;
    userName: string;
    login: string;
    role: string;
}

export interface Break {
    id: number;
    userShiftId: number;
    status: string;
    durationMinutes: number;
    breakNumber: number;
    startTime: string;
    endTime?: string;
    workDate: string;
}

